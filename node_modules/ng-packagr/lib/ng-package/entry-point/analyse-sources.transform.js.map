{"version":3,"file":"analyse-sources.transform.js","sourceRoot":"","sources":["../../../../src/lib/ng-package/entry-point/analyse-sources.transform.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { pipe } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { isEntryPoint, EntryPointNode, isPackage, PackageNode } from '../nodes';\nimport { cacheCompilerHost } from '../../ts/cache-compiler-host';\nimport { BuildGraph } from '../../graph/build-graph';\nimport { Transform } from '../../graph/transform';\nimport { debug } from '../../utils/log';\nimport { ensureUnixPath } from '../../utils/path';\n\nexport const analyseSourcesTransform: Transform = pipe(\n  map(graph => {\n    const entryPoints: EntryPointNode[] = graph.filter(isEntryPoint);\n    const dirtyEntryPoints: EntryPointNode[] = entryPoints.filter(x => x.state !== 'done');\n\n    for (const entryPoint of dirtyEntryPoints) {\n      analyseEntryPoint(graph, entryPoint, entryPoints);\n    }\n\n    return graph;\n  }),\n);\n\n/**\n * Analyses an entrypoint, searching for TypeScript dependencies and additional resources (Templates and Stylesheets).\n *\n * @param graph Build graph\n * @param entryPoint Current entry point that should be analysed.\n * @param entryPoints List of all entry points.\n */\nfunction analyseEntryPoint(graph: BuildGraph, entryPoint: EntryPointNode, entryPoints: EntryPointNode[]) {\n  const { oldPrograms, analysesSourcesFileCache, moduleResolutionCache } = entryPoint.cache;\n  const oldProgram = oldPrograms && (oldPrograms['analysis'] as ts.Program | undefined);\n  const { moduleId } = entryPoint.data.entryPoint;\n  const packageNode: PackageNode = graph.find(isPackage);\n  const primaryModuleId = packageNode.data.primary.moduleId;\n\n  debug(`Analysing sources for ${moduleId}`);\n  const tsConfigOptions: ts.CompilerOptions = {\n    ...entryPoint.data.tsConfig.options,\n    skipLibCheck: true,\n    noLib: true,\n    noEmit: true,\n    types: [],\n    target: ts.ScriptTarget.Latest,\n    strict: false,\n  };\n\n  const compilerHost = cacheCompilerHost(\n    graph,\n    entryPoint,\n    tsConfigOptions,\n    moduleResolutionCache,\n    undefined,\n    analysesSourcesFileCache,\n    false,\n  );\n\n  const potentialDependencies = new Set<string>();\n\n  compilerHost.resolveTypeReferenceDirectives = (\n    moduleNames: string[],\n    containingFile: string,\n    redirectedReference: ts.ResolvedProjectReference | undefined,\n    options: ts.CompilerOptions,\n  ) => {\n    return moduleNames.map(moduleName => {\n      if (!moduleName.startsWith('.')) {\n        if (moduleName === primaryModuleId || moduleName.startsWith(`${primaryModuleId}/`)) {\n          potentialDependencies.add(moduleName);\n        }\n\n        return undefined;\n      }\n\n      const result = ts.resolveTypeReferenceDirective(\n        moduleName,\n        ensureUnixPath(containingFile),\n        options,\n        compilerHost,\n        redirectedReference,\n      ).resolvedTypeReferenceDirective;\n\n      return result;\n    });\n  };\n\n  compilerHost.resolveModuleNames = (\n    moduleNames: string[],\n    containingFile: string,\n    _reusedNames: string[] | undefined,\n    redirectedReference: ts.ResolvedProjectReference | undefined,\n    options: ts.CompilerOptions,\n  ) => {\n    return moduleNames.map(moduleName => {\n      if (!moduleName.startsWith('.')) {\n        if (moduleName === primaryModuleId || moduleName.startsWith(`${primaryModuleId}/`)) {\n          potentialDependencies.add(moduleName);\n        }\n\n        return undefined;\n      }\n\n      const { resolvedModule } = ts.resolveModuleName(\n        moduleName,\n        ensureUnixPath(containingFile),\n        options,\n        compilerHost,\n        moduleResolutionCache,\n        redirectedReference,\n      );\n\n      return resolvedModule;\n    });\n  };\n\n  const program: ts.Program = ts.createProgram(\n    entryPoint.data.tsConfig.rootNames,\n    tsConfigOptions,\n    compilerHost,\n    oldProgram,\n  );\n\n  debug(`tsc program structure is reused: ${oldProgram ? (oldProgram as any).structureIsReused : 'No old program'}`);\n\n  entryPoint.cache.oldPrograms = { ...entryPoint.cache.oldPrograms, ['analysis']: program };\n\n  const entryPointsMapped: Record<string, EntryPointNode> = {};\n  for (const dep of entryPoints) {\n    entryPointsMapped[dep.data.entryPoint.moduleId] = dep;\n  }\n\n  for (const moduleName of potentialDependencies) {\n    const dep = entryPointsMapped[moduleName];\n\n    if (dep) {\n      debug(`Found entry point dependency: ${moduleId} -> ${moduleName}`);\n\n      if (moduleId === moduleName) {\n        throw new Error(`Entry point ${moduleName} has a circular dependency on itself.`);\n      }\n\n      if (dep.some(n => entryPoint === n)) {\n        throw new Error(`Entry point ${moduleName} has a circular dependency on ${moduleId}.`);\n      }\n\n      entryPoint.dependsOn(dep);\n    } else {\n      throw new Error(`Entry point ${moduleName} which is required by ${moduleId} doesn't exists.`);\n    }\n  }\n}\n"]}