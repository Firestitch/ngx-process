import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Inject, InjectionToken, Injectable, Input, NgModule, CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i3 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i1 from '@angular/material/dialog';
import { MAT_DIALOG_DATA, MatDialogModule } from '@angular/material/dialog';
import * as i2 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import { remove, merge } from 'lodash-es';
import { Subject, isObservable, of } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i1$1 from 'ngx-toastr';
import { TOAST_CONFIG } from 'ngx-toastr';

class FsMessageDialogComponent {
    constructor(data, dialogRef) {
        this.data = data;
        this.dialogRef = dialogRef;
        this._destroy$ = new Subject();
    }
    hide() {
        this.dialogRef.close();
    }
    buttonClick(button) {
        if (button.click) {
            const result = button.click();
            const observable$ = isObservable(result) ? result : of(true);
            observable$
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this.hide();
            });
        }
        else {
            this.hide();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
}
FsMessageDialogComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageDialogComponent, deps: [{ token: MAT_DIALOG_DATA }, { token: i1.MatDialogRef }], target: i0.ɵɵFactoryTarget.Component });
FsMessageDialogComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMessageDialogComponent, selector: "fs-message-dialog", ngImport: i0, template: "<div class=\"fs-message-{{ data.type }}\">\n  <div mat-dialog-title fxLayout=\"row\" fxLayoutAlign=\"start center\">\n    <mat-icon>{{ data.icon }}</mat-icon>\n    <span>{{ data.options.title }}</span>\n  </div>\n  <mat-dialog-content [innerHTML]=\"data.message\"></mat-dialog-content>\n  <mat-dialog-actions>\n    <button mat-button (click)=\"hide()\" *ngIf=\"!data.options.buttons\" color=\"primary\">OK</button>\n    <button mat-button *ngFor=\"let button of data.options.buttons || []\" (click)=\"buttonClick(button)\" [color]=\"button.color\">{{button.label}}</button>\n  </mat-dialog-actions>\n</div>\n", styles: [":host .mat-dialog-title{display:flex;flex-direction:row;align-items:center}\n"], components: [{ type: i2.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i3.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }], directives: [{ type: i1.MatDialogTitle, selector: "[mat-dialog-title], [matDialogTitle]", inputs: ["id"], exportAs: ["matDialogTitle"] }, { type: i1.MatDialogContent, selector: "[mat-dialog-content], mat-dialog-content, [matDialogContent]" }, { type: i1.MatDialogActions, selector: "[mat-dialog-actions], mat-dialog-actions, [matDialogActions]" }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageDialogComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-message-dialog',
                    templateUrl: './message-dialog.component.html',
                    styleUrls: ['./message-dialog.component.css'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_DIALOG_DATA]
                }] }, { type: i1.MatDialogRef }]; } });

var MessageType;
(function (MessageType) {
    MessageType["Success"] = "success";
    MessageType["Info"] = "info";
    MessageType["Error"] = "error";
    MessageType["Warning"] = "warning";
})(MessageType || (MessageType = {}));
var MessageMode;
(function (MessageMode) {
    MessageMode["Dialog"] = "dialog";
    MessageMode["Toast"] = "toast";
    MessageMode["Banner"] = "banner";
})(MessageMode || (MessageMode = {}));

const FS_MESSAGE_CONFIG = new InjectionToken('fs-message.config');
const FS_MESSAGE_DEFAULT_CONFIG = new InjectionToken('fs-message.default-config');

class FsMessage {
    constructor(toastr, matDialog, _toastToken, _config) {
        this.toastr = toastr;
        this.matDialog = matDialog;
        this._toastToken = _toastToken;
        this._config = _config;
        this.bannerMessages$ = new Subject();
        this._dialogs = 0;
        this._dialogsMessagesQueue = [];
        this._destroy$ = new Subject();
    }
    success(message, options = {}) {
        return this.show(MessageType.Success, message, Object.assign({ title: 'Success', mode: this._config.successMode }, options));
    }
    info(message, options = {}) {
        return this.show(MessageType.Info, message, Object.assign({ title: 'Information', mode: this._config.infoMode }, options));
    }
    error(message, options = {}) {
        return this.show(MessageType.Error, message, Object.assign({ title: 'Attention', mode: this._config.errorMode }, options));
    }
    warning(message, options = {}) {
        return this.show(MessageType.Warning, message, Object.assign({ title: 'Warning', mode: this._config.warningMode }, options));
    }
    show(type, message, options) {
        options = options || {};
        if (options.icon === undefined) {
            options.icon = this.getIconName(type);
        }
        switch (options.mode) {
            case MessageMode.Toast:
                this.toast(type, message, options);
                break;
            case MessageMode.Banner:
                this.banner(type, message, options);
                break;
            case MessageMode.Dialog:
                return this.dialog(type, message, options);
        }
        return of();
    }
    hide() {
        this.toastr.clear();
        this.bannerMessages$.next();
        this.matDialog.closeAll();
    }
    toast(type, message, options) {
        const opts = options;
        opts.enableHtml = true;
        opts.positionClass = options.positionClass || this._toastToken.config.positionClass || 'toast-bottom-left';
        opts.timeOut = (options.timeout || this._config.toastTimeout) * 1000;
        const icon = opts.icon ? `<div class="mat-icon material-icons">${opts.icon}</div>` : '';
        const template = `<div class="mat-toast-content">${icon}<div class="message">${message}</div></div>`;
        this.toastr[type](template, '', opts);
    }
    banner(type, message, options) {
        this.bannerMessages$.next({
            type: type,
            msg: message,
            timeout: (options.timeout || this._config.bannerTimeout || 5) * 1000
        });
    }
    dialog(type, message, options) {
        const typeMessage = type + message;
        if (this._dialogsMessagesQueue.indexOf(typeMessage) > -1) {
            return of(true);
        }
        this._dialogsMessagesQueue.push(typeMessage);
        this._dialogs++;
        const dialogRef = this.matDialog.open(FsMessageDialogComponent, {
            /* Waiting for MatDialog to support array of classes like panelClass
            backdropClass: ['fs-message-backdrop',
                            'fs-message-backdrop-' + type,
                            options.backdropClass], */
            backdropClass: options.backdropClass,
            width: options.width || this._config.dialogWidth,
            data: { type: type, message: message, options: options, icon: this.getIconName(type) },
            panelClass: [
                'fs-message-pane',
                'fs-message-pane-' + type,
                options.panelClass,
            ],
        });
        dialogRef.afterClosed()
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this._dialogs--;
            const dialogMessageIdx = this._dialogsMessagesQueue.indexOf(typeMessage);
            if (dialogMessageIdx > -1) {
                this._dialogsMessagesQueue.splice(dialogMessageIdx, 1);
            }
        });
        return dialogRef.afterClosed();
    }
    getIconName(type) {
        switch (type) {
            case MessageType.Success:
                return 'done';
            case MessageType.Error:
                return 'report_problem';
            case MessageType.Info:
                return 'info';
            case MessageType.Warning:
                return 'report_problem';
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
}
FsMessage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessage, deps: [{ token: i1$1.ToastrService }, { token: i1.MatDialog }, { token: TOAST_CONFIG }, { token: FS_MESSAGE_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
FsMessage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessage });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessage, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.ToastrService }, { type: i1.MatDialog }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [TOAST_CONFIG]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [FS_MESSAGE_CONFIG]
                }] }]; } });

class FsMessageComponent {
    constructor(_fsMessage) {
        this._fsMessage = _fsMessage;
        this.type = MessageType.Info;
        this.icon = 'info';
    }
    set fsType(value) {
        this.type = value;
    }
    set fsMessage(value) {
        this.message = value;
    }
    ngOnInit() {
        this.icon = this._fsMessage.getIconName(this.type);
    }
}
FsMessageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageComponent, deps: [{ token: FsMessage }], target: i0.ɵɵFactoryTarget.Component });
FsMessageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMessageComponent, selector: "fs-message", inputs: { type: "type", message: "message", fsType: "fsType", fsMessage: "fsMessage" }, ngImport: i0, template: "<div class=\"fs-message-banner fs-message-{{ type }}\">\n  <mat-icon *ngIf=\"icon\" class=\"mat-icon material-icons\" role=\"img\">{{ icon }}</mat-icon>\n  <div class=\"message\">\n    {{ message }}\n    <ng-content></ng-content>\n  </div>\n</div>\n", components: [{ type: i2.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-message',
                    templateUrl: './message.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FsMessage }]; }, propDecorators: { type: [{
                type: Input
            }], message: [{
                type: Input
            }], fsType: [{
                type: Input,
                args: ['fsType']
            }], fsMessage: [{
                type: Input,
                args: ['fsMessage']
            }] } });

class FsMessagesComponent {
    constructor(_fsMessage, _cdRef) {
        this._fsMessage = _fsMessage;
        this._cdRef = _cdRef;
        this.messages = [];
        this._destroy$ = new Subject();
    }
    ngOnInit() {
        this._fsMessage
            .bannerMessages$
            .pipe(takeUntil(this._destroy$))
            .subscribe((message) => {
            if (!message) {
                this.messages = [];
            }
            else {
                this.messages.push(message);
                if (message.timeout) {
                    setTimeout(() => {
                        remove(this.messages, (item) => {
                            return item === message;
                        });
                        this._cdRef.markForCheck();
                    }, message.timeout);
                }
            }
            this._cdRef.markForCheck();
        });
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
}
FsMessagesComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessagesComponent, deps: [{ token: FsMessage }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsMessagesComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsMessagesComponent, selector: "fs-messages", ngImport: i0, template: `<fs-message *ngFor="let item of messages" [fsType]="item.type" [fsMessage]="item.msg"></fs-message>`, isInline: true, components: [{ type: FsMessageComponent, selector: "fs-message", inputs: ["type", "message", "fsType", "fsMessage"] }], directives: [{ type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessagesComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-messages',
                    template: `<fs-message *ngFor="let item of messages" [fsType]="item.type" [fsMessage]="item.msg"></fs-message>`,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: FsMessage }, { type: i0.ChangeDetectorRef }]; } });

class FsMessageModule {
    static forRoot(config = {}) {
        return {
            ngModule: FsMessageModule,
            providers: [
                FsMessage,
                { provide: FS_MESSAGE_DEFAULT_CONFIG, useValue: config },
                {
                    provide: FS_MESSAGE_CONFIG,
                    useFactory: FsMessageConfigFactory,
                    deps: [FS_MESSAGE_DEFAULT_CONFIG]
                },
            ]
        };
    }
}
FsMessageModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsMessageModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageModule, declarations: [FsMessagesComponent,
        FsMessageComponent,
        FsMessageDialogComponent], imports: [CommonModule,
        MatDialogModule,
        MatIconModule,
        MatButtonModule], exports: [FsMessagesComponent,
        FsMessageComponent] });
FsMessageModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageModule, imports: [[
            CommonModule,
            MatDialogModule,
            MatIconModule,
            MatButtonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsMessageModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatDialogModule,
                        MatIconModule,
                        MatButtonModule
                    ],
                    exports: [
                        FsMessagesComponent,
                        FsMessageComponent
                    ],
                    entryComponents: [
                        FsMessageDialogComponent
                    ],
                    declarations: [
                        FsMessagesComponent,
                        FsMessageComponent,
                        FsMessageDialogComponent
                    ],
                    schemas: [CUSTOM_ELEMENTS_SCHEMA]
                }]
        }] });
function FsMessageConfigFactory(config) {
    return merge({
        toastTimeout: 5,
        bannerTimeout: 5,
        dialogWidth: '500px',
        successMode: MessageMode.Toast,
        errorMode: MessageMode.Dialog,
        warningMode: MessageMode.Toast,
        infoMode: MessageMode.Toast
    }, config);
}

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsMessage, FsMessageComponent, FsMessageModule, FsMessagesComponent, MessageMode, MessageType };
//# sourceMappingURL=firestitch-message.js.map
