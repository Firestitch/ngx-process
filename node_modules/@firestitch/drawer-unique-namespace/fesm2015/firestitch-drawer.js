import { __decorate, __metadata, __param } from 'tslib';
import { ViewChild, Component, ChangeDetectionStrategy, InjectionToken, ElementRef, Injector, Injectable, ChangeDetectorRef, Input, NgZone, ViewEncapsulation, Directive, EventEmitter, Renderer2, HostBinding, ContentChildren, QueryList, TemplateRef, Output, Optional, SkipSelf, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, PortalInjector, PortalModule } from '@angular/cdk/portal';
import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatTooltipModule } from '@angular/material/tooltip';
import { FsMenuModule } from '@firestitch/menu';
import { Subject, BehaviorSubject, Observable, zip, fromEvent, merge } from 'rxjs';
import { ESCAPE } from '@angular/cdk/keycodes';
import { takeUntil, filter, take, debounceTime } from 'rxjs/operators';
import { Breakpoints, BreakpointObserver } from '@angular/cdk/layout';

var FsDrawerAction;
(function (FsDrawerAction) {
    FsDrawerAction["Button"] = "button";
    FsDrawerAction["Menu"] = "menu";
    FsDrawerAction["Component"] = "component";
})(FsDrawerAction || (FsDrawerAction = {}));

class BaseAction {
    constructor(data = {}) {
        this._visible = true;
        this._icon = data.icon || '';
        this._click = data.click || null;
        this._link = data.link;
        this._show = data.show || null;
    }
    get icon() {
        return this._icon;
    }
    get click() {
        return this._click;
    }
    get routerLink() {
        return this._routerLink;
    }
    get visible() {
        return this._visible;
    }
    checkVisibility(data) {
        if (this._show) {
            this._visible = this._show(data);
        }
    }
    updateRouterLink(data) {
        if (this._visible && this._link) {
            this._routerLink = this._link(data);
        }
    }
}

class MenuAction extends BaseAction {
    constructor(data = {}) {
        super(data);
        this.actions = [];
        this._isGroup = false;
        if (Array.isArray(data.actions)) {
            this._isGroup = true;
            this.actions = data.actions.map((action) => new MenuAction(action));
        }
        this._label = data.label || '';
    }
    get isGroup() {
        return this._isGroup;
    }
    get label() {
        return this._label;
    }
    updateRouterLink(data) {
        super.updateRouterLink(data);
        if (this.actions.length > 0) {
            this.actions.forEach((action) => {
                action.updateRouterLink(data);
            });
        }
    }
    checkVisibility(data) {
        super.checkVisibility(data);
        if (this.actions.length > 0) {
            this.actions.forEach((action) => {
                action.checkVisibility(data);
            });
        }
        if (this.actions.length > 0) {
            this._visible = this.actions.some((action) => action.visible);
        }
    }
}

class Action extends BaseAction {
    constructor(data = {}) {
        super(data);
        this._data = null;
        this._close = false;
        this._closeSide = true;
        this._menuActions = [];
        this._component = null;
        this._menuRefName = null;
        this._icon = data.icon || '';
        this._type = data.type || '';
        this._name = data.name || '';
        this._toggle = data.toggle === void 0 ? true : data.toggle;
        this._tooltip = data.tooltip || '';
        this._close = !!data.close;
        this._component = data.component || null;
        this._data = data.data === void 0 ? {} : data.data;
        if (this._type === FsDrawerAction.Component) {
            this._menuRefName = data.name || data.icon;
        }
        if (this._type === FsDrawerAction.Menu && data.closeSide === void 0) {
            this._closeSide = false;
        }
        else {
            this._closeSide = data.closeSide === void 0 ? true : !!data.closeSide;
        }
        if (Array.isArray(data.actions)) {
            this._menuActions = data.actions.map((action) => new MenuAction(action));
        }
    }
    get icon() {
        return this._icon;
    }
    set icon(value) {
        this._icon = value;
    }
    get type() {
        return this._type;
    }
    get toggle() {
        return this._toggle;
    }
    get name() {
        return this._name;
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(value) {
        this._tooltip = value;
    }
    get close() {
        return this._close;
    }
    get closeSide() {
        return this._closeSide;
    }
    get menuActions() {
        return this._menuActions;
    }
    get component() {
        return this._component;
    }
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value;
    }
    get menuRefName() {
        return this._menuRefName;
    }
    updateRouterLink(data) {
        if (this._visible) {
            super.updateRouterLink(data);
            if (this._menuActions.length > 0) {
                this._menuActions.forEach((action) => {
                    action.updateRouterLink(data);
                });
            }
        }
    }
    checkVisibility(data) {
        super.checkVisibility(data);
        if (this._menuActions.length > 0) {
            this._menuActions.forEach((action) => {
                action.checkVisibility(data);
            });
        }
        if (this.menuActions.length > 0) {
            this._visible = this.menuActions.some((action) => action.visible);
        }
    }
}

class DrawerConfig {
    constructor(data = {}) {
        this.disableClose = data.disableClose || false;
        this.position = data.position || 'right';
        this.activeAction = data.activeAction || '';
        this.resizable = data.resizable === void 0 ? true : data.resizable;
        if (data.width) {
            this.width = data.width;
        }
        this.actions = data.actions && data.actions.map((action) => new Action(action)) || null;
    }
}

class DrawerRef {
    constructor(_overlayRef, _dataFactory, _config) {
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the drawer has finished opening. */
        this._afterOpened$ = new Subject();
        /** Subject for notifying the user that the drawer has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._closeStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started opening. */
        this._openStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._sideToggle = new Subject();
        /** Subject for notifying the user that the drawer has finished opening. */
        this._actionsUpdated$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._activeAction = new BehaviorSubject(void 0);
        this._menuRefs = new Map();
        this._isOpen = false;
        this._isSideOpen = false;
        this.drawerConfig = new DrawerConfig(_config);
        this._activeAction.next(this.drawerConfig.activeAction);
    }
    get overlayRef() {
        return this._overlayRef;
    }
    /**
     * Getter for DRAWER_DATA for current drawer
     */
    get drawerData() {
        return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
    }
    get destroy$() {
        return this._destroy$.asObservable();
    }
    /**
     * Set reference to drawer container
     * @param value
     */
    set containerRef(value) {
        this._drawerContainerRef = value;
    }
    /**
     * Set reference to drawer component
     * @param value
     */
    set componentRef(value) {
        this._drawerComponentRef = value;
    }
    set drawerContentContainer(value) {
        this._drawerContentContainer = value;
    }
    set drawerActionsContainer(value) {
        this._drawerActionsContainer = value;
    }
    get drawerContentContainer() {
        return this._drawerContentContainer;
    }
    get drawerActionsContainer() {
        return this._drawerActionsContainer;
    }
    get activeAction() {
        return this._activeAction.getValue();
    }
    get activeAction$() {
        return this._activeAction.pipe(takeUntil(this._destroy$));
    }
    /**
     * Return actual status of the drawer
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * Return actual status of the side of the drawer
     */
    get isSideOpen() {
        return this._isSideOpen;
    }
    set resizeController(value) {
        this._resizeController = value;
    }
    get resizeController() {
        return this._resizeController;
    }
    /**
     * Gets an observable that action was updated and change detection should be started
     */
    get actionUpdated$() {
        return this._actionsUpdated$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    get afterClosed$() {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    get afterOpened$() {
        return this._afterOpened$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog open starts.
     */
    get openStart$() {
        return this._openStart$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    get closeStart$() {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when data in DRAWER_DATA was changed
     */
    get dataChanged$() {
        return this._dataFactory.dataChange$;
    }
    /**
     * Gets an observable that is notify that side status toggled
     */
    get sideToggle$() {
        return this._sideToggle.pipe(takeUntil(this._destroy$));
    }
    /**
     * Subscribe on keydown events to react on escape
     */
    events() {
        this._overlayRef.keydownEvents()
            .pipe(filter(event => event.keyCode === ESCAPE && !this.drawerConfig.disableClose), takeUntil(this._destroy$))
            .subscribe(() => this.close());
    }
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    dataChange(data) {
        this._dataFactory.setValue(data);
    }
    /**
     * Open drawer and notify observable
     */
    open() {
        new Observable((obs) => {
            setTimeout(() => {
                if (this._openStart$.observers.length) {
                    this._openStart$.next(obs);
                }
                else {
                    obs.next();
                    obs.complete();
                }
            });
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                if (this.activeAction) {
                    this.openSide();
                }
                this._drawerContainerRef.open();
                this._afterOpened$.next();
                this._afterOpened$.complete();
            },
            error: () => {
                this.destroy();
            },
        });
    }
    /**
     * Close the drawer.
     * @param result Optional result to return to the dialog opener.
     */
    close(result) {
        new Observable(observer => {
            if (this._closeStart$.observers.length) {
                zip(...this._closeStart$.observers.map(item => {
                    return Observable.create(closeObserver => {
                        item.next(closeObserver);
                    });
                }))
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => {
                    observer.next();
                    observer.complete();
                }, () => {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                this._drawerContainerRef.close();
                this._result = result;
                this._afterClosed$.next(result);
                this.destroy();
            }
        });
    }
    /**
     * Open the side of the drawer
     */
    openSide() {
        this._isSideOpen = true;
        this._sideToggle.next(this._isSideOpen);
    }
    /**
     * Close the side of the drawer
     */
    closeSide() {
        this._isSideOpen = false;
        this._sideToggle.next(this._isSideOpen);
        this.setActiveAction(null);
    }
    /**
     * Toggle the side of the drawer
     */
    toggleSide() {
        this.isSideOpen ? this.closeSide() : this.openSide();
    }
    /**
     * Change active action
     * @param name
     */
    setActiveAction(name) {
        this._activeAction.next(name);
        if (name) {
            this.openSide();
        }
    }
    /**
     * Store opened menu reference and subscribe for auto remove
     * @param name
     * @param ref
     */
    addMenuRef(name, ref) {
        this._menuRefs.set(name, ref);
        ref.afterClosed()
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._menuRefs.delete(name);
        });
    }
    /**
     * Get opened menu reference by name
     * @param name
     */
    getMenuRef(name) {
        return this._menuRefs.get(name);
    }
    getAction(name) {
        return this.drawerConfig.actions.find((action) => action.name === name);
    }
    /**
     * Do update for icon for target action
     * @param name
     * @param icon
     */
    updateActionIcon(name, icon) {
        const action = this.getAction(name);
        if (action) {
            action.icon = icon;
            this._actionsUpdated$.next(name);
        }
    }
    /**
     * Do update
     * @param name
     * @param data
     */
    updateAction(name, data) {
        const action = this.getAction(name);
        if (action) {
            const allowedFields = ['icon', 'type', 'toggle', 'tooltip', 'close', 'closeSide', 'component', 'data'];
            const forUpdate = Object.keys(data).filter((key) => allowedFields.indexOf(key) > -1);
            forUpdate.forEach((key) => {
                action[key] = data[key];
            });
            this._actionsUpdated$.next(name);
        }
    }
    updateDrawerWidth(width) {
        this.resizeController.updateMainWidth(width);
    }
    updateSideDrawerWidth(width) {
        this.resizeController.updateSideWidth(width);
    }
    destroy() {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._drawerComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    }
}

let FsDrawerMenuComponent = class FsDrawerMenuComponent extends BasePortalOutlet {
    constructor() {
        super();
    }
    setDrawerMenuRef(value) {
        this.ref = value;
        // this.config = this.externalMenuRef.config;
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    }
};
__decorate([
    ViewChild(CdkPortalOutlet, { static: true }),
    __metadata("design:type", CdkPortalOutlet)
], FsDrawerMenuComponent.prototype, "_portalOutlet", void 0);
FsDrawerMenuComponent = __decorate([
    Component({
        selector: 'fs-drawer-menu',
        template: "<ng-template cdkPortalOutlet></ng-template>\n",
        host: {
            'class': 'mat-elevation-z2'
        },
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{padding:15px;background:#fff;border-radius:2px;overflow:auto}"]
    }),
    __metadata("design:paramtypes", [])
], FsDrawerMenuComponent);

class DrawerMenuRef {
    constructor(_overlayRef, _dataFactory) {
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the menu has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the menu has started closing. */
        this._closeStart$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._overlayRef.backdropClick()
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this.close();
        });
    }
    /**
     * Getter for DRAWER_MENU_DATA for current drawer
     */
    get menuData() {
        return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
    }
    /**
     * Set reference to menu container
     * @param value
     */
    set containerRef(value) {
        this._externalMenuContainerRef = value;
    }
    /**
     * Set reference to menu component
     * @param value
     */
    set componentRef(value) {
        this._externalMenuComponentRef = value;
    }
    /**
     * Gets an observable that is notified when data in DRAWER_DATA was changed
     */
    get dataChanged$() {
        return this._dataFactory.dataChange$;
    }
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    dataChange(data) {
        this._dataFactory.setValue(data);
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    afterClosed() {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    closeStart() {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Close the menu.
     * @param result Optional result to return to the dialog opener.
     */
    close(result) {
        new Observable(observer => {
            if (this._closeStart$.observers.length) {
                zip(...this._closeStart$.observers.map(item => {
                    return Observable.create(closeObserver => {
                        item.next(closeObserver);
                    });
                }))
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => {
                    observer.next();
                    observer.complete();
                }, () => {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                this._result = result;
                this._afterClosed$.next(result);
                this.destroy();
            }
        });
    }
    destroy() {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    }
}

class DrawerData {
    constructor(data = {}) {
        this._dataChange = new Subject();
        this._destroy = new Subject();
        this._data = data;
    }
    static createWithProxy(data = {}) {
        const drawerData = new DrawerData(data);
        return new Proxy(drawerData, {
            get(target, property) {
                if (typeof target[property] === 'function'
                    || property === '_data'
                    || target[property] instanceof Observable) {
                    return target[property];
                }
                else {
                    return target._data[property];
                }
            },
            set(target, property, value) {
                if (property !== '_data') {
                    target._data[property] = value;
                }
                else {
                    target[property] = value;
                }
                return true;
            },
            has(target, property) {
                return property in target._data;
            },
            ownKeys(target) {
                return Object.keys(target._data);
            },
            enumerate(target) {
                return Object.keys(target._data);
            },
            getOwnPropertyDescriptor(target, property) {
                return Object.getOwnPropertyDescriptor(target._data, property);
            }
        });
    }
    get dataChange$() {
        return this._dataChange.pipe(takeUntil(this._destroy));
    }
    getValue() {
        return this._data;
    }
    setValue(value) {
        this._data = value;
        this._dataChange.next(this._data);
    }
    destroy() {
        this._destroy.next();
        this._destroy.complete();
    }
}

/** Injection token that can be used to access the data that was passed in to a drawer. */
const DRAWER_MENU_DATA = new InjectionToken('fs.drawer.menu-data');

let FsDrawerMenuService = class FsDrawerMenuService {
    constructor(_overlay, _injector, _breakpointObserver) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._breakpointObserver = _breakpointObserver;
    }
    create(component, container, config) {
        const overlayRef = this.createOverlay(container);
        const dataFactory = DrawerData.createWithProxy(config.data);
        const menuRef = new DrawerMenuRef(overlayRef, dataFactory);
        const containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
        const componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
        menuRef.containerRef = containerRef;
        containerRef.setDrawerMenuRef(menuRef);
        menuRef.componentRef = componentRef;
        return menuRef;
    }
    createOverlay(container) {
        const overlayConfig = this.getOverlayConfig(container);
        return this._overlay.create(overlayConfig);
    }
    getOverlayConfig(container) {
        const element = new ElementRef(container); // positionStrategy needs ElementRef;
        let strategy = null;
        if (this._breakpointObserver.isMatched(Breakpoints.XSmall)) {
            strategy = this._overlay
                .position()
                .global()
                .centerHorizontally()
                .centerVertically();
        }
        else {
            const positions = [
                { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
            ];
            strategy = this._overlay
                .position()
                .flexibleConnectedTo(element)
                .withPositions(positions);
        }
        return new OverlayConfig({
            positionStrategy: strategy,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop'
        });
    }
    attachContainer(overlayRef, menuRef, dataFactory) {
        const injector = this.createInjector(menuRef, dataFactory);
        const containerPortal = new ComponentPortal(FsDrawerMenuComponent, undefined, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    attachComponent(componentRef, externalContainer, externalRef, config) {
        const injector = this.createInjector(externalRef, config);
        return externalContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    }
    createInjector(componentRef, dataFactory) {
        const injectionTokens = new WeakMap([
            [DrawerMenuRef, componentRef],
            [DRAWER_MENU_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    }
};
FsDrawerMenuService.ctorParameters = () => [
    { type: Overlay },
    { type: Injector },
    { type: BreakpointObserver }
];
FsDrawerMenuService = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [Overlay,
        Injector,
        BreakpointObserver])
], FsDrawerMenuService);

let FsDrawerActionsComponent = class FsDrawerActionsComponent {
    constructor(_drawerRef, _drawerMenu, _cdRef) {
        this._drawerRef = _drawerRef;
        this._drawerMenu = _drawerMenu;
        this._cdRef = _cdRef;
        this._destroy$ = new Subject();
    }
    ngOnInit() {
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    actionClick(action, event) {
        const hasComponentType = action.type === FsDrawerAction.Component;
        const hasMenuType = action.type === FsDrawerAction.Menu;
        if (hasComponentType) {
            const menuRef = this._drawerMenu.create(action.component, event.srcElement, action);
            this._drawerRef.addMenuRef(action.menuRefName, menuRef);
            const params = {
                event: event,
                action: action,
                drawerRef: this._drawerRef,
                menuRef: menuRef
            };
            // Call click
            action.click.call(null, params);
            if (action.closeSide) {
                this._drawerRef.closeSide();
            }
        }
        else if (action.click) {
            const params = { event: event, action: action };
            action.click.call(null, params);
        }
        if (action.close) {
            this._drawerRef.close();
        }
        if (action.toggle && ((!hasComponentType && !hasMenuType) || action.closeSide)) {
            if (this._drawerRef.isSideOpen && this._drawerRef.activeAction === action.name) {
                this._drawerRef.toggleSide();
            }
            else {
                this._drawerRef.setActiveAction(action.name);
            }
        }
    }
};
FsDrawerActionsComponent.ctorParameters = () => [
    { type: DrawerRef },
    { type: FsDrawerMenuService },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Array)
], FsDrawerActionsComponent.prototype, "actions", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FsDrawerActionsComponent.prototype, "activeAction", void 0);
FsDrawerActionsComponent = __decorate([
    Component({
        selector: 'fs-drawer-actions',
        template: "<div class=\"actions-container\">\n  <div *ngFor=\"let action of actions\" class=\"action-btn\">\n    <fs-drawer-action-item [action]=\"action\"\n                           [activeAction]=\"activeAction\"\n                           (actionClicked)=\"actionClick(action, $event)\">\n    </fs-drawer-action-item>\n  </div>\n</div>\n\n<div class=\"drag-icon\">\n  <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [":host{display:flex}.actions-container{flex:0}.drag-icon{display:flex;flex:1;align-items:center}"]
    }),
    __metadata("design:paramtypes", [DrawerRef,
        FsDrawerMenuService,
        ChangeDetectorRef])
], FsDrawerActionsComponent);

const MAIN_DRAWER_DEFAULT_WIDTH = 500;
const SIDE_DRAWER_DEFAULT_WIDTH = 200;
const SIDE_RESIZE_BAR_WIDTH = 25;
const MAIN_RESIZE_ACTION_BAR_WIDTH = 40;
let DrawerSizeController = class DrawerSizeController {
    constructor(_drawerRef, _ngZone) {
        this._drawerRef = _drawerRef;
        this._ngZone = _ngZone;
        this._sideOpened = false;
        this._borderPadding = 0;
        this._destroy$ = new Subject();
        this._initDefaultConfigs();
        this._updateScreenWidth();
        this._listenWindowResize();
        this._listenSideToggle();
    }
    get mainElRef() {
        return this._mainElRef;
    }
    get sideElRef() {
        return this._sideElRef;
    }
    get mainConfig() {
        return this._mainConfig;
    }
    get sideConfig() {
        return this._sideConfig;
    }
    get screenWidth() {
        return this._screenWidth;
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    registerElRef(el) {
        if (el.type === 'main') {
            this._registerMainRef(el);
        }
        else if (el.type === 'side') {
            this._registerSideRef(el);
        }
        else {
            throw Error('Unrecognized resize element type');
        }
    }
    getInitialWidth(type) {
        if (type === 'main') {
            return this.mainConfig.initial;
        }
        else if (type === 'side') {
            return this.sideConfig.initial;
        }
        else {
            return void 0;
        }
    }
    getMinWidth(type) {
        if (type === 'main') {
            return this.mainConfig.min;
        }
        else if (type === 'side') {
            return this.sideConfig.min;
        }
        else {
            return void 0;
        }
    }
    getMaxWidth(type) {
        if (type === 'main') {
            return this.mainConfig.max;
        }
        else if (type === 'side') {
            return this.sideConfig.max;
        }
        else {
            return void 0;
        }
    }
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    updateMainWidth(width) {
        const sideWidth = (this.sideElRef && this.sideElRef.width) || 0;
        this.mainElRef.updateWidth(sideWidth + width);
    }
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    updateSideWidth(width) {
        if (this.sideElRef) {
            const currentWidth = this.mainElRef.width - this.sideElRef.width;
            this.mainElRef.updateWidth(currentWidth + width);
            this.sideElRef.updateWidth(width);
        }
    }
    /**
     * Push current drawer to be visible under new one opened
     * @param inFrontDrawer
     */
    pushMainWidth(inFrontDrawer) {
        const inFrontDrawerTotalWidth = inFrontDrawer.resizeController.mainElRef.width + MAIN_RESIZE_ACTION_BAR_WIDTH;
        if (this.mainElRef.width <= inFrontDrawerTotalWidth) {
            this.updateMainWidth(inFrontDrawerTotalWidth);
        }
    }
    /**
     * Listen for browser resize and update restrictions
     */
    _listenWindowResize() {
        this._ngZone.runOutsideAngular(() => {
            fromEvent(window, 'resize')
                .pipe(debounceTime(50), takeUntil(this._destroy$))
                .subscribe(() => {
                this._updateScreenWidth();
                this._updateMinMaxStyles();
            });
        });
    }
    /**
     * Copy initial configs or set default values
     */
    _initDefaultConfigs() {
        this._mainConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.main)
                || {};
        this._mainConfig.initial = this._mainConfig.initial || MAIN_DRAWER_DEFAULT_WIDTH;
        this._sideConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.side)
                || {};
        this._sideConfig.initial = this._sideConfig.initial || SIDE_DRAWER_DEFAULT_WIDTH;
    }
    _registerMainRef(el) {
        this._mainElRef = el;
    }
    _registerSideRef(el) {
        this._sideElRef = el;
    }
    /**
     * Update current window size
     */
    _updateScreenWidth() {
        this._screenWidth = (window.innerWidth - this._borderPadding);
    }
    /**
     * Update min&max css props for containers
     */
    _updateMinMaxStyles() {
        this.mainElRef.setMinMaxStyles();
        if (this.sideElRef) {
            this.sideElRef.setMinMaxStyles();
        }
    }
    _listenSideToggle() {
        this._drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe((opened) => {
            if (this._sideOpened === opened) {
                return;
            }
            this._sideOpened = opened;
            if (opened) {
                const currentWidth = this.mainElRef.width;
                const sideWidth = this.getInitialWidth('side');
                this._mainElRef.updateWidth(currentWidth + sideWidth + SIDE_RESIZE_BAR_WIDTH);
            }
            else {
                const actualSideWidth = this.sideElRef.fsDrawerResizer.getBoundingClientRect().width;
                const mainWidth = this.mainElRef.width - actualSideWidth - SIDE_RESIZE_BAR_WIDTH;
                this._mainElRef.updateWidth(mainWidth);
            }
        });
    }
};
DrawerSizeController.ctorParameters = () => [
    { type: DrawerRef },
    { type: NgZone }
];
DrawerSizeController = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [DrawerRef,
        NgZone])
], DrawerSizeController);

let FsDrawerComponent = class FsDrawerComponent extends BasePortalOutlet {
    constructor(_el, _drawerMenu, _drawerRef, _cdRef, _resizeController) {
        super();
        this._el = _el;
        this._drawerMenu = _drawerMenu;
        this._drawerRef = _drawerRef;
        this._cdRef = _cdRef;
        this._resizeController = _resizeController;
        this.isOpen = false;
        this.isOpenSide = false;
        this.initialized = false;
        this._sideOpen = false;
        this._destroy$ = new Subject();
        this._drawerRef.resizeController = this._resizeController;
    }
    get sideOpen() {
        return this._sideOpen;
    }
    set sideOpen(value) {
        this._sideOpen = value;
        this._el.nativeElement.classList
            .toggle('side-open', this.sideOpen);
    }
    ngOnInit() {
        this._listenDataChanges();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    open() {
        this.isOpen = true;
    }
    close() {
        this.isOpen = false;
    }
    openSide() {
        this.isOpenSide = true;
    }
    closeSide() {
        this.isOpenSide = false;
    }
    setDrawerRef(value) {
        this.drawerRef = value;
        this.config = this.drawerRef.drawerConfig;
        // Need to be like a parent for children resize
        this.drawerRef.drawerContentContainer = this._drawerContentContainer;
        this.drawerRef.drawerActionsContainer = this._drawerActionsContainer;
        this.drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe((opened) => {
            this.sideOpen = opened;
        });
        this.initialized = true;
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    _listenDataChanges() {
        this._drawerRef.dataChanged$
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this._cdRef.detectChanges();
        });
    }
};
FsDrawerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: FsDrawerMenuService },
    { type: DrawerRef },
    { type: ChangeDetectorRef },
    { type: DrawerSizeController }
];
__decorate([
    ViewChild(CdkPortalOutlet, { static: true }),
    __metadata("design:type", CdkPortalOutlet)
], FsDrawerComponent.prototype, "_portalOutlet", void 0);
__decorate([
    ViewChild('drawerContentContainer', { static: true }),
    __metadata("design:type", ElementRef)
], FsDrawerComponent.prototype, "_drawerContentContainer", void 0);
__decorate([
    ViewChild('drawerActionsContainer', { read: ElementRef, static: true }),
    __metadata("design:type", ElementRef)
], FsDrawerComponent.prototype, "_drawerActionsContainer", void 0);
FsDrawerComponent = __decorate([
    Component({
        selector: 'fs-drawer',
        template: "<div class=\"mat-elevation-z2 drawer\" #drawer\n     hidden\n     [ngClass]=\"config.position\"\n     [hidden]=\"!initialized\">\n  <ng-container>\n    <fs-drawer-actions class=\"drawer-actions\"\n                       #drawerActionsContainer\n                       type=\"main\"\n                       [fsDrawerResizer]=\"drawer\"\n                       [resizable]=\"drawerRef.drawerConfig.resizable\"\n                       [sizeController]=\"drawerRef.resizeController\"\n                       [direction]=\"config.position\"\n                       [actions]=\"config.actions\"\n                       [activeAction]=\"drawerRef.activeAction$ | async\">\n    </fs-drawer-actions>\n    <div class=\"drawer-container\" #drawerContentContainer>\n      <ng-template cdkPortalOutlet></ng-template>\n    </div>\n  </ng-container>\n</div>\n",
        providers: [
            FsDrawerMenuService,
            DrawerSizeController,
        ],
        host: {
            'class': 'fs-drawer-container',
        },
        encapsulation: ViewEncapsulation.None,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [ElementRef,
        FsDrawerMenuService,
        DrawerRef,
        ChangeDetectorRef,
        DrawerSizeController])
], FsDrawerComponent);

let FsDrawerActionDirective = class FsDrawerActionDirective {
};
__decorate([
    Input('fsDrawerAction'),
    __metadata("design:type", String)
], FsDrawerActionDirective.prototype, "name", void 0);
FsDrawerActionDirective = __decorate([
    Directive({
        selector: '[fsDrawerAction]',
    })
], FsDrawerActionDirective);

let FsDrawerSideComponent = class FsDrawerSideComponent {
    constructor(_cdRef, _renderer, _elRef) {
        this._cdRef = _cdRef;
        this._renderer = _renderer;
        this._elRef = _elRef;
        this.classSide = true;
        this.activeTemplate = null;
        this._hidden = false;
        this._destroy$ = new EventEmitter();
    }
    set hidden(value) {
        this._hidden = value;
        if (this._hidden) {
            this._renderer.setAttribute(this._elRef.nativeElement, 'hidden', 'true');
        }
        else {
            this._renderer.removeAttribute(this._elRef.nativeElement, 'hidden');
        }
    }
    ngOnInit() {
        this.hidden = true;
        if (!this.drawer) {
            console.error('Drawer reference is null for @Input("fsDrawerSide")');
        }
        this._subscribeToActionChanges();
    }
    ngAfterViewInit() {
        setTimeout(() => {
            // Check current side status
            if (this.drawer) {
                this.hidden = !this.drawer.isSideOpen;
            }
            this._updateActiveActionTemplate();
        });
    }
    ngOnDestroy() {
        this._destroy$.emit();
        this._destroy$.complete();
    }
    _subscribeToActionChanges() {
        if (this.drawer) {
            this.drawer.sideToggle$
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this.hidden = !this.drawer.isSideOpen;
                this._updateActiveActionTemplate();
                this._cdRef.detectChanges();
            });
        }
    }
    _updateActiveActionTemplate() {
        if (this.drawer) {
            const activatedAction = this.drawer.activeAction;
            if (this.drawer.isSideOpen && activatedAction) {
                const selectedActionIndex = this.actions
                    .toArray()
                    .findIndex((action) => action.name === activatedAction);
                this.activeTemplate = this.actionsTemplates.toArray()[selectedActionIndex];
            }
            else {
                this.activeTemplate = null;
            }
        }
    }
};
FsDrawerSideComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: ElementRef }
];
__decorate([
    Input('fsDrawerSide'),
    __metadata("design:type", DrawerRef)
], FsDrawerSideComponent.prototype, "drawer", void 0);
__decorate([
    HostBinding('class.side'),
    __metadata("design:type", Object)
], FsDrawerSideComponent.prototype, "classSide", void 0);
__decorate([
    ContentChildren(FsDrawerActionDirective),
    __metadata("design:type", QueryList)
], FsDrawerSideComponent.prototype, "actions", void 0);
__decorate([
    ContentChildren(FsDrawerActionDirective, { read: TemplateRef }),
    __metadata("design:type", QueryList)
], FsDrawerSideComponent.prototype, "actionsTemplates", void 0);
FsDrawerSideComponent = __decorate([
    Component({
        selector: '[fsDrawerSide]',
        template: "<ng-container [ngSwitch]=\"drawer.drawerConfig.position\" *ngIf=\"activeTemplate\">\n  <ng-container *ngSwitchCase=\"'right'\">\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"left\"\n         type=\"side\"\n         [fsDrawerResizer]=\"sideContainer\"\n         [resizable]=\"drawer.drawerConfig.resizable\"\n         [sizeController]=\"drawer.resizeController\"\n         [parentContainer]=\"drawer.drawerContentContainer\"\n         [actionsContainer]=\"drawer.drawerActionsContainer\"\n    >\n      <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'left'\">\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"right\"\n         [fsDrawerResizer]=\"sideContainer\"\n    >\n    <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        styles: [".resize-icon{width:24px;height:24px;line-height:24px}.resize-icon span{width:24px}"]
    }),
    __metadata("design:paramtypes", [ChangeDetectorRef,
        Renderer2,
        ElementRef])
], FsDrawerSideComponent);

let FsDrawerActionItemComponent = class FsDrawerActionItemComponent {
    constructor(drawer, _cdRef) {
        this.drawer = drawer;
        this._cdRef = _cdRef;
        this.actionClicked = new EventEmitter();
        this.isActive = false;
        this.actionTypes = FsDrawerAction;
        this._destroy$ = new Subject();
        this._listenActionChanges();
        this._listenDataChanges();
    }
    ngOnInit() {
        this._updateVisibilityAndLinks();
    }
    ngOnChanges(changes) {
        if (changes.activeAction) {
            this.isActive = this.action.name !== '' && this.action.name === this.activeAction;
        }
    }
    actionClick(event) {
        this.actionClicked.emit(event);
    }
    menuActionClick(action, event) {
        if (action.click) {
            action.click.call(null, {
                data: this.drawer.drawerData,
                event: event,
                drawerRef: this.drawer,
                action: action
            });
        }
    }
    _listenActionChanges() {
        this.drawer.actionUpdated$
            .pipe(filter((name) => name === this.action.name), takeUntil(this._destroy$))
            .subscribe(() => {
            this._cdRef.detectChanges();
        });
    }
    _listenDataChanges() {
        this.drawer.dataChanged$
            .pipe(takeUntil(this._destroy$), debounceTime(50))
            .subscribe(() => {
            this._updateVisibilityAndLinks();
        });
    }
    _updateVisibilityAndLinks() {
        this._updateVisibility();
        this._updateRouterLinks();
        this._cdRef.detectChanges();
    }
    _updateVisibility() {
        this.action.checkVisibility(this.drawer.drawerData);
    }
    _updateRouterLinks() {
        if (this.action.type === this.actionTypes.Menu) {
            this.action.updateRouterLink({
                data: this.drawer.drawerData,
                drawerRef: this.drawer
            });
        }
    }
};
FsDrawerActionItemComponent.ctorParameters = () => [
    { type: DrawerRef },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    __metadata("design:type", Action)
], FsDrawerActionItemComponent.prototype, "action", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FsDrawerActionItemComponent.prototype, "activeAction", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], FsDrawerActionItemComponent.prototype, "actionClicked", void 0);
FsDrawerActionItemComponent = __decorate([
    Component({
        selector: 'fs-drawer-action-item',
        template: "<ng-container [ngSwitch]=\"action.type\">\n  <ng-container *ngSwitchCase=\"actionTypes.Button\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Menu\">\n    <ng-container *ngIf=\"action.visible\">\n      <button mat-icon-button\n              type=\"button\"\n              class=\"sub-action\"\n              [fsMenuTriggerFor]=\"menu\"\n              [matTooltip]=\"action.tooltip\"\n              [class.active]=\"isActive\"\n              (click)=\"actionClick($event)\">\n        <i class=\"material-icons\">{{action.icon}}</i>\n      </button>\n\n      <fs-menu #menu>\n        <ng-container *ngFor=\"let menuAction of action.menuActions\">\n          <ng-container *ngIf=\"menuAction.isGroup else simpleMenuItem\">\n            <fs-menu-group [label]=\"menuAction.label\" [hidden]=\"!menuAction.visible\">\n              <ng-container *ngFor=\"let groupAction of menuAction.actions\">\n                <ng-template fs-menu-item\n                             [hidden]=\"!groupAction.visible\"\n                             [link]=\"groupAction.routerLink?.link\"\n                             [queryParams]=\"groupAction.routerLink?.queryParams\"\n                             (click)=\"menuActionClick(groupAction, $event);\">\n                  <mat-icon *ngIf=\"menuAction.icon\">{{groupAction.icon}}</mat-icon>\n                  {{groupAction.label}}\n                </ng-template>\n              </ng-container>\n            </fs-menu-group>\n          </ng-container>\n          <ng-template #simpleMenuItem>\n            <ng-template fs-menu-item\n                         [hidden]=\"!menuAction.visible\"\n                         [link]=\"menuAction.routerLink?.link\"\n                         [queryParams]=\"menuAction.routerLink?.queryParams\"\n                         (click)=\"menuActionClick(menuAction, $event);\">\n              <i class=\"material-icons\" *ngIf=\"menuAction.icon\">{{menuAction.icon}}</i>\n              <span>{{menuAction.label}}</span>\n            </ng-template>\n          </ng-template>\n        </ng-container>\n      </fs-menu>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Component\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n</ng-container>\n",
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [DrawerRef,
        ChangeDetectorRef])
], FsDrawerActionItemComponent);

let FsDrawerContentComponent = class FsDrawerContentComponent {
};
FsDrawerContentComponent = __decorate([
    Component({
        selector: '[fsDrawerContent]',
        template: '<div class="content"><ng-content></ng-content></div>',
        host: {
            'class': 'content-container'
        }
    })
], FsDrawerContentComponent);

let FsDrawerResizerDirective = class FsDrawerResizerDirective {
    constructor(_el, _renderer, _ngZone) {
        this._el = _el;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.fsDrawerResizer = this._el.nativeElement;
        this.direction = 'left';
        this.resizable = true;
        this._dragStartHandler = this._dragStart.bind(this);
        this._dragHandler = this._drag.bind(this);
        this._dragEndHandler = this._dragEnd.bind(this);
        this._x = 0;
        this._width = 0;
        this._actionsWidth = 0;
        this._destroy$ = new Subject();
    }
    get width() {
        return this._width;
    }
    get minWidth() {
        const minWidth = this.sizeController.getMinWidth(this.type);
        if (minWidth && minWidth >= 0) {
            if (minWidth > this.sizeController.screenWidth) {
                return this.sizeController.screenWidth;
            }
            else {
                return minWidth;
            }
        }
    }
    get maxWidth() {
        const maxWidth = this.sizeController.getMaxWidth(this.type);
        let parentContainerWidth = null;
        if (this.parentContainer) {
            parentContainerWidth = this._getElementWidth(this.parentContainer.nativeElement);
        }
        if (parentContainerWidth !== null) {
            return !maxWidth || maxWidth >= parentContainerWidth
                ? parentContainerWidth - this._actionsWidth * 2
                : maxWidth;
        }
        else {
            return !maxWidth || maxWidth >= this.sizeController.screenWidth
                ? this.sizeController.screenWidth
                : maxWidth;
        }
    }
    ngOnInit() {
        this.sizeController.registerElRef(this);
        if (this.resizable) {
            this._ngZone.runOutsideAngular(() => {
                this._el.nativeElement.addEventListener('mousedown', this._dragStartHandler, false);
                this._el.nativeElement.addEventListener('touchstart', this._dragStartHandler, false);
            });
            if (this.actionsContainer) {
                this._actionsWidth = this._getElementWidth(this.actionsContainer.nativeElement);
            }
            this.setMinMaxStyles();
            const minWidth = this.sizeController.getMinWidth(this.type);
            let width = this.sizeController.getInitialWidth(this.type)
                || this._getElementWidth(this.fsDrawerResizer);
            if (width < minWidth) {
                width = minWidth;
            }
            this.updateWidth(width);
        }
    }
    updateWidth(width) {
        this._width = width;
        requestAnimationFrame(() => {
            this._renderer.setStyle(this.fsDrawerResizer, 'width', `${width}px`);
        });
    }
    ngOnDestroy() {
        this._el.nativeElement.removeEventListener('mousedown', this._dragStartHandler, false);
        this._el.nativeElement.removeEventListener('touchstart', this._dragStartHandler, false);
        this._destroy$.next();
        this._destroy$.complete();
    }
    /**
     * Set inline styles min/max width
     */
    setMinMaxStyles() {
        requestAnimationFrame(() => {
            this._renderer.setStyle(this.fsDrawerResizer, 'min-width', `${this.minWidth}px`);
            this._renderer.setStyle(this.fsDrawerResizer, 'max-width', `${this.maxWidth}px`);
        });
    }
    /**
     * Subscribe to move events and init base dimensions/restrictions
     * @param event { MouseEvent }
     */
    _dragStart(event) {
        this._x = this._getClientX(event);
        this._width = this._getElementWidth(this.fsDrawerResizer);
        this.setMinMaxStyles();
        document.addEventListener('touchmove', this._dragHandler, false);
        document.addEventListener('touchend', this._dragEndHandler, false);
        document.addEventListener('mousemove', this._dragHandler, false);
        document.addEventListener('mouseup', this._dragEndHandler, false);
    }
    /**
     * Update coordinates during drag
     * @param event
     */
    _drag(event) {
        const clientX = this._getClientX(event);
        const predictedWidth = this._calcWidth(this.direction, clientX);
        this._updatePosition(clientX, predictedWidth);
        this._emitResizeEvent();
    }
    /**
     * Remove listeners when drag finished
     * @param event
     */
    _dragEnd(event) {
        document.removeEventListener('mousemove', this._dragHandler, false);
        document.removeEventListener('mouseup', this._dragEndHandler, false);
        document.removeEventListener('touchmove', this._dragHandler, false);
        document.removeEventListener('touchend', this._dragEndHandler, false);
    }
    /**
     *
     * @param event
     */
    _getClientX(event) {
        return event.touches ? event.touches[0].clientX : event.clientX;
    }
    /**
     * Will return width of element
     * @param el
     */
    _getElementWidth(el) {
        return el.getBoundingClientRect().width;
    }
    /**
     * Update width and position of target element
     * @param clientX
     * @param width
     */
    _updatePosition(clientX, width) {
        this._x = clientX;
        this.updateWidth(width < 0 ? 0 : width);
    }
    /**
     * Calc new width based on offset from previous position
     * @param direction
     * @param clientX
     */
    _calcWidth(direction, clientX) {
        const directionSign = direction === 'left' ? -1 : 1;
        return this._width + (this._x - clientX) * directionSign;
    }
    /**
     * Resize event for Window
     */
    _emitResizeEvent() {
        const resizeEvent = window.document.createEvent('UIEvents');
        resizeEvent.initEvent('resize', true, false);
        window.dispatchEvent(resizeEvent);
    }
};
FsDrawerResizerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], FsDrawerResizerDirective.prototype, "fsDrawerResizer", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], FsDrawerResizerDirective.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FsDrawerResizerDirective.prototype, "direction", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], FsDrawerResizerDirective.prototype, "resizable", void 0);
__decorate([
    Input(),
    __metadata("design:type", ElementRef)
], FsDrawerResizerDirective.prototype, "parentContainer", void 0);
__decorate([
    Input(),
    __metadata("design:type", ElementRef)
], FsDrawerResizerDirective.prototype, "actionsContainer", void 0);
__decorate([
    Input(),
    __metadata("design:type", DrawerSizeController)
], FsDrawerResizerDirective.prototype, "sizeController", void 0);
FsDrawerResizerDirective = __decorate([
    Directive({
        selector: '[fsDrawerResizer]',
        host: {
            '[style.cursor]': '"col-resize"',
        }
    }),
    __metadata("design:paramtypes", [ElementRef,
        Renderer2,
        NgZone])
], FsDrawerResizerDirective);

/** Injection token that can be used to access the data that was passed in to a drawer. */
const DRAWER_DATA = new InjectionToken('DrawerData');

let FsDrawerService = class FsDrawerService {
    constructor(_parentDrawerService, _overlay, _injector) {
        this._parentDrawerService = _parentDrawerService;
        this._overlay = _overlay;
        this._injector = _injector;
        this._drawerRefs = new Set();
        this._destroy$ = new Subject();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    open(component, config) {
        const overlayRef = this._createOverlay();
        const dataFactory = DrawerData.createWithProxy(config.data);
        const drawerRef = new DrawerRef(overlayRef, dataFactory, config);
        const containerRef = this._attachDrawerContainer(overlayRef, drawerRef, dataFactory);
        const componentRef = this._attachComponent(component, containerRef, drawerRef, dataFactory);
        drawerRef.containerRef = containerRef;
        containerRef.setDrawerRef(drawerRef);
        drawerRef.componentRef = componentRef;
        drawerRef.events();
        drawerRef.open();
        this._storeDrawerRef(drawerRef);
        merge(drawerRef.afterOpened$, drawerRef.afterClosed$)
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            setTimeout(() => {
                this._applyBackdrop();
                this._applyBodyOpenClass();
            });
        });
        return drawerRef;
    }
    closeAll() {
        this._drawerRefs.forEach((ref) => ref.close());
        if (this._parentDrawerService) {
            this._parentDrawerService.closeAll();
        }
    }
    _applyBackdrop() {
        Array.from(this._drawerRefs)
            .forEach((drawerRef, index) => {
            const backdrop = drawerRef.overlayRef.backdropElement;
            if (backdrop) {
                if (index && index === (this._drawerRefs.size - 1)) {
                    backdrop.classList.add('fs-drawer-backdrop-active');
                }
                else {
                    backdrop.classList.remove('fs-drawer-backdrop-active');
                }
            }
        });
    }
    _applyBodyOpenClass() {
        if (this._drawerRefs.size) {
            document.body.classList.add('fs-drawer-open');
        }
        else {
            document.body.classList.remove('fs-drawer-open');
        }
    }
    _storeDrawerRef(ref) {
        this._drawerRefs.add(ref);
        this._pushDrawersCascade();
        ref.destroy$
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._drawerRefs.delete(ref);
        });
    }
    /**
     * In case, when we want to open more than 1 drawer
     * our previously opened drawers should be visible
     *
     *      d1   d2   d3
     *     ---- ---- ---
     *    | x  | x1 | x2
     *    | y  | y1 | y2
     *    | z  | z1 | z2
     *     ---- ---- ---
     *
     * Where d1, d2 - previously opened drawers
     * d1 and d2 must be pushed left to be visible under just opened d3
     */
    _pushDrawersCascade() {
        if (this._drawerRefs.size > 1) {
            // SetTimeout should be here because we must wait render newly opened drawer
            // to be able to get his width
            setTimeout(() => {
                const refsArr = Array.from(this._drawerRefs.values());
                for (let i = refsArr.length - 1; i > 0; i--) {
                    const prevRef = refsArr[i - 1];
                    const currRef = refsArr[i];
                    prevRef.resizeController.pushMainWidth(currRef);
                }
            });
        }
    }
    _createOverlay() {
        const overlayConfig = this._getOverlayConfig();
        return this._overlay.create(overlayConfig);
    }
    _getOverlayConfig() {
        return new OverlayConfig({
            hasBackdrop: true,
            backdropClass: 'fs-drawer-backdrop'
        });
    }
    _attachDrawerContainer(overlayRef, drawerRef, dataFactory) {
        const injector = this._createInjector(drawerRef, dataFactory);
        const containerPortal = new ComponentPortal(FsDrawerComponent, undefined, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    _attachComponent(componentRef, drawerContainer, drawerRef, dataFactory) {
        const injector = this._createInjector(drawerRef, dataFactory);
        return drawerContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    }
    _createInjector(componentRef, dataFactory) {
        const injectionTokens = new WeakMap([
            [DrawerRef, componentRef],
            [DRAWER_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    }
};
FsDrawerService.ctorParameters = () => [
    { type: FsDrawerService, decorators: [{ type: Optional }, { type: SkipSelf }] },
    { type: Overlay },
    { type: Injector }
];
FsDrawerService = __decorate([
    Injectable(),
    __param(0, Optional()), __param(0, SkipSelf()),
    __metadata("design:paramtypes", [FsDrawerService,
        Overlay,
        Injector])
], FsDrawerService);

let FsDrawerModule = class FsDrawerModule {
};
FsDrawerModule = __decorate([
    NgModule({
        imports: [
            CommonModule,
            MatTooltipModule,
            MatButtonModule,
            MatIconModule,
            OverlayModule,
            PortalModule,
            FsMenuModule,
            MatMenuModule,
        ],
        exports: [
            FsDrawerComponent,
            FsDrawerSideComponent,
            FsDrawerContentComponent,
            FsDrawerActionDirective,
            FsDrawerResizerDirective,
        ],
        declarations: [
            FsDrawerSideComponent,
            FsDrawerComponent,
            FsDrawerActionsComponent,
            FsDrawerActionItemComponent,
            FsDrawerContentComponent,
            FsDrawerActionDirective,
            FsDrawerResizerDirective,
            FsDrawerMenuComponent,
        ],
        providers: [FsDrawerService],
    })
], FsDrawerModule);

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DRAWER_DATA, DRAWER_MENU_DATA, DrawerData, DrawerMenuRef, DrawerRef, FsDrawerAction, FsDrawerActionDirective, FsDrawerComponent, FsDrawerContentComponent, FsDrawerModule, FsDrawerResizerDirective, FsDrawerService, FsDrawerSideComponent, FsDrawerMenuService as ɵa, DrawerSizeController as ɵb, FsDrawerActionsComponent as ɵc, FsDrawerActionItemComponent as ɵd, FsDrawerMenuComponent as ɵe };
//# sourceMappingURL=firestitch-drawer.js.map
