import { __assign, __read, __spread } from "tslib";
import { Observable, Subject, zip } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
var DrawerMenuRef = /** @class */ (function () {
    function DrawerMenuRef(_overlayRef, _dataFactory) {
        var _this = this;
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the menu has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the menu has started closing. */
        this._closeStart$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._overlayRef.backdropClick()
            .pipe(takeUntil(this._destroy$))
            .subscribe(function () {
            _this.close();
        });
    }
    Object.defineProperty(DrawerMenuRef.prototype, "menuData", {
        /**
         * Getter for DRAWER_MENU_DATA for current drawer
         */
        get: function () {
            return __assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "containerRef", {
        /**
         * Set reference to menu container
         * @param value
         */
        set: function (value) {
            this._externalMenuContainerRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "componentRef", {
        /**
         * Set reference to menu component
         * @param value
         */
        set: function (value) {
            this._externalMenuComponentRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "dataChanged$", {
        /**
         * Gets an observable that is notified when data in DRAWER_DATA was changed
         */
        get: function () {
            return this._dataFactory.dataChange$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    DrawerMenuRef.prototype.dataChange = function (data) {
        this._dataFactory.setValue(data);
    };
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    DrawerMenuRef.prototype.afterClosed = function () {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    };
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    DrawerMenuRef.prototype.closeStart = function () {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    };
    /**
     * Close the menu.
     * @param result Optional result to return to the dialog opener.
     */
    DrawerMenuRef.prototype.close = function (result) {
        var _this = this;
        new Observable(function (observer) {
            if (_this._closeStart$.observers.length) {
                zip.apply(void 0, __spread(_this._closeStart$.observers.map(function (item) {
                    return Observable.create(function (closeObserver) {
                        item.next(closeObserver);
                    });
                }))).pipe(takeUntil(_this._destroy$))
                    .subscribe(function () {
                    observer.next();
                    observer.complete();
                }, function () {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: function () {
                _this._result = result;
                _this._afterClosed$.next(result);
                _this.destroy();
            }
        });
    };
    DrawerMenuRef.prototype.destroy = function () {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    };
    return DrawerMenuRef;
}());
export { DrawerMenuRef };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLW1lbnUtcmVmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGZpcmVzdGl0Y2gvZHJhd2VyLyIsInNvdXJjZXMiOlsiYXBwL2NsYXNzZXMvZHJhd2VyLW1lbnUtcmVmLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFHQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBYyxHQUFHLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSzNDO0lBcUJFLHVCQUFvQixXQUF1QixFQUFVLFlBQXdCO1FBQTdFLGlCQVFDO1FBUm1CLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQVUsaUJBQVksR0FBWixZQUFZLENBQVk7UUFuQjdFLHlFQUF5RTtRQUN4RCxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFpQixDQUFDO1FBRTlELHdFQUF3RTtRQUN2RCxpQkFBWSxHQUFHLElBQUksT0FBTyxFQUFvQixDQUFDO1FBRWhFLHdCQUF3QjtRQUNQLGNBQVMsR0FBRyxJQUFJLE9BQU8sRUFBUSxDQUFDO1FBYS9DLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFO2FBQzdCLElBQUksQ0FDSCxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUMxQjthQUNBLFNBQVMsQ0FBQztZQUNULEtBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUFBO0lBQ04sQ0FBQztJQUtELHNCQUFJLG1DQUFRO1FBSFo7O1dBRUc7YUFDSDtZQUNFLG9CQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQywwQ0FBMEM7UUFDdkYsQ0FBQzs7O09BQUE7SUFNRCxzQkFBSSx1Q0FBWTtRQUpoQjs7O1dBR0c7YUFDSCxVQUFpQixLQUE0QjtZQUMzQyxJQUFJLENBQUMseUJBQXlCLEdBQUcsS0FBSyxDQUFDO1FBQ3pDLENBQUM7OztPQUFBO0lBTUQsc0JBQUksdUNBQVk7UUFKaEI7OztXQUdHO2FBQ0gsVUFBaUIsS0FBeUI7WUFDeEMsSUFBSSxDQUFDLHlCQUF5QixHQUFHLEtBQUssQ0FBQztRQUN6QyxDQUFDOzs7T0FBQTtJQUtELHNCQUFJLHVDQUFZO1FBSGhCOztXQUVHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDO1FBQ3ZDLENBQUM7OztPQUFBO0lBRUQ7OztPQUdHO0lBQ0ksa0NBQVUsR0FBakIsVUFBa0IsSUFBSTtRQUNwQixJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQ7O09BRUc7SUFDSSxtQ0FBVyxHQUFsQjtRQUNFLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQzVELENBQUM7SUFFRDs7T0FFRztJQUNJLGtDQUFVLEdBQWpCO1FBQ0UsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVEOzs7T0FHRztJQUNJLDZCQUFLLEdBQVosVUFBYSxNQUFVO1FBQXZCLGlCQThCQztRQTdCQyxJQUFJLFVBQVUsQ0FBTyxVQUFBLFFBQVE7WUFDM0IsSUFBSSxLQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUU7Z0JBQ3RDLEdBQUcsd0JBQUksS0FBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFVBQUEsSUFBSTtvQkFDekMsT0FBTyxVQUFVLENBQUMsTUFBTSxDQUFDLFVBQUEsYUFBYTt3QkFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDM0IsQ0FBQyxDQUFDLENBQUM7Z0JBQ0wsQ0FBQyxDQUFDLEdBQ0QsSUFBSSxDQUNILFNBQVMsQ0FBQyxLQUFJLENBQUMsU0FBUyxDQUFDLENBQzFCO3FCQUNBLFNBQVMsQ0FBQztvQkFDVCxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7b0JBQ2hCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDdEIsQ0FBQyxFQUFFO29CQUNELFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkIsQ0FBQyxDQUFDLENBQUM7YUFDSjtpQkFBTTtnQkFDTCxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQ2hCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQzthQUNyQjtRQUVILENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQy9CLFNBQVMsQ0FBQztZQUNYLElBQUksRUFBRTtnQkFDSixLQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQztnQkFDdEIsS0FBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2hDLEtBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNqQixDQUFDO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUdNLCtCQUFPLEdBQWQ7UUFDRSxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLHlCQUF5QixJQUFJLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUUzRSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRTVCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM1QixDQUFDO0lBR0gsb0JBQUM7QUFBRCxDQUFDLEFBcElELElBb0lDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPdmVybGF5UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBTdWJzY3JpYmVyLCB6aXAgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgRnNEcmF3ZXJNZW51Q29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9kcmF3ZXItbWVudS9kcmF3ZXItbWVudS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJhd2VyRGF0YSB9IGZyb20gJy4vZHJhd2VyLWRhdGEnO1xuXG5leHBvcnQgY2xhc3MgRHJhd2VyTWVudVJlZjxUQ21wLCBSID0gYW55PiB7XG5cbiAgLyoqIFN1YmplY3QgZm9yIG5vdGlmeWluZyB0aGUgdXNlciB0aGF0IHRoZSBtZW51IGhhcyBmaW5pc2hlZCBjbG9zaW5nLiAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9hZnRlckNsb3NlZCQgPSBuZXcgU3ViamVjdDxSIHwgdW5kZWZpbmVkPigpO1xuXG4gIC8qKiBTdWJqZWN0IGZvciBub3RpZnlpbmcgdGhlIHVzZXIgdGhhdCB0aGUgbWVudSBoYXMgc3RhcnRlZCBjbG9zaW5nLiAqL1xuICBwcml2YXRlIHJlYWRvbmx5IF9jbG9zZVN0YXJ0JCA9IG5ldyBTdWJqZWN0PFN1YnNjcmliZXI8dm9pZD4+KCk7XG5cbiAgLyoqIERlc3Ryb3kgbm90aWZpZXIgKiovXG4gIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3kkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAvKiogUmVzdWx0IHRvIGJlIHBhc3NlZCB0byBhZnRlckNsb3NlZC4gKi9cbiAgcHJpdmF0ZSBfcmVzdWx0OiBSIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBNYWluIG1lbnUgY29tcG9uZW50IGFuZCB0ZW1wbGF0ZSAqL1xuICBwcml2YXRlIF9leHRlcm5hbE1lbnVDb250YWluZXJSZWY6IEZzRHJhd2VyTWVudUNvbXBvbmVudDtcblxuICAvKiogTWFpbiBtZW51IGNvbXBvbmVudCBhbmQgdGVtcGxhdGUgKi9cbiAgcHJpdmF0ZSBfZXh0ZXJuYWxNZW51Q29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8VENtcD47XG5cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmLCBwcml2YXRlIF9kYXRhRmFjdG9yeTogRHJhd2VyRGF0YSkge1xuICAgIHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpXG4gICAgICAucGlwZShcbiAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSxcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHRlciBmb3IgRFJBV0VSX01FTlVfREFUQSBmb3IgY3VycmVudCBkcmF3ZXJcbiAgICovXG4gIGdldCBtZW51RGF0YSgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLl9kYXRhRmFjdG9yeS5nZXRWYWx1ZSgpIH0gLy8gTGlrZSBpbW11dGFibGUuLi4uIFRPRE8gc3dpdGNoIHRvIEltbWVyXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlZmVyZW5jZSB0byBtZW51IGNvbnRhaW5lclxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICovXG4gIHNldCBjb250YWluZXJSZWYodmFsdWU6IEZzRHJhd2VyTWVudUNvbXBvbmVudCkge1xuICAgIHRoaXMuX2V4dGVybmFsTWVudUNvbnRhaW5lclJlZiA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCByZWZlcmVuY2UgdG8gbWVudSBjb21wb25lbnRcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqL1xuICBzZXQgY29tcG9uZW50UmVmKHZhbHVlOiBDb21wb25lbnRSZWY8VENtcD4pIHtcbiAgICB0aGlzLl9leHRlcm5hbE1lbnVDb21wb25lbnRSZWYgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIGRhdGEgaW4gRFJBV0VSX0RBVEEgd2FzIGNoYW5nZWRcbiAgICovXG4gIGdldCBkYXRhQ2hhbmdlZCQoKTogT2JzZXJ2YWJsZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFGYWN0b3J5LmRhdGFDaGFuZ2UkO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB2YWx1ZSBmb3IgRFJBV0VSX0RBVEFcbiAgICogQHBhcmFtIGRhdGFcbiAgICovXG4gIHB1YmxpYyBkYXRhQ2hhbmdlKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhRmFjdG9yeS5zZXRWYWx1ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuIG9ic2VydmFibGUgdGhhdCBpcyBub3RpZmllZCB3aGVuIHRoZSBkaWFsb2cgaXMgZmluaXNoZWQgY2xvc2luZy5cbiAgICovXG4gIHB1YmxpYyBhZnRlckNsb3NlZCgpOiBPYnNlcnZhYmxlPFIgfCB1bmRlZmluZWQ+IHtcbiAgICByZXR1cm4gdGhpcy5fYWZ0ZXJDbG9zZWQkLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbiBvYnNlcnZhYmxlIHRoYXQgaXMgbm90aWZpZWQgd2hlbiB0aGUgZGlhbG9nIGlzIGZpbmlzaGVkIG9wZW5pbmcuXG4gICAqL1xuICBwdWJsaWMgY2xvc2VTdGFydCgpOiBPYnNlcnZhYmxlPFN1YnNjcmliZXI8dm9pZD4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xvc2VTdGFydCQucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgbWVudS5cbiAgICogQHBhcmFtIHJlc3VsdCBPcHRpb25hbCByZXN1bHQgdG8gcmV0dXJuIHRvIHRoZSBkaWFsb2cgb3BlbmVyLlxuICAgKi9cbiAgcHVibGljIGNsb3NlKHJlc3VsdD86IFIpOiB2b2lkIHtcbiAgICBuZXcgT2JzZXJ2YWJsZTx2b2lkPihvYnNlcnZlciA9PiB7XG4gICAgICBpZiAodGhpcy5fY2xvc2VTdGFydCQub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICB6aXAoLi4udGhpcy5fY2xvc2VTdGFydCQub2JzZXJ2ZXJzLm1hcChpdGVtID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoY2xvc2VPYnNlcnZlciA9PiB7XG4gICAgICAgICAgICBpdGVtLm5leHQoY2xvc2VPYnNlcnZlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKVxuICAgICAgICAucGlwZShcbiAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSQpXG4gICAgICAgIClcbiAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCgpO1xuICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ic2VydmVyLm5leHQoKTtcbiAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgIH0pLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSlcbiAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX2FmdGVyQ2xvc2VkJC5uZXh0KHJlc3VsdCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cblxuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaEJhY2tkcm9wKCk7XG4gICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB0aGlzLl9leHRlcm5hbE1lbnVDb21wb25lbnRSZWYgJiYgdGhpcy5fZXh0ZXJuYWxNZW51Q29tcG9uZW50UmVmLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuX2RhdGFGYWN0b3J5LmRlc3Ryb3koKTtcblxuICAgIHRoaXMuX2Rlc3Ryb3kkLm5leHQoKTtcbiAgICB0aGlzLl9kZXN0cm95JC5jb21wbGV0ZSgpO1xuICB9XG5cblxufVxuIl19