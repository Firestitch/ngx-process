import { __extends, __assign, __spread, __decorate, __metadata, __param } from 'tslib';
import { ViewChild, Component, ChangeDetectionStrategy, InjectionToken, ElementRef, Injector, Injectable, ChangeDetectorRef, Input, NgZone, ViewEncapsulation, Directive, EventEmitter, Renderer2, HostBinding, ContentChildren, QueryList, TemplateRef, Output, Optional, SkipSelf, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { CdkPortalOutlet, BasePortalOutlet, ComponentPortal, PortalInjector, PortalModule } from '@angular/cdk/portal';
import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import { MatTooltipModule } from '@angular/material/tooltip';
import { FsMenuModule } from '@firestitch/menu';
import { Subject, BehaviorSubject, Observable, zip, fromEvent, merge } from 'rxjs';
import { ESCAPE } from '@angular/cdk/keycodes';
import { takeUntil, filter, take, debounceTime } from 'rxjs/operators';
import { Breakpoints, BreakpointObserver } from '@angular/cdk/layout';

var FsDrawerAction;
(function (FsDrawerAction) {
    FsDrawerAction["Button"] = "button";
    FsDrawerAction["Menu"] = "menu";
    FsDrawerAction["Component"] = "component";
})(FsDrawerAction || (FsDrawerAction = {}));

var BaseAction = /** @class */ (function () {
    function BaseAction(data) {
        if (data === void 0) { data = {}; }
        this._visible = true;
        this._icon = data.icon || '';
        this._click = data.click || null;
        this._link = data.link;
        this._show = data.show || null;
    }
    Object.defineProperty(BaseAction.prototype, "icon", {
        get: function () {
            return this._icon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseAction.prototype, "click", {
        get: function () {
            return this._click;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseAction.prototype, "routerLink", {
        get: function () {
            return this._routerLink;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseAction.prototype, "visible", {
        get: function () {
            return this._visible;
        },
        enumerable: true,
        configurable: true
    });
    BaseAction.prototype.checkVisibility = function (data) {
        if (this._show) {
            this._visible = this._show(data);
        }
    };
    BaseAction.prototype.updateRouterLink = function (data) {
        if (this._visible && this._link) {
            this._routerLink = this._link(data);
        }
    };
    return BaseAction;
}());

var MenuAction = /** @class */ (function (_super) {
    __extends(MenuAction, _super);
    function MenuAction(data) {
        if (data === void 0) { data = {}; }
        var _this = _super.call(this, data) || this;
        _this.actions = [];
        _this._isGroup = false;
        if (Array.isArray(data.actions)) {
            _this._isGroup = true;
            _this.actions = data.actions.map(function (action) { return new MenuAction(action); });
        }
        _this._label = data.label || '';
        return _this;
    }
    Object.defineProperty(MenuAction.prototype, "isGroup", {
        get: function () {
            return this._isGroup;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MenuAction.prototype, "label", {
        get: function () {
            return this._label;
        },
        enumerable: true,
        configurable: true
    });
    MenuAction.prototype.updateRouterLink = function (data) {
        _super.prototype.updateRouterLink.call(this, data);
        if (this.actions.length > 0) {
            this.actions.forEach(function (action) {
                action.updateRouterLink(data);
            });
        }
    };
    MenuAction.prototype.checkVisibility = function (data) {
        _super.prototype.checkVisibility.call(this, data);
        if (this.actions.length > 0) {
            this.actions.forEach(function (action) {
                action.checkVisibility(data);
            });
        }
        if (this.actions.length > 0) {
            this._visible = this.actions.some(function (action) { return action.visible; });
        }
    };
    return MenuAction;
}(BaseAction));

var Action = /** @class */ (function (_super) {
    __extends(Action, _super);
    function Action(data) {
        if (data === void 0) { data = {}; }
        var _this = _super.call(this, data) || this;
        _this._data = null;
        _this._close = false;
        _this._closeSide = true;
        _this._menuActions = [];
        _this._component = null;
        _this._menuRefName = null;
        _this._icon = data.icon || '';
        _this._type = data.type || '';
        _this._name = data.name || '';
        _this._toggle = data.toggle === void 0 ? true : data.toggle;
        _this._tooltip = data.tooltip || '';
        _this._close = !!data.close;
        _this._component = data.component || null;
        _this._data = data.data === void 0 ? {} : data.data;
        if (_this._type === FsDrawerAction.Component) {
            _this._menuRefName = data.name || data.icon;
        }
        if (_this._type === FsDrawerAction.Menu && data.closeSide === void 0) {
            _this._closeSide = false;
        }
        else {
            _this._closeSide = data.closeSide === void 0 ? true : !!data.closeSide;
        }
        if (Array.isArray(data.actions)) {
            _this._menuActions = data.actions.map(function (action) { return new MenuAction(action); });
        }
        return _this;
    }
    Object.defineProperty(Action.prototype, "icon", {
        get: function () {
            return this._icon;
        },
        set: function (value) {
            this._icon = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "type", {
        get: function () {
            return this._type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "toggle", {
        get: function () {
            return this._toggle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "tooltip", {
        get: function () {
            return this._tooltip;
        },
        set: function (value) {
            this._tooltip = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "close", {
        get: function () {
            return this._close;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "closeSide", {
        get: function () {
            return this._closeSide;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "menuActions", {
        get: function () {
            return this._menuActions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "component", {
        get: function () {
            return this._component;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "data", {
        get: function () {
            return this._data;
        },
        set: function (value) {
            this._data = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Action.prototype, "menuRefName", {
        get: function () {
            return this._menuRefName;
        },
        enumerable: true,
        configurable: true
    });
    Action.prototype.updateRouterLink = function (data) {
        if (this._visible) {
            _super.prototype.updateRouterLink.call(this, data);
            if (this._menuActions.length > 0) {
                this._menuActions.forEach(function (action) {
                    action.updateRouterLink(data);
                });
            }
        }
    };
    Action.prototype.checkVisibility = function (data) {
        _super.prototype.checkVisibility.call(this, data);
        if (this._menuActions.length > 0) {
            this._menuActions.forEach(function (action) {
                action.checkVisibility(data);
            });
        }
        if (this.menuActions.length > 0) {
            this._visible = this.menuActions.some(function (action) { return action.visible; });
        }
    };
    return Action;
}(BaseAction));

var DrawerConfig = /** @class */ (function () {
    function DrawerConfig(data) {
        if (data === void 0) { data = {}; }
        this.disableClose = data.disableClose || false;
        this.position = data.position || 'right';
        this.activeAction = data.activeAction || '';
        this.resizable = data.resizable === void 0 ? true : data.resizable;
        if (data.width) {
            this.width = data.width;
        }
        this.actions = data.actions && data.actions.map(function (action) { return new Action(action); }) || null;
    }
    return DrawerConfig;
}());

var DrawerRef = /** @class */ (function () {
    function DrawerRef(_overlayRef, _dataFactory, _config) {
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the drawer has finished opening. */
        this._afterOpened$ = new Subject();
        /** Subject for notifying the user that the drawer has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._closeStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started opening. */
        this._openStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._sideToggle = new Subject();
        /** Subject for notifying the user that the drawer has finished opening. */
        this._actionsUpdated$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._activeAction = new BehaviorSubject(void 0);
        this._menuRefs = new Map();
        this._isOpen = false;
        this._isSideOpen = false;
        this.drawerConfig = new DrawerConfig(_config);
        this._activeAction.next(this.drawerConfig.activeAction);
    }
    Object.defineProperty(DrawerRef.prototype, "overlayRef", {
        get: function () {
            return this._overlayRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "drawerData", {
        /**
         * Getter for DRAWER_DATA for current drawer
         */
        get: function () {
            return __assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "destroy$", {
        get: function () {
            return this._destroy$.asObservable();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "containerRef", {
        /**
         * Set reference to drawer container
         * @param value
         */
        set: function (value) {
            this._drawerContainerRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "componentRef", {
        /**
         * Set reference to drawer component
         * @param value
         */
        set: function (value) {
            this._drawerComponentRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "drawerContentContainer", {
        get: function () {
            return this._drawerContentContainer;
        },
        set: function (value) {
            this._drawerContentContainer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "drawerActionsContainer", {
        get: function () {
            return this._drawerActionsContainer;
        },
        set: function (value) {
            this._drawerActionsContainer = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "activeAction", {
        get: function () {
            return this._activeAction.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "activeAction$", {
        get: function () {
            return this._activeAction.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "isOpen", {
        /**
         * Return actual status of the drawer
         */
        get: function () {
            return this._isOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "isSideOpen", {
        /**
         * Return actual status of the side of the drawer
         */
        get: function () {
            return this._isSideOpen;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "resizeController", {
        get: function () {
            return this._resizeController;
        },
        set: function (value) {
            this._resizeController = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "actionUpdated$", {
        /**
         * Gets an observable that action was updated and change detection should be started
         */
        get: function () {
            return this._actionsUpdated$.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "afterClosed$", {
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        get: function () {
            return this._afterClosed$.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "afterOpened$", {
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        get: function () {
            return this._afterOpened$.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "openStart$", {
        /**
         * Gets an observable that is notified when the dialog open starts.
         */
        get: function () {
            return this._openStart$.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "closeStart$", {
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        get: function () {
            return this._closeStart$.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "dataChanged$", {
        /**
         * Gets an observable that is notified when data in DRAWER_DATA was changed
         */
        get: function () {
            return this._dataFactory.dataChange$;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerRef.prototype, "sideToggle$", {
        /**
         * Gets an observable that is notify that side status toggled
         */
        get: function () {
            return this._sideToggle.pipe(takeUntil(this._destroy$));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe on keydown events to react on escape
     */
    DrawerRef.prototype.events = function () {
        var _this = this;
        this._overlayRef.keydownEvents()
            .pipe(filter(function (event) { return event.keyCode === ESCAPE && !_this.drawerConfig.disableClose; }), takeUntil(this._destroy$))
            .subscribe(function () { return _this.close(); });
    };
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    DrawerRef.prototype.dataChange = function (data) {
        this._dataFactory.setValue(data);
    };
    /**
     * Open drawer and notify observable
     */
    DrawerRef.prototype.open = function () {
        var _this = this;
        new Observable(function (obs) {
            setTimeout(function () {
                if (_this._openStart$.observers.length) {
                    _this._openStart$.next(obs);
                }
                else {
                    obs.next();
                    obs.complete();
                }
            });
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: function () {
                if (_this.activeAction) {
                    _this.openSide();
                }
                _this._drawerContainerRef.open();
                _this._afterOpened$.next();
                _this._afterOpened$.complete();
            },
            error: function () {
                _this.destroy();
            },
        });
    };
    /**
     * Close the drawer.
     * @param result Optional result to return to the dialog opener.
     */
    DrawerRef.prototype.close = function (result) {
        var _this = this;
        new Observable(function (observer) {
            if (_this._closeStart$.observers.length) {
                zip.apply(void 0, __spread(_this._closeStart$.observers.map(function (item) {
                    return Observable.create(function (closeObserver) {
                        item.next(closeObserver);
                    });
                }))).pipe(takeUntil(_this._destroy$))
                    .subscribe(function () {
                    observer.next();
                    observer.complete();
                }, function () {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: function () {
                _this._drawerContainerRef.close();
                _this._result = result;
                _this._afterClosed$.next(result);
                _this.destroy();
            }
        });
    };
    /**
     * Open the side of the drawer
     */
    DrawerRef.prototype.openSide = function () {
        this._isSideOpen = true;
        this._sideToggle.next(this._isSideOpen);
    };
    /**
     * Close the side of the drawer
     */
    DrawerRef.prototype.closeSide = function () {
        this._isSideOpen = false;
        this._sideToggle.next(this._isSideOpen);
        this.setActiveAction(null);
    };
    /**
     * Toggle the side of the drawer
     */
    DrawerRef.prototype.toggleSide = function () {
        this.isSideOpen ? this.closeSide() : this.openSide();
    };
    /**
     * Change active action
     * @param name
     */
    DrawerRef.prototype.setActiveAction = function (name) {
        this._activeAction.next(name);
        if (name) {
            this.openSide();
        }
    };
    /**
     * Store opened menu reference and subscribe for auto remove
     * @param name
     * @param ref
     */
    DrawerRef.prototype.addMenuRef = function (name, ref) {
        var _this = this;
        this._menuRefs.set(name, ref);
        ref.afterClosed()
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(function () {
            _this._menuRefs.delete(name);
        });
    };
    /**
     * Get opened menu reference by name
     * @param name
     */
    DrawerRef.prototype.getMenuRef = function (name) {
        return this._menuRefs.get(name);
    };
    DrawerRef.prototype.getAction = function (name) {
        return this.drawerConfig.actions.find(function (action) { return action.name === name; });
    };
    /**
     * Do update for icon for target action
     * @param name
     * @param icon
     */
    DrawerRef.prototype.updateActionIcon = function (name, icon) {
        var action = this.getAction(name);
        if (action) {
            action.icon = icon;
            this._actionsUpdated$.next(name);
        }
    };
    /**
     * Do update
     * @param name
     * @param data
     */
    DrawerRef.prototype.updateAction = function (name, data) {
        var action = this.getAction(name);
        if (action) {
            var allowedFields_1 = ['icon', 'type', 'toggle', 'tooltip', 'close', 'closeSide', 'component', 'data'];
            var forUpdate = Object.keys(data).filter(function (key) { return allowedFields_1.indexOf(key) > -1; });
            forUpdate.forEach(function (key) {
                action[key] = data[key];
            });
            this._actionsUpdated$.next(name);
        }
    };
    DrawerRef.prototype.updateDrawerWidth = function (width) {
        this.resizeController.updateMainWidth(width);
    };
    DrawerRef.prototype.updateSideDrawerWidth = function (width) {
        this.resizeController.updateSideWidth(width);
    };
    DrawerRef.prototype.destroy = function () {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._drawerComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    };
    return DrawerRef;
}());

var FsDrawerMenuComponent = /** @class */ (function (_super) {
    __extends(FsDrawerMenuComponent, _super);
    function FsDrawerMenuComponent() {
        return _super.call(this) || this;
    }
    FsDrawerMenuComponent.prototype.setDrawerMenuRef = function (value) {
        this.ref = value;
        // this.config = this.externalMenuRef.config;
    };
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    FsDrawerMenuComponent.prototype.attachComponentPortal = function (portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    };
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    FsDrawerMenuComponent.prototype.attachTemplatePortal = function (portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    };
    __decorate([
        ViewChild(CdkPortalOutlet, { static: true }),
        __metadata("design:type", CdkPortalOutlet)
    ], FsDrawerMenuComponent.prototype, "_portalOutlet", void 0);
    FsDrawerMenuComponent = __decorate([
        Component({
            selector: 'fs-drawer-menu',
            template: "<ng-template cdkPortalOutlet></ng-template>\n",
            host: {
                'class': 'mat-elevation-z2'
            },
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [":host{padding:15px;background:#fff;border-radius:2px;overflow:auto}"]
        }),
        __metadata("design:paramtypes", [])
    ], FsDrawerMenuComponent);
    return FsDrawerMenuComponent;
}(BasePortalOutlet));

var DrawerMenuRef = /** @class */ (function () {
    function DrawerMenuRef(_overlayRef, _dataFactory) {
        var _this = this;
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the menu has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the menu has started closing. */
        this._closeStart$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._overlayRef.backdropClick()
            .pipe(takeUntil(this._destroy$))
            .subscribe(function () {
            _this.close();
        });
    }
    Object.defineProperty(DrawerMenuRef.prototype, "menuData", {
        /**
         * Getter for DRAWER_MENU_DATA for current drawer
         */
        get: function () {
            return __assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "containerRef", {
        /**
         * Set reference to menu container
         * @param value
         */
        set: function (value) {
            this._externalMenuContainerRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "componentRef", {
        /**
         * Set reference to menu component
         * @param value
         */
        set: function (value) {
            this._externalMenuComponentRef = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerMenuRef.prototype, "dataChanged$", {
        /**
         * Gets an observable that is notified when data in DRAWER_DATA was changed
         */
        get: function () {
            return this._dataFactory.dataChange$;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    DrawerMenuRef.prototype.dataChange = function (data) {
        this._dataFactory.setValue(data);
    };
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    DrawerMenuRef.prototype.afterClosed = function () {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    };
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    DrawerMenuRef.prototype.closeStart = function () {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    };
    /**
     * Close the menu.
     * @param result Optional result to return to the dialog opener.
     */
    DrawerMenuRef.prototype.close = function (result) {
        var _this = this;
        new Observable(function (observer) {
            if (_this._closeStart$.observers.length) {
                zip.apply(void 0, __spread(_this._closeStart$.observers.map(function (item) {
                    return Observable.create(function (closeObserver) {
                        item.next(closeObserver);
                    });
                }))).pipe(takeUntil(_this._destroy$))
                    .subscribe(function () {
                    observer.next();
                    observer.complete();
                }, function () {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: function () {
                _this._result = result;
                _this._afterClosed$.next(result);
                _this.destroy();
            }
        });
    };
    DrawerMenuRef.prototype.destroy = function () {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    };
    return DrawerMenuRef;
}());

var DrawerData = /** @class */ (function () {
    function DrawerData(data) {
        if (data === void 0) { data = {}; }
        this._dataChange = new Subject();
        this._destroy = new Subject();
        this._data = data;
    }
    DrawerData.createWithProxy = function (data) {
        if (data === void 0) { data = {}; }
        var drawerData = new DrawerData(data);
        return new Proxy(drawerData, {
            get: function (target, property) {
                if (typeof target[property] === 'function'
                    || property === '_data'
                    || target[property] instanceof Observable) {
                    return target[property];
                }
                else {
                    return target._data[property];
                }
            },
            set: function (target, property, value) {
                if (property !== '_data') {
                    target._data[property] = value;
                }
                else {
                    target[property] = value;
                }
                return true;
            },
            has: function (target, property) {
                return property in target._data;
            },
            ownKeys: function (target) {
                return Object.keys(target._data);
            },
            enumerate: function (target) {
                return Object.keys(target._data);
            },
            getOwnPropertyDescriptor: function (target, property) {
                return Object.getOwnPropertyDescriptor(target._data, property);
            }
        });
    };
    Object.defineProperty(DrawerData.prototype, "dataChange$", {
        get: function () {
            return this._dataChange.pipe(takeUntil(this._destroy));
        },
        enumerable: true,
        configurable: true
    });
    DrawerData.prototype.getValue = function () {
        return this._data;
    };
    DrawerData.prototype.setValue = function (value) {
        this._data = value;
        this._dataChange.next(this._data);
    };
    DrawerData.prototype.destroy = function () {
        this._destroy.next();
        this._destroy.complete();
    };
    return DrawerData;
}());

/** Injection token that can be used to access the data that was passed in to a drawer. */
var DRAWER_MENU_DATA = new InjectionToken('fs.drawer.menu-data');

var FsDrawerMenuService = /** @class */ (function () {
    function FsDrawerMenuService(_overlay, _injector, _breakpointObserver) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._breakpointObserver = _breakpointObserver;
    }
    FsDrawerMenuService.prototype.create = function (component, container, config) {
        var overlayRef = this.createOverlay(container);
        var dataFactory = DrawerData.createWithProxy(config.data);
        var menuRef = new DrawerMenuRef(overlayRef, dataFactory);
        var containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
        var componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
        menuRef.containerRef = containerRef;
        containerRef.setDrawerMenuRef(menuRef);
        menuRef.componentRef = componentRef;
        return menuRef;
    };
    FsDrawerMenuService.prototype.createOverlay = function (container) {
        var overlayConfig = this.getOverlayConfig(container);
        return this._overlay.create(overlayConfig);
    };
    FsDrawerMenuService.prototype.getOverlayConfig = function (container) {
        var element = new ElementRef(container); // positionStrategy needs ElementRef;
        var strategy = null;
        if (this._breakpointObserver.isMatched(Breakpoints.XSmall)) {
            strategy = this._overlay
                .position()
                .global()
                .centerHorizontally()
                .centerVertically();
        }
        else {
            var positions = [
                { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
            ];
            strategy = this._overlay
                .position()
                .flexibleConnectedTo(element)
                .withPositions(positions);
        }
        return new OverlayConfig({
            positionStrategy: strategy,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop'
        });
    };
    FsDrawerMenuService.prototype.attachContainer = function (overlayRef, menuRef, dataFactory) {
        var injector = this.createInjector(menuRef, dataFactory);
        var containerPortal = new ComponentPortal(FsDrawerMenuComponent, undefined, injector);
        var containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    };
    FsDrawerMenuService.prototype.attachComponent = function (componentRef, externalContainer, externalRef, config) {
        var injector = this.createInjector(externalRef, config);
        return externalContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    };
    FsDrawerMenuService.prototype.createInjector = function (componentRef, dataFactory) {
        var injectionTokens = new WeakMap([
            [DrawerMenuRef, componentRef],
            [DRAWER_MENU_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    };
    FsDrawerMenuService.ctorParameters = function () { return [
        { type: Overlay },
        { type: Injector },
        { type: BreakpointObserver }
    ]; };
    FsDrawerMenuService = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [Overlay,
            Injector,
            BreakpointObserver])
    ], FsDrawerMenuService);
    return FsDrawerMenuService;
}());

var FsDrawerActionsComponent = /** @class */ (function () {
    function FsDrawerActionsComponent(_drawerRef, _drawerMenu, _cdRef) {
        this._drawerRef = _drawerRef;
        this._drawerMenu = _drawerMenu;
        this._cdRef = _cdRef;
        this._destroy$ = new Subject();
    }
    FsDrawerActionsComponent.prototype.ngOnInit = function () {
    };
    FsDrawerActionsComponent.prototype.ngOnDestroy = function () {
        this._destroy$.next();
        this._destroy$.complete();
    };
    FsDrawerActionsComponent.prototype.actionClick = function (action, event) {
        var hasComponentType = action.type === FsDrawerAction.Component;
        var hasMenuType = action.type === FsDrawerAction.Menu;
        if (hasComponentType) {
            var menuRef = this._drawerMenu.create(action.component, event.srcElement, action);
            this._drawerRef.addMenuRef(action.menuRefName, menuRef);
            var params = {
                event: event,
                action: action,
                drawerRef: this._drawerRef,
                menuRef: menuRef
            };
            // Call click
            action.click.call(null, params);
            if (action.closeSide) {
                this._drawerRef.closeSide();
            }
        }
        else if (action.click) {
            var params = { event: event, action: action };
            action.click.call(null, params);
        }
        if (action.close) {
            this._drawerRef.close();
        }
        if (action.toggle && ((!hasComponentType && !hasMenuType) || action.closeSide)) {
            if (this._drawerRef.isSideOpen && this._drawerRef.activeAction === action.name) {
                this._drawerRef.toggleSide();
            }
            else {
                this._drawerRef.setActiveAction(action.name);
            }
        }
    };
    FsDrawerActionsComponent.ctorParameters = function () { return [
        { type: DrawerRef },
        { type: FsDrawerMenuService },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Array)
    ], FsDrawerActionsComponent.prototype, "actions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FsDrawerActionsComponent.prototype, "activeAction", void 0);
    FsDrawerActionsComponent = __decorate([
        Component({
            selector: 'fs-drawer-actions',
            template: "<div class=\"actions-container\">\n  <div *ngFor=\"let action of actions\" class=\"action-btn\">\n    <fs-drawer-action-item [action]=\"action\"\n                           [activeAction]=\"activeAction\"\n                           (actionClicked)=\"actionClick(action, $event)\">\n    </fs-drawer-action-item>\n  </div>\n</div>\n\n<div class=\"drag-icon\">\n  <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [":host{display:flex}.actions-container{flex:0}.drag-icon{display:flex;flex:1;align-items:center}"]
        }),
        __metadata("design:paramtypes", [DrawerRef,
            FsDrawerMenuService,
            ChangeDetectorRef])
    ], FsDrawerActionsComponent);
    return FsDrawerActionsComponent;
}());

var MAIN_DRAWER_DEFAULT_WIDTH = 500;
var SIDE_DRAWER_DEFAULT_WIDTH = 200;
var SIDE_RESIZE_BAR_WIDTH = 25;
var MAIN_RESIZE_ACTION_BAR_WIDTH = 40;
var DrawerSizeController = /** @class */ (function () {
    function DrawerSizeController(_drawerRef, _ngZone) {
        this._drawerRef = _drawerRef;
        this._ngZone = _ngZone;
        this._sideOpened = false;
        this._borderPadding = 0;
        this._destroy$ = new Subject();
        this._initDefaultConfigs();
        this._updateScreenWidth();
        this._listenWindowResize();
        this._listenSideToggle();
    }
    Object.defineProperty(DrawerSizeController.prototype, "mainElRef", {
        get: function () {
            return this._mainElRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerSizeController.prototype, "sideElRef", {
        get: function () {
            return this._sideElRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerSizeController.prototype, "mainConfig", {
        get: function () {
            return this._mainConfig;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerSizeController.prototype, "sideConfig", {
        get: function () {
            return this._sideConfig;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DrawerSizeController.prototype, "screenWidth", {
        get: function () {
            return this._screenWidth;
        },
        enumerable: true,
        configurable: true
    });
    DrawerSizeController.prototype.ngOnDestroy = function () {
        this._destroy$.next();
        this._destroy$.complete();
    };
    DrawerSizeController.prototype.registerElRef = function (el) {
        if (el.type === 'main') {
            this._registerMainRef(el);
        }
        else if (el.type === 'side') {
            this._registerSideRef(el);
        }
        else {
            throw Error('Unrecognized resize element type');
        }
    };
    DrawerSizeController.prototype.getInitialWidth = function (type) {
        if (type === 'main') {
            return this.mainConfig.initial;
        }
        else if (type === 'side') {
            return this.sideConfig.initial;
        }
        else {
            return void 0;
        }
    };
    DrawerSizeController.prototype.getMinWidth = function (type) {
        if (type === 'main') {
            return this.mainConfig.min;
        }
        else if (type === 'side') {
            return this.sideConfig.min;
        }
        else {
            return void 0;
        }
    };
    DrawerSizeController.prototype.getMaxWidth = function (type) {
        if (type === 'main') {
            return this.mainConfig.max;
        }
        else if (type === 'side') {
            return this.sideConfig.max;
        }
        else {
            return void 0;
        }
    };
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    DrawerSizeController.prototype.updateMainWidth = function (width) {
        var sideWidth = (this.sideElRef && this.sideElRef.width) || 0;
        this.mainElRef.updateWidth(sideWidth + width);
    };
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    DrawerSizeController.prototype.updateSideWidth = function (width) {
        if (this.sideElRef) {
            var currentWidth = this.mainElRef.width - this.sideElRef.width;
            this.mainElRef.updateWidth(currentWidth + width);
            this.sideElRef.updateWidth(width);
        }
    };
    /**
     * Push current drawer to be visible under new one opened
     * @param inFrontDrawer
     */
    DrawerSizeController.prototype.pushMainWidth = function (inFrontDrawer) {
        var inFrontDrawerTotalWidth = inFrontDrawer.resizeController.mainElRef.width + MAIN_RESIZE_ACTION_BAR_WIDTH;
        if (this.mainElRef.width <= inFrontDrawerTotalWidth) {
            this.updateMainWidth(inFrontDrawerTotalWidth);
        }
    };
    /**
     * Listen for browser resize and update restrictions
     */
    DrawerSizeController.prototype._listenWindowResize = function () {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            fromEvent(window, 'resize')
                .pipe(debounceTime(50), takeUntil(_this._destroy$))
                .subscribe(function () {
                _this._updateScreenWidth();
                _this._updateMinMaxStyles();
            });
        });
    };
    /**
     * Copy initial configs or set default values
     */
    DrawerSizeController.prototype._initDefaultConfigs = function () {
        this._mainConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.main)
                || {};
        this._mainConfig.initial = this._mainConfig.initial || MAIN_DRAWER_DEFAULT_WIDTH;
        this._sideConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.side)
                || {};
        this._sideConfig.initial = this._sideConfig.initial || SIDE_DRAWER_DEFAULT_WIDTH;
    };
    DrawerSizeController.prototype._registerMainRef = function (el) {
        this._mainElRef = el;
    };
    DrawerSizeController.prototype._registerSideRef = function (el) {
        this._sideElRef = el;
    };
    /**
     * Update current window size
     */
    DrawerSizeController.prototype._updateScreenWidth = function () {
        this._screenWidth = (window.innerWidth - this._borderPadding);
    };
    /**
     * Update min&max css props for containers
     */
    DrawerSizeController.prototype._updateMinMaxStyles = function () {
        this.mainElRef.setMinMaxStyles();
        if (this.sideElRef) {
            this.sideElRef.setMinMaxStyles();
        }
    };
    DrawerSizeController.prototype._listenSideToggle = function () {
        var _this = this;
        this._drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (opened) {
            if (_this._sideOpened === opened) {
                return;
            }
            _this._sideOpened = opened;
            if (opened) {
                var currentWidth = _this.mainElRef.width;
                var sideWidth = _this.getInitialWidth('side');
                _this._mainElRef.updateWidth(currentWidth + sideWidth + SIDE_RESIZE_BAR_WIDTH);
            }
            else {
                var actualSideWidth = _this.sideElRef.fsDrawerResizer.getBoundingClientRect().width;
                var mainWidth = _this.mainElRef.width - actualSideWidth - SIDE_RESIZE_BAR_WIDTH;
                _this._mainElRef.updateWidth(mainWidth);
            }
        });
    };
    DrawerSizeController.ctorParameters = function () { return [
        { type: DrawerRef },
        { type: NgZone }
    ]; };
    DrawerSizeController = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [DrawerRef,
            NgZone])
    ], DrawerSizeController);
    return DrawerSizeController;
}());

var FsDrawerComponent = /** @class */ (function (_super) {
    __extends(FsDrawerComponent, _super);
    function FsDrawerComponent(_el, _drawerMenu, _drawerRef, _cdRef, _resizeController) {
        var _this = _super.call(this) || this;
        _this._el = _el;
        _this._drawerMenu = _drawerMenu;
        _this._drawerRef = _drawerRef;
        _this._cdRef = _cdRef;
        _this._resizeController = _resizeController;
        _this.isOpen = false;
        _this.isOpenSide = false;
        _this.initialized = false;
        _this._sideOpen = false;
        _this._destroy$ = new Subject();
        _this._drawerRef.resizeController = _this._resizeController;
        return _this;
    }
    Object.defineProperty(FsDrawerComponent.prototype, "sideOpen", {
        get: function () {
            return this._sideOpen;
        },
        set: function (value) {
            this._sideOpen = value;
            this._el.nativeElement.classList
                .toggle('side-open', this.sideOpen);
        },
        enumerable: true,
        configurable: true
    });
    FsDrawerComponent.prototype.ngOnInit = function () {
        this._listenDataChanges();
    };
    FsDrawerComponent.prototype.ngOnDestroy = function () {
        this._destroy$.next();
        this._destroy$.complete();
    };
    FsDrawerComponent.prototype.open = function () {
        this.isOpen = true;
    };
    FsDrawerComponent.prototype.close = function () {
        this.isOpen = false;
    };
    FsDrawerComponent.prototype.openSide = function () {
        this.isOpenSide = true;
    };
    FsDrawerComponent.prototype.closeSide = function () {
        this.isOpenSide = false;
    };
    FsDrawerComponent.prototype.setDrawerRef = function (value) {
        var _this = this;
        this.drawerRef = value;
        this.config = this.drawerRef.drawerConfig;
        // Need to be like a parent for children resize
        this.drawerRef.drawerContentContainer = this._drawerContentContainer;
        this.drawerRef.drawerActionsContainer = this._drawerActionsContainer;
        this.drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe(function (opened) {
            _this.sideOpen = opened;
        });
        this.initialized = true;
    };
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    FsDrawerComponent.prototype.attachComponentPortal = function (portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    };
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    FsDrawerComponent.prototype.attachTemplatePortal = function (portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    };
    FsDrawerComponent.prototype._listenDataChanges = function () {
        var _this = this;
        this._drawerRef.dataChanged$
            .pipe(takeUntil(this._destroy$))
            .subscribe(function () {
            _this._cdRef.detectChanges();
        });
    };
    FsDrawerComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: FsDrawerMenuService },
        { type: DrawerRef },
        { type: ChangeDetectorRef },
        { type: DrawerSizeController }
    ]; };
    __decorate([
        ViewChild(CdkPortalOutlet, { static: true }),
        __metadata("design:type", CdkPortalOutlet)
    ], FsDrawerComponent.prototype, "_portalOutlet", void 0);
    __decorate([
        ViewChild('drawerContentContainer', { static: true }),
        __metadata("design:type", ElementRef)
    ], FsDrawerComponent.prototype, "_drawerContentContainer", void 0);
    __decorate([
        ViewChild('drawerActionsContainer', { read: ElementRef, static: true }),
        __metadata("design:type", ElementRef)
    ], FsDrawerComponent.prototype, "_drawerActionsContainer", void 0);
    FsDrawerComponent = __decorate([
        Component({
            selector: 'fs-drawer',
            template: "<div class=\"mat-elevation-z2 drawer\" #drawer\n     hidden\n     [ngClass]=\"config.position\"\n     [hidden]=\"!initialized\">\n  <ng-container>\n    <fs-drawer-actions class=\"drawer-actions\"\n                       #drawerActionsContainer\n                       type=\"main\"\n                       [fsDrawerResizer]=\"drawer\"\n                       [resizable]=\"drawerRef.drawerConfig.resizable\"\n                       [sizeController]=\"drawerRef.resizeController\"\n                       [direction]=\"config.position\"\n                       [actions]=\"config.actions\"\n                       [activeAction]=\"drawerRef.activeAction$ | async\">\n    </fs-drawer-actions>\n    <div class=\"drawer-container\" #drawerContentContainer>\n      <ng-template cdkPortalOutlet></ng-template>\n    </div>\n  </ng-container>\n</div>\n",
            providers: [
                FsDrawerMenuService,
                DrawerSizeController,
            ],
            host: {
                'class': 'fs-drawer-container',
            },
            encapsulation: ViewEncapsulation.None,
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [ElementRef,
            FsDrawerMenuService,
            DrawerRef,
            ChangeDetectorRef,
            DrawerSizeController])
    ], FsDrawerComponent);
    return FsDrawerComponent;
}(BasePortalOutlet));

var FsDrawerActionDirective = /** @class */ (function () {
    function FsDrawerActionDirective() {
    }
    __decorate([
        Input('fsDrawerAction'),
        __metadata("design:type", String)
    ], FsDrawerActionDirective.prototype, "name", void 0);
    FsDrawerActionDirective = __decorate([
        Directive({
            selector: '[fsDrawerAction]',
        })
    ], FsDrawerActionDirective);
    return FsDrawerActionDirective;
}());

var FsDrawerSideComponent = /** @class */ (function () {
    function FsDrawerSideComponent(_cdRef, _renderer, _elRef) {
        this._cdRef = _cdRef;
        this._renderer = _renderer;
        this._elRef = _elRef;
        this.classSide = true;
        this.activeTemplate = null;
        this._hidden = false;
        this._destroy$ = new EventEmitter();
    }
    Object.defineProperty(FsDrawerSideComponent.prototype, "hidden", {
        set: function (value) {
            this._hidden = value;
            if (this._hidden) {
                this._renderer.setAttribute(this._elRef.nativeElement, 'hidden', 'true');
            }
            else {
                this._renderer.removeAttribute(this._elRef.nativeElement, 'hidden');
            }
        },
        enumerable: true,
        configurable: true
    });
    FsDrawerSideComponent.prototype.ngOnInit = function () {
        this.hidden = true;
        if (!this.drawer) {
            console.error('Drawer reference is null for @Input("fsDrawerSide")');
        }
        this._subscribeToActionChanges();
    };
    FsDrawerSideComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        setTimeout(function () {
            // Check current side status
            if (_this.drawer) {
                _this.hidden = !_this.drawer.isSideOpen;
            }
            _this._updateActiveActionTemplate();
        });
    };
    FsDrawerSideComponent.prototype.ngOnDestroy = function () {
        this._destroy$.emit();
        this._destroy$.complete();
    };
    FsDrawerSideComponent.prototype._subscribeToActionChanges = function () {
        var _this = this;
        if (this.drawer) {
            this.drawer.sideToggle$
                .pipe(takeUntil(this._destroy$))
                .subscribe(function () {
                _this.hidden = !_this.drawer.isSideOpen;
                _this._updateActiveActionTemplate();
                _this._cdRef.detectChanges();
            });
        }
    };
    FsDrawerSideComponent.prototype._updateActiveActionTemplate = function () {
        if (this.drawer) {
            var activatedAction_1 = this.drawer.activeAction;
            if (this.drawer.isSideOpen && activatedAction_1) {
                var selectedActionIndex = this.actions
                    .toArray()
                    .findIndex(function (action) { return action.name === activatedAction_1; });
                this.activeTemplate = this.actionsTemplates.toArray()[selectedActionIndex];
            }
            else {
                this.activeTemplate = null;
            }
        }
    };
    FsDrawerSideComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    __decorate([
        Input('fsDrawerSide'),
        __metadata("design:type", DrawerRef)
    ], FsDrawerSideComponent.prototype, "drawer", void 0);
    __decorate([
        HostBinding('class.side'),
        __metadata("design:type", Object)
    ], FsDrawerSideComponent.prototype, "classSide", void 0);
    __decorate([
        ContentChildren(FsDrawerActionDirective),
        __metadata("design:type", QueryList)
    ], FsDrawerSideComponent.prototype, "actions", void 0);
    __decorate([
        ContentChildren(FsDrawerActionDirective, { read: TemplateRef }),
        __metadata("design:type", QueryList)
    ], FsDrawerSideComponent.prototype, "actionsTemplates", void 0);
    FsDrawerSideComponent = __decorate([
        Component({
            selector: '[fsDrawerSide]',
            template: "<ng-container [ngSwitch]=\"drawer.drawerConfig.position\" *ngIf=\"activeTemplate\">\n  <ng-container *ngSwitchCase=\"'right'\">\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"left\"\n         type=\"side\"\n         [fsDrawerResizer]=\"sideContainer\"\n         [resizable]=\"drawer.drawerConfig.resizable\"\n         [sizeController]=\"drawer.resizeController\"\n         [parentContainer]=\"drawer.drawerContentContainer\"\n         [actionsContainer]=\"drawer.drawerActionsContainer\"\n    >\n      <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'left'\">\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"right\"\n         [fsDrawerResizer]=\"sideContainer\"\n    >\n    <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".resize-icon{width:24px;height:24px;line-height:24px}.resize-icon span{width:24px}"]
        }),
        __metadata("design:paramtypes", [ChangeDetectorRef,
            Renderer2,
            ElementRef])
    ], FsDrawerSideComponent);
    return FsDrawerSideComponent;
}());

var FsDrawerActionItemComponent = /** @class */ (function () {
    function FsDrawerActionItemComponent(drawer, _cdRef) {
        this.drawer = drawer;
        this._cdRef = _cdRef;
        this.actionClicked = new EventEmitter();
        this.isActive = false;
        this.actionTypes = FsDrawerAction;
        this._destroy$ = new Subject();
        this._listenActionChanges();
        this._listenDataChanges();
    }
    FsDrawerActionItemComponent.prototype.ngOnInit = function () {
        this._updateVisibilityAndLinks();
    };
    FsDrawerActionItemComponent.prototype.ngOnChanges = function (changes) {
        if (changes.activeAction) {
            this.isActive = this.action.name !== '' && this.action.name === this.activeAction;
        }
    };
    FsDrawerActionItemComponent.prototype.actionClick = function (event) {
        this.actionClicked.emit(event);
    };
    FsDrawerActionItemComponent.prototype.menuActionClick = function (action, event) {
        if (action.click) {
            action.click.call(null, {
                data: this.drawer.drawerData,
                event: event,
                drawerRef: this.drawer,
                action: action
            });
        }
    };
    FsDrawerActionItemComponent.prototype._listenActionChanges = function () {
        var _this = this;
        this.drawer.actionUpdated$
            .pipe(filter(function (name) { return name === _this.action.name; }), takeUntil(this._destroy$))
            .subscribe(function () {
            _this._cdRef.detectChanges();
        });
    };
    FsDrawerActionItemComponent.prototype._listenDataChanges = function () {
        var _this = this;
        this.drawer.dataChanged$
            .pipe(takeUntil(this._destroy$), debounceTime(50))
            .subscribe(function () {
            _this._updateVisibilityAndLinks();
        });
    };
    FsDrawerActionItemComponent.prototype._updateVisibilityAndLinks = function () {
        this._updateVisibility();
        this._updateRouterLinks();
        this._cdRef.detectChanges();
    };
    FsDrawerActionItemComponent.prototype._updateVisibility = function () {
        this.action.checkVisibility(this.drawer.drawerData);
    };
    FsDrawerActionItemComponent.prototype._updateRouterLinks = function () {
        if (this.action.type === this.actionTypes.Menu) {
            this.action.updateRouterLink({
                data: this.drawer.drawerData,
                drawerRef: this.drawer
            });
        }
    };
    FsDrawerActionItemComponent.ctorParameters = function () { return [
        { type: DrawerRef },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Action)
    ], FsDrawerActionItemComponent.prototype, "action", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FsDrawerActionItemComponent.prototype, "activeAction", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], FsDrawerActionItemComponent.prototype, "actionClicked", void 0);
    FsDrawerActionItemComponent = __decorate([
        Component({
            selector: 'fs-drawer-action-item',
            template: "<ng-container [ngSwitch]=\"action.type\">\n  <ng-container *ngSwitchCase=\"actionTypes.Button\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Menu\">\n    <ng-container *ngIf=\"action.visible\">\n      <button mat-icon-button\n              type=\"button\"\n              class=\"sub-action\"\n              [fsMenuTriggerFor]=\"menu\"\n              [matTooltip]=\"action.tooltip\"\n              [class.active]=\"isActive\"\n              (click)=\"actionClick($event)\">\n        <i class=\"material-icons\">{{action.icon}}</i>\n      </button>\n\n      <fs-menu #menu>\n        <ng-container *ngFor=\"let menuAction of action.menuActions\">\n          <ng-container *ngIf=\"menuAction.isGroup else simpleMenuItem\">\n            <fs-menu-group [label]=\"menuAction.label\" [hidden]=\"!menuAction.visible\">\n              <ng-container *ngFor=\"let groupAction of menuAction.actions\">\n                <ng-template fs-menu-item\n                             [hidden]=\"!groupAction.visible\"\n                             [link]=\"groupAction.routerLink?.link\"\n                             [queryParams]=\"groupAction.routerLink?.queryParams\"\n                             (click)=\"menuActionClick(groupAction, $event);\">\n                  <mat-icon *ngIf=\"menuAction.icon\">{{groupAction.icon}}</mat-icon>\n                  {{groupAction.label}}\n                </ng-template>\n              </ng-container>\n            </fs-menu-group>\n          </ng-container>\n          <ng-template #simpleMenuItem>\n            <ng-template fs-menu-item\n                         [hidden]=\"!menuAction.visible\"\n                         [link]=\"menuAction.routerLink?.link\"\n                         [queryParams]=\"menuAction.routerLink?.queryParams\"\n                         (click)=\"menuActionClick(menuAction, $event);\">\n              <i class=\"material-icons\" *ngIf=\"menuAction.icon\">{{menuAction.icon}}</i>\n              <span>{{menuAction.label}}</span>\n            </ng-template>\n          </ng-template>\n        </ng-container>\n      </fs-menu>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Component\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n</ng-container>\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [DrawerRef,
            ChangeDetectorRef])
    ], FsDrawerActionItemComponent);
    return FsDrawerActionItemComponent;
}());

var FsDrawerContentComponent = /** @class */ (function () {
    function FsDrawerContentComponent() {
    }
    FsDrawerContentComponent = __decorate([
        Component({
            selector: '[fsDrawerContent]',
            template: '<div class="content"><ng-content></ng-content></div>',
            host: {
                'class': 'content-container'
            }
        })
    ], FsDrawerContentComponent);
    return FsDrawerContentComponent;
}());

var FsDrawerResizerDirective = /** @class */ (function () {
    function FsDrawerResizerDirective(_el, _renderer, _ngZone) {
        this._el = _el;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this.fsDrawerResizer = this._el.nativeElement;
        this.direction = 'left';
        this.resizable = true;
        this._dragStartHandler = this._dragStart.bind(this);
        this._dragHandler = this._drag.bind(this);
        this._dragEndHandler = this._dragEnd.bind(this);
        this._x = 0;
        this._width = 0;
        this._actionsWidth = 0;
        this._destroy$ = new Subject();
    }
    Object.defineProperty(FsDrawerResizerDirective.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FsDrawerResizerDirective.prototype, "minWidth", {
        get: function () {
            var minWidth = this.sizeController.getMinWidth(this.type);
            if (minWidth && minWidth >= 0) {
                if (minWidth > this.sizeController.screenWidth) {
                    return this.sizeController.screenWidth;
                }
                else {
                    return minWidth;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FsDrawerResizerDirective.prototype, "maxWidth", {
        get: function () {
            var maxWidth = this.sizeController.getMaxWidth(this.type);
            var parentContainerWidth = null;
            if (this.parentContainer) {
                parentContainerWidth = this._getElementWidth(this.parentContainer.nativeElement);
            }
            if (parentContainerWidth !== null) {
                return !maxWidth || maxWidth >= parentContainerWidth
                    ? parentContainerWidth - this._actionsWidth * 2
                    : maxWidth;
            }
            else {
                return !maxWidth || maxWidth >= this.sizeController.screenWidth
                    ? this.sizeController.screenWidth
                    : maxWidth;
            }
        },
        enumerable: true,
        configurable: true
    });
    FsDrawerResizerDirective.prototype.ngOnInit = function () {
        var _this = this;
        this.sizeController.registerElRef(this);
        if (this.resizable) {
            this._ngZone.runOutsideAngular(function () {
                _this._el.nativeElement.addEventListener('mousedown', _this._dragStartHandler, false);
                _this._el.nativeElement.addEventListener('touchstart', _this._dragStartHandler, false);
            });
            if (this.actionsContainer) {
                this._actionsWidth = this._getElementWidth(this.actionsContainer.nativeElement);
            }
            this.setMinMaxStyles();
            var minWidth = this.sizeController.getMinWidth(this.type);
            var width = this.sizeController.getInitialWidth(this.type)
                || this._getElementWidth(this.fsDrawerResizer);
            if (width < minWidth) {
                width = minWidth;
            }
            this.updateWidth(width);
        }
    };
    FsDrawerResizerDirective.prototype.updateWidth = function (width) {
        var _this = this;
        this._width = width;
        requestAnimationFrame(function () {
            _this._renderer.setStyle(_this.fsDrawerResizer, 'width', width + "px");
        });
    };
    FsDrawerResizerDirective.prototype.ngOnDestroy = function () {
        this._el.nativeElement.removeEventListener('mousedown', this._dragStartHandler, false);
        this._el.nativeElement.removeEventListener('touchstart', this._dragStartHandler, false);
        this._destroy$.next();
        this._destroy$.complete();
    };
    /**
     * Set inline styles min/max width
     */
    FsDrawerResizerDirective.prototype.setMinMaxStyles = function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this._renderer.setStyle(_this.fsDrawerResizer, 'min-width', _this.minWidth + "px");
            _this._renderer.setStyle(_this.fsDrawerResizer, 'max-width', _this.maxWidth + "px");
        });
    };
    /**
     * Subscribe to move events and init base dimensions/restrictions
     * @param event { MouseEvent }
     */
    FsDrawerResizerDirective.prototype._dragStart = function (event) {
        this._x = this._getClientX(event);
        this._width = this._getElementWidth(this.fsDrawerResizer);
        this.setMinMaxStyles();
        document.addEventListener('touchmove', this._dragHandler, false);
        document.addEventListener('touchend', this._dragEndHandler, false);
        document.addEventListener('mousemove', this._dragHandler, false);
        document.addEventListener('mouseup', this._dragEndHandler, false);
    };
    /**
     * Update coordinates during drag
     * @param event
     */
    FsDrawerResizerDirective.prototype._drag = function (event) {
        var clientX = this._getClientX(event);
        var predictedWidth = this._calcWidth(this.direction, clientX);
        this._updatePosition(clientX, predictedWidth);
        this._emitResizeEvent();
    };
    /**
     * Remove listeners when drag finished
     * @param event
     */
    FsDrawerResizerDirective.prototype._dragEnd = function (event) {
        document.removeEventListener('mousemove', this._dragHandler, false);
        document.removeEventListener('mouseup', this._dragEndHandler, false);
        document.removeEventListener('touchmove', this._dragHandler, false);
        document.removeEventListener('touchend', this._dragEndHandler, false);
    };
    /**
     *
     * @param event
     */
    FsDrawerResizerDirective.prototype._getClientX = function (event) {
        return event.touches ? event.touches[0].clientX : event.clientX;
    };
    /**
     * Will return width of element
     * @param el
     */
    FsDrawerResizerDirective.prototype._getElementWidth = function (el) {
        return el.getBoundingClientRect().width;
    };
    /**
     * Update width and position of target element
     * @param clientX
     * @param width
     */
    FsDrawerResizerDirective.prototype._updatePosition = function (clientX, width) {
        this._x = clientX;
        this.updateWidth(width < 0 ? 0 : width);
    };
    /**
     * Calc new width based on offset from previous position
     * @param direction
     * @param clientX
     */
    FsDrawerResizerDirective.prototype._calcWidth = function (direction, clientX) {
        var directionSign = direction === 'left' ? -1 : 1;
        return this._width + (this._x - clientX) * directionSign;
    };
    /**
     * Resize event for Window
     */
    FsDrawerResizerDirective.prototype._emitResizeEvent = function () {
        var resizeEvent = window.document.createEvent('UIEvents');
        resizeEvent.initEvent('resize', true, false);
        window.dispatchEvent(resizeEvent);
    };
    FsDrawerResizerDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FsDrawerResizerDirective.prototype, "fsDrawerResizer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], FsDrawerResizerDirective.prototype, "type", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FsDrawerResizerDirective.prototype, "direction", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], FsDrawerResizerDirective.prototype, "resizable", void 0);
    __decorate([
        Input(),
        __metadata("design:type", ElementRef)
    ], FsDrawerResizerDirective.prototype, "parentContainer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", ElementRef)
    ], FsDrawerResizerDirective.prototype, "actionsContainer", void 0);
    __decorate([
        Input(),
        __metadata("design:type", DrawerSizeController)
    ], FsDrawerResizerDirective.prototype, "sizeController", void 0);
    FsDrawerResizerDirective = __decorate([
        Directive({
            selector: '[fsDrawerResizer]',
            host: {
                '[style.cursor]': '"col-resize"',
            }
        }),
        __metadata("design:paramtypes", [ElementRef,
            Renderer2,
            NgZone])
    ], FsDrawerResizerDirective);
    return FsDrawerResizerDirective;
}());

/** Injection token that can be used to access the data that was passed in to a drawer. */
var DRAWER_DATA = new InjectionToken('DrawerData');

var FsDrawerService = /** @class */ (function () {
    function FsDrawerService(_parentDrawerService, _overlay, _injector) {
        this._parentDrawerService = _parentDrawerService;
        this._overlay = _overlay;
        this._injector = _injector;
        this._drawerRefs = new Set();
        this._destroy$ = new Subject();
    }
    FsDrawerService.prototype.ngOnDestroy = function () {
        this._destroy$.next();
        this._destroy$.complete();
    };
    FsDrawerService.prototype.open = function (component, config) {
        var _this = this;
        var overlayRef = this._createOverlay();
        var dataFactory = DrawerData.createWithProxy(config.data);
        var drawerRef = new DrawerRef(overlayRef, dataFactory, config);
        var containerRef = this._attachDrawerContainer(overlayRef, drawerRef, dataFactory);
        var componentRef = this._attachComponent(component, containerRef, drawerRef, dataFactory);
        drawerRef.containerRef = containerRef;
        containerRef.setDrawerRef(drawerRef);
        drawerRef.componentRef = componentRef;
        drawerRef.events();
        drawerRef.open();
        this._storeDrawerRef(drawerRef);
        merge(drawerRef.afterOpened$, drawerRef.afterClosed$)
            .pipe(takeUntil(this._destroy$))
            .subscribe(function () {
            setTimeout(function () {
                _this._applyBackdrop();
                _this._applyBodyOpenClass();
            });
        });
        return drawerRef;
    };
    FsDrawerService.prototype.closeAll = function () {
        this._drawerRefs.forEach(function (ref) { return ref.close(); });
        if (this._parentDrawerService) {
            this._parentDrawerService.closeAll();
        }
    };
    FsDrawerService.prototype._applyBackdrop = function () {
        var _this = this;
        Array.from(this._drawerRefs)
            .forEach(function (drawerRef, index) {
            var backdrop = drawerRef.overlayRef.backdropElement;
            if (backdrop) {
                if (index && index === (_this._drawerRefs.size - 1)) {
                    backdrop.classList.add('fs-drawer-backdrop-active');
                }
                else {
                    backdrop.classList.remove('fs-drawer-backdrop-active');
                }
            }
        });
    };
    FsDrawerService.prototype._applyBodyOpenClass = function () {
        if (this._drawerRefs.size) {
            document.body.classList.add('fs-drawer-open');
        }
        else {
            document.body.classList.remove('fs-drawer-open');
        }
    };
    FsDrawerService.prototype._storeDrawerRef = function (ref) {
        var _this = this;
        this._drawerRefs.add(ref);
        this._pushDrawersCascade();
        ref.destroy$
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(function () {
            _this._drawerRefs.delete(ref);
        });
    };
    /**
     * In case, when we want to open more than 1 drawer
     * our previously opened drawers should be visible
     *
     *      d1   d2   d3
     *     ---- ---- ---
     *    | x  | x1 | x2
     *    | y  | y1 | y2
     *    | z  | z1 | z2
     *     ---- ---- ---
     *
     * Where d1, d2 - previously opened drawers
     * d1 and d2 must be pushed left to be visible under just opened d3
     */
    FsDrawerService.prototype._pushDrawersCascade = function () {
        var _this = this;
        if (this._drawerRefs.size > 1) {
            // SetTimeout should be here because we must wait render newly opened drawer
            // to be able to get his width
            setTimeout(function () {
                var refsArr = Array.from(_this._drawerRefs.values());
                for (var i = refsArr.length - 1; i > 0; i--) {
                    var prevRef = refsArr[i - 1];
                    var currRef = refsArr[i];
                    prevRef.resizeController.pushMainWidth(currRef);
                }
            });
        }
    };
    FsDrawerService.prototype._createOverlay = function () {
        var overlayConfig = this._getOverlayConfig();
        return this._overlay.create(overlayConfig);
    };
    FsDrawerService.prototype._getOverlayConfig = function () {
        return new OverlayConfig({
            hasBackdrop: true,
            backdropClass: 'fs-drawer-backdrop'
        });
    };
    FsDrawerService.prototype._attachDrawerContainer = function (overlayRef, drawerRef, dataFactory) {
        var injector = this._createInjector(drawerRef, dataFactory);
        var containerPortal = new ComponentPortal(FsDrawerComponent, undefined, injector);
        var containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    };
    FsDrawerService.prototype._attachComponent = function (componentRef, drawerContainer, drawerRef, dataFactory) {
        var injector = this._createInjector(drawerRef, dataFactory);
        return drawerContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    };
    FsDrawerService.prototype._createInjector = function (componentRef, dataFactory) {
        var injectionTokens = new WeakMap([
            [DrawerRef, componentRef],
            [DRAWER_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    };
    FsDrawerService.ctorParameters = function () { return [
        { type: FsDrawerService, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: Overlay },
        { type: Injector }
    ]; };
    FsDrawerService = __decorate([
        Injectable(),
        __param(0, Optional()), __param(0, SkipSelf()),
        __metadata("design:paramtypes", [FsDrawerService,
            Overlay,
            Injector])
    ], FsDrawerService);
    return FsDrawerService;
}());

var FsDrawerModule = /** @class */ (function () {
    function FsDrawerModule() {
    }
    FsDrawerModule = __decorate([
        NgModule({
            imports: [
                CommonModule,
                MatTooltipModule,
                MatButtonModule,
                MatIconModule,
                OverlayModule,
                PortalModule,
                FsMenuModule,
                MatMenuModule,
            ],
            exports: [
                FsDrawerComponent,
                FsDrawerSideComponent,
                FsDrawerContentComponent,
                FsDrawerActionDirective,
                FsDrawerResizerDirective,
            ],
            declarations: [
                FsDrawerSideComponent,
                FsDrawerComponent,
                FsDrawerActionsComponent,
                FsDrawerActionItemComponent,
                FsDrawerContentComponent,
                FsDrawerActionDirective,
                FsDrawerResizerDirective,
                FsDrawerMenuComponent,
            ],
            providers: [FsDrawerService],
        })
    ], FsDrawerModule);
    return FsDrawerModule;
}());

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DRAWER_DATA, DRAWER_MENU_DATA, DrawerData, DrawerMenuRef, DrawerRef, FsDrawerAction, FsDrawerActionDirective, FsDrawerComponent, FsDrawerContentComponent, FsDrawerModule, FsDrawerResizerDirective, FsDrawerService, FsDrawerSideComponent, FsDrawerMenuService as ɵa, DrawerSizeController as ɵb, FsDrawerActionsComponent as ɵc, FsDrawerActionItemComponent as ɵd, FsDrawerMenuComponent as ɵe };
//# sourceMappingURL=firestitch-drawer.js.map
