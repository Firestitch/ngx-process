(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/portal'), require('@angular/cdk/overlay'), require('@angular/material/button'), require('@angular/material/icon'), require('@angular/material/menu'), require('@angular/material/tooltip'), require('@firestitch/menu'), require('rxjs'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/cdk/layout')) :
    typeof define === 'function' && define.amd ? define('@firestitch/drawer', ['exports', '@angular/core', '@angular/common', '@angular/cdk/portal', '@angular/cdk/overlay', '@angular/material/button', '@angular/material/icon', '@angular/material/menu', '@angular/material/tooltip', '@firestitch/menu', 'rxjs', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/cdk/layout'], factory) :
    (global = global || self, factory((global.firestitch = global.firestitch || {}, global.firestitch.drawer = {}), global.ng.core, global.ng.common, global.ng.cdk.portal, global.ng.cdk.overlay, global.ng.material.button, global.ng.material.icon, global.ng.material.menu, global.ng.material.tooltip, global.menu$1, global.rxjs, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.cdk.layout));
}(this, (function (exports, core, common, portal, overlay, button, icon, menu, tooltip, menu$1, rxjs, keycodes, operators, layout) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    (function (FsDrawerAction) {
        FsDrawerAction["Button"] = "button";
        FsDrawerAction["Menu"] = "menu";
        FsDrawerAction["Component"] = "component";
    })(exports.FsDrawerAction || (exports.FsDrawerAction = {}));

    var BaseAction = /** @class */ (function () {
        function BaseAction(data) {
            if (data === void 0) { data = {}; }
            this._visible = true;
            this._icon = data.icon || '';
            this._click = data.click || null;
            this._link = data.link;
            this._show = data.show || null;
        }
        Object.defineProperty(BaseAction.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "click", {
            get: function () {
                return this._click;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "routerLink", {
            get: function () {
                return this._routerLink;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            enumerable: true,
            configurable: true
        });
        BaseAction.prototype.checkVisibility = function (data) {
            if (this._show) {
                this._visible = this._show(data);
            }
        };
        BaseAction.prototype.updateRouterLink = function (data) {
            if (this._visible && this._link) {
                this._routerLink = this._link(data);
            }
        };
        return BaseAction;
    }());

    var MenuAction = /** @class */ (function (_super) {
        __extends(MenuAction, _super);
        function MenuAction(data) {
            if (data === void 0) { data = {}; }
            var _this = _super.call(this, data) || this;
            _this.actions = [];
            _this._isGroup = false;
            if (Array.isArray(data.actions)) {
                _this._isGroup = true;
                _this.actions = data.actions.map(function (action) { return new MenuAction(action); });
            }
            _this._label = data.label || '';
            return _this;
        }
        Object.defineProperty(MenuAction.prototype, "isGroup", {
            get: function () {
                return this._isGroup;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuAction.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        MenuAction.prototype.updateRouterLink = function (data) {
            _super.prototype.updateRouterLink.call(this, data);
            if (this.actions.length > 0) {
                this.actions.forEach(function (action) {
                    action.updateRouterLink(data);
                });
            }
        };
        MenuAction.prototype.checkVisibility = function (data) {
            _super.prototype.checkVisibility.call(this, data);
            if (this.actions.length > 0) {
                this.actions.forEach(function (action) {
                    action.checkVisibility(data);
                });
            }
            if (this.actions.length > 0) {
                this._visible = this.actions.some(function (action) { return action.visible; });
            }
        };
        return MenuAction;
    }(BaseAction));

    var Action = /** @class */ (function (_super) {
        __extends(Action, _super);
        function Action(data) {
            if (data === void 0) { data = {}; }
            var _this = _super.call(this, data) || this;
            _this._data = null;
            _this._close = false;
            _this._closeSide = true;
            _this._menuActions = [];
            _this._component = null;
            _this._menuRefName = null;
            _this._icon = data.icon || '';
            _this._type = data.type || '';
            _this._name = data.name || '';
            _this._toggle = data.toggle === void 0 ? true : data.toggle;
            _this._tooltip = data.tooltip || '';
            _this._close = !!data.close;
            _this._component = data.component || null;
            _this._data = data.data === void 0 ? {} : data.data;
            if (_this._type === exports.FsDrawerAction.Component) {
                _this._menuRefName = data.name || data.icon;
            }
            if (_this._type === exports.FsDrawerAction.Menu && data.closeSide === void 0) {
                _this._closeSide = false;
            }
            else {
                _this._closeSide = data.closeSide === void 0 ? true : !!data.closeSide;
            }
            if (Array.isArray(data.actions)) {
                _this._menuActions = data.actions.map(function (action) { return new MenuAction(action); });
            }
            return _this;
        }
        Object.defineProperty(Action.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            set: function (value) {
                this._icon = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "toggle", {
            get: function () {
                return this._toggle;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._tooltip = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "close", {
            get: function () {
                return this._close;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "closeSide", {
            get: function () {
                return this._closeSide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "menuActions", {
            get: function () {
                return this._menuActions;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "component", {
            get: function () {
                return this._component;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "data", {
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "menuRefName", {
            get: function () {
                return this._menuRefName;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.updateRouterLink = function (data) {
            if (this._visible) {
                _super.prototype.updateRouterLink.call(this, data);
                if (this._menuActions.length > 0) {
                    this._menuActions.forEach(function (action) {
                        action.updateRouterLink(data);
                    });
                }
            }
        };
        Action.prototype.checkVisibility = function (data) {
            _super.prototype.checkVisibility.call(this, data);
            if (this._menuActions.length > 0) {
                this._menuActions.forEach(function (action) {
                    action.checkVisibility(data);
                });
            }
            if (this.menuActions.length > 0) {
                this._visible = this.menuActions.some(function (action) { return action.visible; });
            }
        };
        return Action;
    }(BaseAction));

    var DrawerConfig = /** @class */ (function () {
        function DrawerConfig(data) {
            if (data === void 0) { data = {}; }
            this.disableClose = data.disableClose || false;
            this.position = data.position || 'right';
            this.activeAction = data.activeAction || '';
            this.resizable = data.resizable === void 0 ? true : data.resizable;
            if (data.width) {
                this.width = data.width;
            }
            this.actions = data.actions && data.actions.map(function (action) { return new Action(action); }) || null;
        }
        return DrawerConfig;
    }());

    var DrawerRef = /** @class */ (function () {
        function DrawerRef(_overlayRef, _dataFactory, _config) {
            this._overlayRef = _overlayRef;
            this._dataFactory = _dataFactory;
            /** Subject for notifying the user that the drawer has finished opening. */
            this._afterOpened$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has finished closing. */
            this._afterClosed$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started closing. */
            this._closeStart$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started opening. */
            this._openStart$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started closing. */
            this._sideToggle = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has finished opening. */
            this._actionsUpdated$ = new rxjs.Subject();
            /** Destroy notifier **/
            this._destroy$ = new rxjs.Subject();
            this._activeAction = new rxjs.BehaviorSubject(void 0);
            this._menuRefs = new Map();
            this._isOpen = false;
            this._isSideOpen = false;
            this.drawerConfig = new DrawerConfig(_config);
            this._activeAction.next(this.drawerConfig.activeAction);
        }
        Object.defineProperty(DrawerRef.prototype, "overlayRef", {
            get: function () {
                return this._overlayRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerData", {
            /**
             * Getter for DRAWER_DATA for current drawer
             */
            get: function () {
                return __assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "destroy$", {
            get: function () {
                return this._destroy$.asObservable();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "containerRef", {
            /**
             * Set reference to drawer container
             * @param value
             */
            set: function (value) {
                this._drawerContainerRef = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "componentRef", {
            /**
             * Set reference to drawer component
             * @param value
             */
            set: function (value) {
                this._drawerComponentRef = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerContentContainer", {
            get: function () {
                return this._drawerContentContainer;
            },
            set: function (value) {
                this._drawerContentContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerActionsContainer", {
            get: function () {
                return this._drawerActionsContainer;
            },
            set: function (value) {
                this._drawerActionsContainer = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "activeAction", {
            get: function () {
                return this._activeAction.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "activeAction$", {
            get: function () {
                return this._activeAction.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "isOpen", {
            /**
             * Return actual status of the drawer
             */
            get: function () {
                return this._isOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "isSideOpen", {
            /**
             * Return actual status of the side of the drawer
             */
            get: function () {
                return this._isSideOpen;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "resizeController", {
            get: function () {
                return this._resizeController;
            },
            set: function (value) {
                this._resizeController = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "actionUpdated$", {
            /**
             * Gets an observable that action was updated and change detection should be started
             */
            get: function () {
                return this._actionsUpdated$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "afterClosed$", {
            /**
             * Gets an observable that is notified when the dialog is finished closing.
             */
            get: function () {
                return this._afterClosed$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "afterOpened$", {
            /**
             * Gets an observable that is notified when the dialog is finished opening.
             */
            get: function () {
                return this._afterOpened$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "openStart$", {
            /**
             * Gets an observable that is notified when the dialog open starts.
             */
            get: function () {
                return this._openStart$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "closeStart$", {
            /**
             * Gets an observable that is notified when the dialog is finished opening.
             */
            get: function () {
                return this._closeStart$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "dataChanged$", {
            /**
             * Gets an observable that is notified when data in DRAWER_DATA was changed
             */
            get: function () {
                return this._dataFactory.dataChange$;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "sideToggle$", {
            /**
             * Gets an observable that is notify that side status toggled
             */
            get: function () {
                return this._sideToggle.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Subscribe on keydown events to react on escape
         */
        DrawerRef.prototype.events = function () {
            var _this = this;
            this._overlayRef.keydownEvents()
                .pipe(operators.filter(function (event) { return event.keyCode === keycodes.ESCAPE && !_this.drawerConfig.disableClose; }), operators.takeUntil(this._destroy$))
                .subscribe(function () { return _this.close(); });
        };
        /**
         * Set value for DRAWER_DATA
         * @param data
         */
        DrawerRef.prototype.dataChange = function (data) {
            this._dataFactory.setValue(data);
        };
        /**
         * Open drawer and notify observable
         */
        DrawerRef.prototype.open = function () {
            var _this = this;
            new rxjs.Observable(function (obs) {
                setTimeout(function () {
                    if (_this._openStart$.observers.length) {
                        _this._openStart$.next(obs);
                    }
                    else {
                        obs.next();
                        obs.complete();
                    }
                });
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    if (_this.activeAction) {
                        _this.openSide();
                    }
                    _this._drawerContainerRef.open();
                    _this._afterOpened$.next();
                    _this._afterOpened$.complete();
                },
                error: function () {
                    _this.destroy();
                },
            });
        };
        /**
         * Close the drawer.
         * @param result Optional result to return to the dialog opener.
         */
        DrawerRef.prototype.close = function (result) {
            var _this = this;
            new rxjs.Observable(function (observer) {
                if (_this._closeStart$.observers.length) {
                    rxjs.zip.apply(void 0, __spread(_this._closeStart$.observers.map(function (item) {
                        return rxjs.Observable.create(function (closeObserver) {
                            item.next(closeObserver);
                        });
                    }))).pipe(operators.takeUntil(_this._destroy$))
                        .subscribe(function () {
                        observer.next();
                        observer.complete();
                    }, function () {
                        observer.error();
                    });
                }
                else {
                    observer.next();
                    observer.complete();
                }
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    _this._drawerContainerRef.close();
                    _this._result = result;
                    _this._afterClosed$.next(result);
                    _this.destroy();
                }
            });
        };
        /**
         * Open the side of the drawer
         */
        DrawerRef.prototype.openSide = function () {
            this._isSideOpen = true;
            this._sideToggle.next(this._isSideOpen);
        };
        /**
         * Close the side of the drawer
         */
        DrawerRef.prototype.closeSide = function () {
            this._isSideOpen = false;
            this._sideToggle.next(this._isSideOpen);
            this.setActiveAction(null);
        };
        /**
         * Toggle the side of the drawer
         */
        DrawerRef.prototype.toggleSide = function () {
            this.isSideOpen ? this.closeSide() : this.openSide();
        };
        /**
         * Change active action
         * @param name
         */
        DrawerRef.prototype.setActiveAction = function (name) {
            this._activeAction.next(name);
            if (name) {
                this.openSide();
            }
        };
        /**
         * Store opened menu reference and subscribe for auto remove
         * @param name
         * @param ref
         */
        DrawerRef.prototype.addMenuRef = function (name, ref) {
            var _this = this;
            this._menuRefs.set(name, ref);
            ref.afterClosed()
                .pipe(operators.take(1), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._menuRefs.delete(name);
            });
        };
        /**
         * Get opened menu reference by name
         * @param name
         */
        DrawerRef.prototype.getMenuRef = function (name) {
            return this._menuRefs.get(name);
        };
        DrawerRef.prototype.getAction = function (name) {
            return this.drawerConfig.actions.find(function (action) { return action.name === name; });
        };
        /**
         * Do update for icon for target action
         * @param name
         * @param icon
         */
        DrawerRef.prototype.updateActionIcon = function (name, icon) {
            var action = this.getAction(name);
            if (action) {
                action.icon = icon;
                this._actionsUpdated$.next(name);
            }
        };
        /**
         * Do update
         * @param name
         * @param data
         */
        DrawerRef.prototype.updateAction = function (name, data) {
            var action = this.getAction(name);
            if (action) {
                var allowedFields_1 = ['icon', 'type', 'toggle', 'tooltip', 'close', 'closeSide', 'component', 'data'];
                var forUpdate = Object.keys(data).filter(function (key) { return allowedFields_1.indexOf(key) > -1; });
                forUpdate.forEach(function (key) {
                    action[key] = data[key];
                });
                this._actionsUpdated$.next(name);
            }
        };
        DrawerRef.prototype.updateDrawerWidth = function (width) {
            this.resizeController.updateMainWidth(width);
        };
        DrawerRef.prototype.updateSideDrawerWidth = function (width) {
            this.resizeController.updateSideWidth(width);
        };
        DrawerRef.prototype.destroy = function () {
            this._overlayRef.detachBackdrop();
            this._overlayRef.detach();
            this._drawerComponentRef.destroy();
            this._dataFactory.destroy();
            this._destroy$.next();
            this._destroy$.complete();
        };
        return DrawerRef;
    }());

    var FsDrawerMenuComponent = /** @class */ (function (_super) {
        __extends(FsDrawerMenuComponent, _super);
        function FsDrawerMenuComponent() {
            return _super.call(this) || this;
        }
        FsDrawerMenuComponent.prototype.setDrawerMenuRef = function (value) {
            this.ref = value;
            // this.config = this.externalMenuRef.config;
        };
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerMenuComponent.prototype.attachComponentPortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer component already attached');
            }
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerMenuComponent.prototype.attachTemplatePortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer template already attached');
            }
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        __decorate([
            core.ViewChild(portal.CdkPortalOutlet, { static: true }),
            __metadata("design:type", portal.CdkPortalOutlet)
        ], FsDrawerMenuComponent.prototype, "_portalOutlet", void 0);
        FsDrawerMenuComponent = __decorate([
            core.Component({
                selector: 'fs-drawer-menu',
                template: "<ng-template cdkPortalOutlet></ng-template>\n",
                host: {
                    'class': 'mat-elevation-z2'
                },
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [":host{padding:15px;background:#fff;border-radius:2px;overflow:auto}"]
            }),
            __metadata("design:paramtypes", [])
        ], FsDrawerMenuComponent);
        return FsDrawerMenuComponent;
    }(portal.BasePortalOutlet));

    var DrawerMenuRef = /** @class */ (function () {
        function DrawerMenuRef(_overlayRef, _dataFactory) {
            var _this = this;
            this._overlayRef = _overlayRef;
            this._dataFactory = _dataFactory;
            /** Subject for notifying the user that the menu has finished closing. */
            this._afterClosed$ = new rxjs.Subject();
            /** Subject for notifying the user that the menu has started closing. */
            this._closeStart$ = new rxjs.Subject();
            /** Destroy notifier **/
            this._destroy$ = new rxjs.Subject();
            this._overlayRef.backdropClick()
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this.close();
            });
        }
        Object.defineProperty(DrawerMenuRef.prototype, "menuData", {
            /**
             * Getter for DRAWER_MENU_DATA for current drawer
             */
            get: function () {
                return __assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "containerRef", {
            /**
             * Set reference to menu container
             * @param value
             */
            set: function (value) {
                this._externalMenuContainerRef = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "componentRef", {
            /**
             * Set reference to menu component
             * @param value
             */
            set: function (value) {
                this._externalMenuComponentRef = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "dataChanged$", {
            /**
             * Gets an observable that is notified when data in DRAWER_DATA was changed
             */
            get: function () {
                return this._dataFactory.dataChange$;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set value for DRAWER_DATA
         * @param data
         */
        DrawerMenuRef.prototype.dataChange = function (data) {
            this._dataFactory.setValue(data);
        };
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        DrawerMenuRef.prototype.afterClosed = function () {
            return this._afterClosed$.pipe(operators.takeUntil(this._destroy$));
        };
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        DrawerMenuRef.prototype.closeStart = function () {
            return this._closeStart$.pipe(operators.takeUntil(this._destroy$));
        };
        /**
         * Close the menu.
         * @param result Optional result to return to the dialog opener.
         */
        DrawerMenuRef.prototype.close = function (result) {
            var _this = this;
            new rxjs.Observable(function (observer) {
                if (_this._closeStart$.observers.length) {
                    rxjs.zip.apply(void 0, __spread(_this._closeStart$.observers.map(function (item) {
                        return rxjs.Observable.create(function (closeObserver) {
                            item.next(closeObserver);
                        });
                    }))).pipe(operators.takeUntil(_this._destroy$))
                        .subscribe(function () {
                        observer.next();
                        observer.complete();
                    }, function () {
                        observer.error();
                    });
                }
                else {
                    observer.next();
                    observer.complete();
                }
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    _this._result = result;
                    _this._afterClosed$.next(result);
                    _this.destroy();
                }
            });
        };
        DrawerMenuRef.prototype.destroy = function () {
            this._overlayRef.detachBackdrop();
            this._overlayRef.detach();
            this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
            this._dataFactory.destroy();
            this._destroy$.next();
            this._destroy$.complete();
        };
        return DrawerMenuRef;
    }());

    var DrawerData = /** @class */ (function () {
        function DrawerData(data) {
            if (data === void 0) { data = {}; }
            this._dataChange = new rxjs.Subject();
            this._destroy = new rxjs.Subject();
            this._data = data;
        }
        DrawerData.createWithProxy = function (data) {
            if (data === void 0) { data = {}; }
            var drawerData = new DrawerData(data);
            return new Proxy(drawerData, {
                get: function (target, property) {
                    if (typeof target[property] === 'function'
                        || property === '_data'
                        || target[property] instanceof rxjs.Observable) {
                        return target[property];
                    }
                    else {
                        return target._data[property];
                    }
                },
                set: function (target, property, value) {
                    if (property !== '_data') {
                        target._data[property] = value;
                    }
                    else {
                        target[property] = value;
                    }
                    return true;
                },
                has: function (target, property) {
                    return property in target._data;
                },
                ownKeys: function (target) {
                    return Object.keys(target._data);
                },
                enumerate: function (target) {
                    return Object.keys(target._data);
                },
                getOwnPropertyDescriptor: function (target, property) {
                    return Object.getOwnPropertyDescriptor(target._data, property);
                }
            });
        };
        Object.defineProperty(DrawerData.prototype, "dataChange$", {
            get: function () {
                return this._dataChange.pipe(operators.takeUntil(this._destroy));
            },
            enumerable: true,
            configurable: true
        });
        DrawerData.prototype.getValue = function () {
            return this._data;
        };
        DrawerData.prototype.setValue = function (value) {
            this._data = value;
            this._dataChange.next(this._data);
        };
        DrawerData.prototype.destroy = function () {
            this._destroy.next();
            this._destroy.complete();
        };
        return DrawerData;
    }());

    /** Injection token that can be used to access the data that was passed in to a drawer. */
    var DRAWER_MENU_DATA = new core.InjectionToken('fs.drawer.menu-data');

    var FsDrawerMenuService = /** @class */ (function () {
        function FsDrawerMenuService(_overlay, _injector, _breakpointObserver) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._breakpointObserver = _breakpointObserver;
        }
        FsDrawerMenuService.prototype.create = function (component, container, config) {
            var overlayRef = this.createOverlay(container);
            var dataFactory = DrawerData.createWithProxy(config.data);
            var menuRef = new DrawerMenuRef(overlayRef, dataFactory);
            var containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
            var componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
            menuRef.containerRef = containerRef;
            containerRef.setDrawerMenuRef(menuRef);
            menuRef.componentRef = componentRef;
            return menuRef;
        };
        FsDrawerMenuService.prototype.createOverlay = function (container) {
            var overlayConfig = this.getOverlayConfig(container);
            return this._overlay.create(overlayConfig);
        };
        FsDrawerMenuService.prototype.getOverlayConfig = function (container) {
            var element = new core.ElementRef(container); // positionStrategy needs ElementRef;
            var strategy = null;
            if (this._breakpointObserver.isMatched(layout.Breakpoints.XSmall)) {
                strategy = this._overlay
                    .position()
                    .global()
                    .centerHorizontally()
                    .centerVertically();
            }
            else {
                var positions = [
                    { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
                ];
                strategy = this._overlay
                    .position()
                    .flexibleConnectedTo(element)
                    .withPositions(positions);
            }
            return new overlay.OverlayConfig({
                positionStrategy: strategy,
                scrollStrategy: this._overlay.scrollStrategies.reposition(),
                hasBackdrop: true,
                backdropClass: 'cdk-overlay-transparent-backdrop'
            });
        };
        FsDrawerMenuService.prototype.attachContainer = function (overlayRef, menuRef, dataFactory) {
            var injector = this.createInjector(menuRef, dataFactory);
            var containerPortal = new portal.ComponentPortal(FsDrawerMenuComponent, undefined, injector);
            var containerRef = overlayRef.attach(containerPortal);
            return containerRef.instance;
        };
        FsDrawerMenuService.prototype.attachComponent = function (componentRef, externalContainer, externalRef, config) {
            var injector = this.createInjector(externalRef, config);
            return externalContainer.attachComponentPortal(new portal.ComponentPortal(componentRef, undefined, injector));
        };
        FsDrawerMenuService.prototype.createInjector = function (componentRef, dataFactory) {
            var injectionTokens = new WeakMap([
                [DrawerMenuRef, componentRef],
                [DRAWER_MENU_DATA, dataFactory]
            ]);
            return new portal.PortalInjector(this._injector, injectionTokens);
        };
        FsDrawerMenuService.ctorParameters = function () { return [
            { type: overlay.Overlay },
            { type: core.Injector },
            { type: layout.BreakpointObserver }
        ]; };
        FsDrawerMenuService = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [overlay.Overlay,
                core.Injector,
                layout.BreakpointObserver])
        ], FsDrawerMenuService);
        return FsDrawerMenuService;
    }());

    var FsDrawerActionsComponent = /** @class */ (function () {
        function FsDrawerActionsComponent(_drawerRef, _drawerMenu, _cdRef) {
            this._drawerRef = _drawerRef;
            this._drawerMenu = _drawerMenu;
            this._cdRef = _cdRef;
            this._destroy$ = new rxjs.Subject();
        }
        FsDrawerActionsComponent.prototype.ngOnInit = function () {
        };
        FsDrawerActionsComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerActionsComponent.prototype.actionClick = function (action, event) {
            var hasComponentType = action.type === exports.FsDrawerAction.Component;
            var hasMenuType = action.type === exports.FsDrawerAction.Menu;
            if (hasComponentType) {
                var menuRef = this._drawerMenu.create(action.component, event.srcElement, action);
                this._drawerRef.addMenuRef(action.menuRefName, menuRef);
                var params = {
                    event: event,
                    action: action,
                    drawerRef: this._drawerRef,
                    menuRef: menuRef
                };
                // Call click
                action.click.call(null, params);
                if (action.closeSide) {
                    this._drawerRef.closeSide();
                }
            }
            else if (action.click) {
                var params = { event: event, action: action };
                action.click.call(null, params);
            }
            if (action.close) {
                this._drawerRef.close();
            }
            if (action.toggle && ((!hasComponentType && !hasMenuType) || action.closeSide)) {
                if (this._drawerRef.isSideOpen && this._drawerRef.activeAction === action.name) {
                    this._drawerRef.toggleSide();
                }
                else {
                    this._drawerRef.setActiveAction(action.name);
                }
            }
        };
        FsDrawerActionsComponent.ctorParameters = function () { return [
            { type: DrawerRef },
            { type: FsDrawerMenuService },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Array)
        ], FsDrawerActionsComponent.prototype, "actions", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FsDrawerActionsComponent.prototype, "activeAction", void 0);
        FsDrawerActionsComponent = __decorate([
            core.Component({
                selector: 'fs-drawer-actions',
                template: "<div class=\"actions-container\">\n  <div *ngFor=\"let action of actions\" class=\"action-btn\">\n    <fs-drawer-action-item [action]=\"action\"\n                           [activeAction]=\"activeAction\"\n                           (actionClicked)=\"actionClick(action, $event)\">\n    </fs-drawer-action-item>\n  </div>\n</div>\n\n<div class=\"drag-icon\">\n  <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n</div>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex}.actions-container{flex:0}.drag-icon{display:flex;flex:1;align-items:center}"]
            }),
            __metadata("design:paramtypes", [DrawerRef,
                FsDrawerMenuService,
                core.ChangeDetectorRef])
        ], FsDrawerActionsComponent);
        return FsDrawerActionsComponent;
    }());

    var MAIN_DRAWER_DEFAULT_WIDTH = 500;
    var SIDE_DRAWER_DEFAULT_WIDTH = 200;
    var SIDE_RESIZE_BAR_WIDTH = 25;
    var MAIN_RESIZE_ACTION_BAR_WIDTH = 40;
    var DrawerSizeController = /** @class */ (function () {
        function DrawerSizeController(_drawerRef, _ngZone) {
            this._drawerRef = _drawerRef;
            this._ngZone = _ngZone;
            this._sideOpened = false;
            this._borderPadding = 0;
            this._destroy$ = new rxjs.Subject();
            this._initDefaultConfigs();
            this._updateScreenWidth();
            this._listenWindowResize();
            this._listenSideToggle();
        }
        Object.defineProperty(DrawerSizeController.prototype, "mainElRef", {
            get: function () {
                return this._mainElRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "sideElRef", {
            get: function () {
                return this._sideElRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "mainConfig", {
            get: function () {
                return this._mainConfig;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "sideConfig", {
            get: function () {
                return this._sideConfig;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "screenWidth", {
            get: function () {
                return this._screenWidth;
            },
            enumerable: true,
            configurable: true
        });
        DrawerSizeController.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        DrawerSizeController.prototype.registerElRef = function (el) {
            if (el.type === 'main') {
                this._registerMainRef(el);
            }
            else if (el.type === 'side') {
                this._registerSideRef(el);
            }
            else {
                throw Error('Unrecognized resize element type');
            }
        };
        DrawerSizeController.prototype.getInitialWidth = function (type) {
            if (type === 'main') {
                return this.mainConfig.initial;
            }
            else if (type === 'side') {
                return this.sideConfig.initial;
            }
            else {
                return void 0;
            }
        };
        DrawerSizeController.prototype.getMinWidth = function (type) {
            if (type === 'main') {
                return this.mainConfig.min;
            }
            else if (type === 'side') {
                return this.sideConfig.min;
            }
            else {
                return void 0;
            }
        };
        DrawerSizeController.prototype.getMaxWidth = function (type) {
            if (type === 'main') {
                return this.mainConfig.max;
            }
            else if (type === 'side') {
                return this.sideConfig.max;
            }
            else {
                return void 0;
            }
        };
        /**
         * Update width from outside with all calculations to be done
         * @param width
         */
        DrawerSizeController.prototype.updateMainWidth = function (width) {
            var sideWidth = (this.sideElRef && this.sideElRef.width) || 0;
            this.mainElRef.updateWidth(sideWidth + width);
        };
        /**
         * Update width from outside with all calculations to be done
         * @param width
         */
        DrawerSizeController.prototype.updateSideWidth = function (width) {
            if (this.sideElRef) {
                var currentWidth = this.mainElRef.width - this.sideElRef.width;
                this.mainElRef.updateWidth(currentWidth + width);
                this.sideElRef.updateWidth(width);
            }
        };
        /**
         * Push current drawer to be visible under new one opened
         * @param inFrontDrawer
         */
        DrawerSizeController.prototype.pushMainWidth = function (inFrontDrawer) {
            var inFrontDrawerTotalWidth = inFrontDrawer.resizeController.mainElRef.width + MAIN_RESIZE_ACTION_BAR_WIDTH;
            if (this.mainElRef.width <= inFrontDrawerTotalWidth) {
                this.updateMainWidth(inFrontDrawerTotalWidth);
            }
        };
        /**
         * Listen for browser resize and update restrictions
         */
        DrawerSizeController.prototype._listenWindowResize = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                rxjs.fromEvent(window, 'resize')
                    .pipe(operators.debounceTime(50), operators.takeUntil(_this._destroy$))
                    .subscribe(function () {
                    _this._updateScreenWidth();
                    _this._updateMinMaxStyles();
                });
            });
        };
        /**
         * Copy initial configs or set default values
         */
        DrawerSizeController.prototype._initDefaultConfigs = function () {
            this._mainConfig =
                (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.main)
                    || {};
            this._mainConfig.initial = this._mainConfig.initial || MAIN_DRAWER_DEFAULT_WIDTH;
            this._sideConfig =
                (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.side)
                    || {};
            this._sideConfig.initial = this._sideConfig.initial || SIDE_DRAWER_DEFAULT_WIDTH;
        };
        DrawerSizeController.prototype._registerMainRef = function (el) {
            this._mainElRef = el;
        };
        DrawerSizeController.prototype._registerSideRef = function (el) {
            this._sideElRef = el;
        };
        /**
         * Update current window size
         */
        DrawerSizeController.prototype._updateScreenWidth = function () {
            this._screenWidth = (window.innerWidth - this._borderPadding);
        };
        /**
         * Update min&max css props for containers
         */
        DrawerSizeController.prototype._updateMinMaxStyles = function () {
            this.mainElRef.setMinMaxStyles();
            if (this.sideElRef) {
                this.sideElRef.setMinMaxStyles();
            }
        };
        DrawerSizeController.prototype._listenSideToggle = function () {
            var _this = this;
            this._drawerRef.sideToggle$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (opened) {
                if (_this._sideOpened === opened) {
                    return;
                }
                _this._sideOpened = opened;
                if (opened) {
                    var currentWidth = _this.mainElRef.width;
                    var sideWidth = _this.getInitialWidth('side');
                    _this._mainElRef.updateWidth(currentWidth + sideWidth + SIDE_RESIZE_BAR_WIDTH);
                }
                else {
                    var actualSideWidth = _this.sideElRef.fsDrawerResizer.getBoundingClientRect().width;
                    var mainWidth = _this.mainElRef.width - actualSideWidth - SIDE_RESIZE_BAR_WIDTH;
                    _this._mainElRef.updateWidth(mainWidth);
                }
            });
        };
        DrawerSizeController.ctorParameters = function () { return [
            { type: DrawerRef },
            { type: core.NgZone }
        ]; };
        DrawerSizeController = __decorate([
            core.Injectable(),
            __metadata("design:paramtypes", [DrawerRef,
                core.NgZone])
        ], DrawerSizeController);
        return DrawerSizeController;
    }());

    var FsDrawerComponent = /** @class */ (function (_super) {
        __extends(FsDrawerComponent, _super);
        function FsDrawerComponent(_el, _drawerMenu, _drawerRef, _cdRef, _resizeController) {
            var _this = _super.call(this) || this;
            _this._el = _el;
            _this._drawerMenu = _drawerMenu;
            _this._drawerRef = _drawerRef;
            _this._cdRef = _cdRef;
            _this._resizeController = _resizeController;
            _this.isOpen = false;
            _this.isOpenSide = false;
            _this.initialized = false;
            _this._sideOpen = false;
            _this._destroy$ = new rxjs.Subject();
            _this._drawerRef.resizeController = _this._resizeController;
            return _this;
        }
        Object.defineProperty(FsDrawerComponent.prototype, "sideOpen", {
            get: function () {
                return this._sideOpen;
            },
            set: function (value) {
                this._sideOpen = value;
                this._el.nativeElement.classList
                    .toggle('side-open', this.sideOpen);
            },
            enumerable: true,
            configurable: true
        });
        FsDrawerComponent.prototype.ngOnInit = function () {
            this._listenDataChanges();
        };
        FsDrawerComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerComponent.prototype.open = function () {
            this.isOpen = true;
        };
        FsDrawerComponent.prototype.close = function () {
            this.isOpen = false;
        };
        FsDrawerComponent.prototype.openSide = function () {
            this.isOpenSide = true;
        };
        FsDrawerComponent.prototype.closeSide = function () {
            this.isOpenSide = false;
        };
        FsDrawerComponent.prototype.setDrawerRef = function (value) {
            var _this = this;
            this.drawerRef = value;
            this.config = this.drawerRef.drawerConfig;
            // Need to be like a parent for children resize
            this.drawerRef.drawerContentContainer = this._drawerContentContainer;
            this.drawerRef.drawerActionsContainer = this._drawerActionsContainer;
            this.drawerRef.sideToggle$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (opened) {
                _this.sideOpen = opened;
            });
            this.initialized = true;
        };
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerComponent.prototype.attachComponentPortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer component already attached');
            }
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerComponent.prototype.attachTemplatePortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer template already attached');
            }
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        FsDrawerComponent.prototype._listenDataChanges = function () {
            var _this = this;
            this._drawerRef.dataChanged$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._cdRef.detectChanges();
            });
        };
        FsDrawerComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: FsDrawerMenuService },
            { type: DrawerRef },
            { type: core.ChangeDetectorRef },
            { type: DrawerSizeController }
        ]; };
        __decorate([
            core.ViewChild(portal.CdkPortalOutlet, { static: true }),
            __metadata("design:type", portal.CdkPortalOutlet)
        ], FsDrawerComponent.prototype, "_portalOutlet", void 0);
        __decorate([
            core.ViewChild('drawerContentContainer', { static: true }),
            __metadata("design:type", core.ElementRef)
        ], FsDrawerComponent.prototype, "_drawerContentContainer", void 0);
        __decorate([
            core.ViewChild('drawerActionsContainer', { read: core.ElementRef, static: true }),
            __metadata("design:type", core.ElementRef)
        ], FsDrawerComponent.prototype, "_drawerActionsContainer", void 0);
        FsDrawerComponent = __decorate([
            core.Component({
                selector: 'fs-drawer',
                template: "<div class=\"mat-elevation-z2 drawer\" #drawer\n     hidden\n     [ngClass]=\"config.position\"\n     [hidden]=\"!initialized\">\n  <ng-container>\n    <fs-drawer-actions class=\"drawer-actions\"\n                       #drawerActionsContainer\n                       type=\"main\"\n                       [fsDrawerResizer]=\"drawer\"\n                       [resizable]=\"drawerRef.drawerConfig.resizable\"\n                       [sizeController]=\"drawerRef.resizeController\"\n                       [direction]=\"config.position\"\n                       [actions]=\"config.actions\"\n                       [activeAction]=\"drawerRef.activeAction$ | async\">\n    </fs-drawer-actions>\n    <div class=\"drawer-container\" #drawerContentContainer>\n      <ng-template cdkPortalOutlet></ng-template>\n    </div>\n  </ng-container>\n</div>\n",
                providers: [
                    FsDrawerMenuService,
                    DrawerSizeController,
                ],
                host: {
                    'class': 'fs-drawer-container',
                },
                encapsulation: core.ViewEncapsulation.None,
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                FsDrawerMenuService,
                DrawerRef,
                core.ChangeDetectorRef,
                DrawerSizeController])
        ], FsDrawerComponent);
        return FsDrawerComponent;
    }(portal.BasePortalOutlet));

    var FsDrawerActionDirective = /** @class */ (function () {
        function FsDrawerActionDirective() {
        }
        __decorate([
            core.Input('fsDrawerAction'),
            __metadata("design:type", String)
        ], FsDrawerActionDirective.prototype, "name", void 0);
        FsDrawerActionDirective = __decorate([
            core.Directive({
                selector: '[fsDrawerAction]',
            })
        ], FsDrawerActionDirective);
        return FsDrawerActionDirective;
    }());

    var FsDrawerSideComponent = /** @class */ (function () {
        function FsDrawerSideComponent(_cdRef, _renderer, _elRef) {
            this._cdRef = _cdRef;
            this._renderer = _renderer;
            this._elRef = _elRef;
            this.classSide = true;
            this.activeTemplate = null;
            this._hidden = false;
            this._destroy$ = new core.EventEmitter();
        }
        Object.defineProperty(FsDrawerSideComponent.prototype, "hidden", {
            set: function (value) {
                this._hidden = value;
                if (this._hidden) {
                    this._renderer.setAttribute(this._elRef.nativeElement, 'hidden', 'true');
                }
                else {
                    this._renderer.removeAttribute(this._elRef.nativeElement, 'hidden');
                }
            },
            enumerable: true,
            configurable: true
        });
        FsDrawerSideComponent.prototype.ngOnInit = function () {
            this.hidden = true;
            if (!this.drawer) {
                console.error('Drawer reference is null for @Input("fsDrawerSide")');
            }
            this._subscribeToActionChanges();
        };
        FsDrawerSideComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () {
                // Check current side status
                if (_this.drawer) {
                    _this.hidden = !_this.drawer.isSideOpen;
                }
                _this._updateActiveActionTemplate();
            });
        };
        FsDrawerSideComponent.prototype.ngOnDestroy = function () {
            this._destroy$.emit();
            this._destroy$.complete();
        };
        FsDrawerSideComponent.prototype._subscribeToActionChanges = function () {
            var _this = this;
            if (this.drawer) {
                this.drawer.sideToggle$
                    .pipe(operators.takeUntil(this._destroy$))
                    .subscribe(function () {
                    _this.hidden = !_this.drawer.isSideOpen;
                    _this._updateActiveActionTemplate();
                    _this._cdRef.detectChanges();
                });
            }
        };
        FsDrawerSideComponent.prototype._updateActiveActionTemplate = function () {
            if (this.drawer) {
                var activatedAction_1 = this.drawer.activeAction;
                if (this.drawer.isSideOpen && activatedAction_1) {
                    var selectedActionIndex = this.actions
                        .toArray()
                        .findIndex(function (action) { return action.name === activatedAction_1; });
                    this.activeTemplate = this.actionsTemplates.toArray()[selectedActionIndex];
                }
                else {
                    this.activeTemplate = null;
                }
            }
        };
        FsDrawerSideComponent.ctorParameters = function () { return [
            { type: core.ChangeDetectorRef },
            { type: core.Renderer2 },
            { type: core.ElementRef }
        ]; };
        __decorate([
            core.Input('fsDrawerSide'),
            __metadata("design:type", DrawerRef)
        ], FsDrawerSideComponent.prototype, "drawer", void 0);
        __decorate([
            core.HostBinding('class.side'),
            __metadata("design:type", Object)
        ], FsDrawerSideComponent.prototype, "classSide", void 0);
        __decorate([
            core.ContentChildren(FsDrawerActionDirective),
            __metadata("design:type", core.QueryList)
        ], FsDrawerSideComponent.prototype, "actions", void 0);
        __decorate([
            core.ContentChildren(FsDrawerActionDirective, { read: core.TemplateRef }),
            __metadata("design:type", core.QueryList)
        ], FsDrawerSideComponent.prototype, "actionsTemplates", void 0);
        FsDrawerSideComponent = __decorate([
            core.Component({
                selector: '[fsDrawerSide]',
                template: "<ng-container [ngSwitch]=\"drawer.drawerConfig.position\" *ngIf=\"activeTemplate\">\n  <ng-container *ngSwitchCase=\"'right'\">\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"left\"\n         type=\"side\"\n         [fsDrawerResizer]=\"sideContainer\"\n         [resizable]=\"drawer.drawerConfig.resizable\"\n         [sizeController]=\"drawer.resizeController\"\n         [parentContainer]=\"drawer.drawerContentContainer\"\n         [actionsContainer]=\"drawer.drawerActionsContainer\"\n    >\n      <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'left'\">\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"right\"\n         [fsDrawerResizer]=\"sideContainer\"\n    >\n    <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                styles: [".resize-icon{width:24px;height:24px;line-height:24px}.resize-icon span{width:24px}"]
            }),
            __metadata("design:paramtypes", [core.ChangeDetectorRef,
                core.Renderer2,
                core.ElementRef])
        ], FsDrawerSideComponent);
        return FsDrawerSideComponent;
    }());

    var FsDrawerActionItemComponent = /** @class */ (function () {
        function FsDrawerActionItemComponent(drawer, _cdRef) {
            this.drawer = drawer;
            this._cdRef = _cdRef;
            this.actionClicked = new core.EventEmitter();
            this.isActive = false;
            this.actionTypes = exports.FsDrawerAction;
            this._destroy$ = new rxjs.Subject();
            this._listenActionChanges();
            this._listenDataChanges();
        }
        FsDrawerActionItemComponent.prototype.ngOnInit = function () {
            this._updateVisibilityAndLinks();
        };
        FsDrawerActionItemComponent.prototype.ngOnChanges = function (changes) {
            if (changes.activeAction) {
                this.isActive = this.action.name !== '' && this.action.name === this.activeAction;
            }
        };
        FsDrawerActionItemComponent.prototype.actionClick = function (event) {
            this.actionClicked.emit(event);
        };
        FsDrawerActionItemComponent.prototype.menuActionClick = function (action, event) {
            if (action.click) {
                action.click.call(null, {
                    data: this.drawer.drawerData,
                    event: event,
                    drawerRef: this.drawer,
                    action: action
                });
            }
        };
        FsDrawerActionItemComponent.prototype._listenActionChanges = function () {
            var _this = this;
            this.drawer.actionUpdated$
                .pipe(operators.filter(function (name) { return name === _this.action.name; }), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._cdRef.detectChanges();
            });
        };
        FsDrawerActionItemComponent.prototype._listenDataChanges = function () {
            var _this = this;
            this.drawer.dataChanged$
                .pipe(operators.takeUntil(this._destroy$), operators.debounceTime(50))
                .subscribe(function () {
                _this._updateVisibilityAndLinks();
            });
        };
        FsDrawerActionItemComponent.prototype._updateVisibilityAndLinks = function () {
            this._updateVisibility();
            this._updateRouterLinks();
            this._cdRef.detectChanges();
        };
        FsDrawerActionItemComponent.prototype._updateVisibility = function () {
            this.action.checkVisibility(this.drawer.drawerData);
        };
        FsDrawerActionItemComponent.prototype._updateRouterLinks = function () {
            if (this.action.type === this.actionTypes.Menu) {
                this.action.updateRouterLink({
                    data: this.drawer.drawerData,
                    drawerRef: this.drawer
                });
            }
        };
        FsDrawerActionItemComponent.ctorParameters = function () { return [
            { type: DrawerRef },
            { type: core.ChangeDetectorRef }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Action)
        ], FsDrawerActionItemComponent.prototype, "action", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FsDrawerActionItemComponent.prototype, "activeAction", void 0);
        __decorate([
            core.Output(),
            __metadata("design:type", Object)
        ], FsDrawerActionItemComponent.prototype, "actionClicked", void 0);
        FsDrawerActionItemComponent = __decorate([
            core.Component({
                selector: 'fs-drawer-action-item',
                template: "<ng-container [ngSwitch]=\"action.type\">\n  <ng-container *ngSwitchCase=\"actionTypes.Button\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Menu\">\n    <ng-container *ngIf=\"action.visible\">\n      <button mat-icon-button\n              type=\"button\"\n              class=\"sub-action\"\n              [fsMenuTriggerFor]=\"menu\"\n              [matTooltip]=\"action.tooltip\"\n              [class.active]=\"isActive\"\n              (click)=\"actionClick($event)\">\n        <i class=\"material-icons\">{{action.icon}}</i>\n      </button>\n\n      <fs-menu #menu>\n        <ng-container *ngFor=\"let menuAction of action.menuActions\">\n          <ng-container *ngIf=\"menuAction.isGroup else simpleMenuItem\">\n            <fs-menu-group [label]=\"menuAction.label\" [hidden]=\"!menuAction.visible\">\n              <ng-container *ngFor=\"let groupAction of menuAction.actions\">\n                <ng-template fs-menu-item\n                             [hidden]=\"!groupAction.visible\"\n                             [link]=\"groupAction.routerLink?.link\"\n                             [queryParams]=\"groupAction.routerLink?.queryParams\"\n                             (click)=\"menuActionClick(groupAction, $event);\">\n                  <mat-icon *ngIf=\"menuAction.icon\">{{groupAction.icon}}</mat-icon>\n                  {{groupAction.label}}\n                </ng-template>\n              </ng-container>\n            </fs-menu-group>\n          </ng-container>\n          <ng-template #simpleMenuItem>\n            <ng-template fs-menu-item\n                         [hidden]=\"!menuAction.visible\"\n                         [link]=\"menuAction.routerLink?.link\"\n                         [queryParams]=\"menuAction.routerLink?.queryParams\"\n                         (click)=\"menuActionClick(menuAction, $event);\">\n              <i class=\"material-icons\" *ngIf=\"menuAction.icon\">{{menuAction.icon}}</i>\n              <span>{{menuAction.label}}</span>\n            </ng-template>\n          </ng-template>\n        </ng-container>\n      </fs-menu>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Component\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n</ng-container>\n",
                changeDetection: core.ChangeDetectionStrategy.OnPush
            }),
            __metadata("design:paramtypes", [DrawerRef,
                core.ChangeDetectorRef])
        ], FsDrawerActionItemComponent);
        return FsDrawerActionItemComponent;
    }());

    var FsDrawerContentComponent = /** @class */ (function () {
        function FsDrawerContentComponent() {
        }
        FsDrawerContentComponent = __decorate([
            core.Component({
                selector: '[fsDrawerContent]',
                template: '<div class="content"><ng-content></ng-content></div>',
                host: {
                    'class': 'content-container'
                }
            })
        ], FsDrawerContentComponent);
        return FsDrawerContentComponent;
    }());

    var FsDrawerResizerDirective = /** @class */ (function () {
        function FsDrawerResizerDirective(_el, _renderer, _ngZone) {
            this._el = _el;
            this._renderer = _renderer;
            this._ngZone = _ngZone;
            this.fsDrawerResizer = this._el.nativeElement;
            this.direction = 'left';
            this.resizable = true;
            this._dragStartHandler = this._dragStart.bind(this);
            this._dragHandler = this._drag.bind(this);
            this._dragEndHandler = this._dragEnd.bind(this);
            this._x = 0;
            this._width = 0;
            this._actionsWidth = 0;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(FsDrawerResizerDirective.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "minWidth", {
            get: function () {
                var minWidth = this.sizeController.getMinWidth(this.type);
                if (minWidth && minWidth >= 0) {
                    if (minWidth > this.sizeController.screenWidth) {
                        return this.sizeController.screenWidth;
                    }
                    else {
                        return minWidth;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "maxWidth", {
            get: function () {
                var maxWidth = this.sizeController.getMaxWidth(this.type);
                var parentContainerWidth = null;
                if (this.parentContainer) {
                    parentContainerWidth = this._getElementWidth(this.parentContainer.nativeElement);
                }
                if (parentContainerWidth !== null) {
                    return !maxWidth || maxWidth >= parentContainerWidth
                        ? parentContainerWidth - this._actionsWidth * 2
                        : maxWidth;
                }
                else {
                    return !maxWidth || maxWidth >= this.sizeController.screenWidth
                        ? this.sizeController.screenWidth
                        : maxWidth;
                }
            },
            enumerable: true,
            configurable: true
        });
        FsDrawerResizerDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.sizeController.registerElRef(this);
            if (this.resizable) {
                this._ngZone.runOutsideAngular(function () {
                    _this._el.nativeElement.addEventListener('mousedown', _this._dragStartHandler, false);
                    _this._el.nativeElement.addEventListener('touchstart', _this._dragStartHandler, false);
                });
                if (this.actionsContainer) {
                    this._actionsWidth = this._getElementWidth(this.actionsContainer.nativeElement);
                }
                this.setMinMaxStyles();
                var minWidth = this.sizeController.getMinWidth(this.type);
                var width = this.sizeController.getInitialWidth(this.type)
                    || this._getElementWidth(this.fsDrawerResizer);
                if (width < minWidth) {
                    width = minWidth;
                }
                this.updateWidth(width);
            }
        };
        FsDrawerResizerDirective.prototype.updateWidth = function (width) {
            var _this = this;
            this._width = width;
            requestAnimationFrame(function () {
                _this._renderer.setStyle(_this.fsDrawerResizer, 'width', width + "px");
            });
        };
        FsDrawerResizerDirective.prototype.ngOnDestroy = function () {
            this._el.nativeElement.removeEventListener('mousedown', this._dragStartHandler, false);
            this._el.nativeElement.removeEventListener('touchstart', this._dragStartHandler, false);
            this._destroy$.next();
            this._destroy$.complete();
        };
        /**
         * Set inline styles min/max width
         */
        FsDrawerResizerDirective.prototype.setMinMaxStyles = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this._renderer.setStyle(_this.fsDrawerResizer, 'min-width', _this.minWidth + "px");
                _this._renderer.setStyle(_this.fsDrawerResizer, 'max-width', _this.maxWidth + "px");
            });
        };
        /**
         * Subscribe to move events and init base dimensions/restrictions
         * @param event { MouseEvent }
         */
        FsDrawerResizerDirective.prototype._dragStart = function (event) {
            this._x = this._getClientX(event);
            this._width = this._getElementWidth(this.fsDrawerResizer);
            this.setMinMaxStyles();
            document.addEventListener('touchmove', this._dragHandler, false);
            document.addEventListener('touchend', this._dragEndHandler, false);
            document.addEventListener('mousemove', this._dragHandler, false);
            document.addEventListener('mouseup', this._dragEndHandler, false);
        };
        /**
         * Update coordinates during drag
         * @param event
         */
        FsDrawerResizerDirective.prototype._drag = function (event) {
            var clientX = this._getClientX(event);
            var predictedWidth = this._calcWidth(this.direction, clientX);
            this._updatePosition(clientX, predictedWidth);
            this._emitResizeEvent();
        };
        /**
         * Remove listeners when drag finished
         * @param event
         */
        FsDrawerResizerDirective.prototype._dragEnd = function (event) {
            document.removeEventListener('mousemove', this._dragHandler, false);
            document.removeEventListener('mouseup', this._dragEndHandler, false);
            document.removeEventListener('touchmove', this._dragHandler, false);
            document.removeEventListener('touchend', this._dragEndHandler, false);
        };
        /**
         *
         * @param event
         */
        FsDrawerResizerDirective.prototype._getClientX = function (event) {
            return event.touches ? event.touches[0].clientX : event.clientX;
        };
        /**
         * Will return width of element
         * @param el
         */
        FsDrawerResizerDirective.prototype._getElementWidth = function (el) {
            return el.getBoundingClientRect().width;
        };
        /**
         * Update width and position of target element
         * @param clientX
         * @param width
         */
        FsDrawerResizerDirective.prototype._updatePosition = function (clientX, width) {
            this._x = clientX;
            this.updateWidth(width < 0 ? 0 : width);
        };
        /**
         * Calc new width based on offset from previous position
         * @param direction
         * @param clientX
         */
        FsDrawerResizerDirective.prototype._calcWidth = function (direction, clientX) {
            var directionSign = direction === 'left' ? -1 : 1;
            return this._width + (this._x - clientX) * directionSign;
        };
        /**
         * Resize event for Window
         */
        FsDrawerResizerDirective.prototype._emitResizeEvent = function () {
            var resizeEvent = window.document.createEvent('UIEvents');
            resizeEvent.initEvent('resize', true, false);
            window.dispatchEvent(resizeEvent);
        };
        FsDrawerResizerDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.Renderer2 },
            { type: core.NgZone }
        ]; };
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FsDrawerResizerDirective.prototype, "fsDrawerResizer", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", String)
        ], FsDrawerResizerDirective.prototype, "type", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FsDrawerResizerDirective.prototype, "direction", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", Object)
        ], FsDrawerResizerDirective.prototype, "resizable", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.ElementRef)
        ], FsDrawerResizerDirective.prototype, "parentContainer", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", core.ElementRef)
        ], FsDrawerResizerDirective.prototype, "actionsContainer", void 0);
        __decorate([
            core.Input(),
            __metadata("design:type", DrawerSizeController)
        ], FsDrawerResizerDirective.prototype, "sizeController", void 0);
        FsDrawerResizerDirective = __decorate([
            core.Directive({
                selector: '[fsDrawerResizer]',
                host: {
                    '[style.cursor]': '"col-resize"',
                }
            }),
            __metadata("design:paramtypes", [core.ElementRef,
                core.Renderer2,
                core.NgZone])
        ], FsDrawerResizerDirective);
        return FsDrawerResizerDirective;
    }());

    /** Injection token that can be used to access the data that was passed in to a drawer. */
    var DRAWER_DATA = new core.InjectionToken('DrawerData');

    var FsDrawerService = /** @class */ (function () {
        function FsDrawerService(_parentDrawerService, _overlay, _injector) {
            this._parentDrawerService = _parentDrawerService;
            this._overlay = _overlay;
            this._injector = _injector;
            this._drawerRefs = new Set();
            this._destroy$ = new rxjs.Subject();
        }
        FsDrawerService.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerService.prototype.open = function (component, config) {
            var _this = this;
            var overlayRef = this._createOverlay();
            var dataFactory = DrawerData.createWithProxy(config.data);
            var drawerRef = new DrawerRef(overlayRef, dataFactory, config);
            var containerRef = this._attachDrawerContainer(overlayRef, drawerRef, dataFactory);
            var componentRef = this._attachComponent(component, containerRef, drawerRef, dataFactory);
            drawerRef.containerRef = containerRef;
            containerRef.setDrawerRef(drawerRef);
            drawerRef.componentRef = componentRef;
            drawerRef.events();
            drawerRef.open();
            this._storeDrawerRef(drawerRef);
            rxjs.merge(drawerRef.afterOpened$, drawerRef.afterClosed$)
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                setTimeout(function () {
                    _this._applyBackdrop();
                    _this._applyBodyOpenClass();
                });
            });
            return drawerRef;
        };
        FsDrawerService.prototype.closeAll = function () {
            this._drawerRefs.forEach(function (ref) { return ref.close(); });
            if (this._parentDrawerService) {
                this._parentDrawerService.closeAll();
            }
        };
        FsDrawerService.prototype._applyBackdrop = function () {
            var _this = this;
            Array.from(this._drawerRefs)
                .forEach(function (drawerRef, index) {
                var backdrop = drawerRef.overlayRef.backdropElement;
                if (backdrop) {
                    if (index && index === (_this._drawerRefs.size - 1)) {
                        backdrop.classList.add('fs-drawer-backdrop-active');
                    }
                    else {
                        backdrop.classList.remove('fs-drawer-backdrop-active');
                    }
                }
            });
        };
        FsDrawerService.prototype._applyBodyOpenClass = function () {
            if (this._drawerRefs.size) {
                document.body.classList.add('fs-drawer-open');
            }
            else {
                document.body.classList.remove('fs-drawer-open');
            }
        };
        FsDrawerService.prototype._storeDrawerRef = function (ref) {
            var _this = this;
            this._drawerRefs.add(ref);
            this._pushDrawersCascade();
            ref.destroy$
                .pipe(operators.take(1), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._drawerRefs.delete(ref);
            });
        };
        /**
         * In case, when we want to open more than 1 drawer
         * our previously opened drawers should be visible
         *
         *      d1   d2   d3
         *     ---- ---- ---
         *    | x  | x1 | x2
         *    | y  | y1 | y2
         *    | z  | z1 | z2
         *     ---- ---- ---
         *
         * Where d1, d2 - previously opened drawers
         * d1 and d2 must be pushed left to be visible under just opened d3
         */
        FsDrawerService.prototype._pushDrawersCascade = function () {
            var _this = this;
            if (this._drawerRefs.size > 1) {
                // SetTimeout should be here because we must wait render newly opened drawer
                // to be able to get his width
                setTimeout(function () {
                    var refsArr = Array.from(_this._drawerRefs.values());
                    for (var i = refsArr.length - 1; i > 0; i--) {
                        var prevRef = refsArr[i - 1];
                        var currRef = refsArr[i];
                        prevRef.resizeController.pushMainWidth(currRef);
                    }
                });
            }
        };
        FsDrawerService.prototype._createOverlay = function () {
            var overlayConfig = this._getOverlayConfig();
            return this._overlay.create(overlayConfig);
        };
        FsDrawerService.prototype._getOverlayConfig = function () {
            return new overlay.OverlayConfig({
                hasBackdrop: true,
                backdropClass: 'fs-drawer-backdrop'
            });
        };
        FsDrawerService.prototype._attachDrawerContainer = function (overlayRef, drawerRef, dataFactory) {
            var injector = this._createInjector(drawerRef, dataFactory);
            var containerPortal = new portal.ComponentPortal(FsDrawerComponent, undefined, injector);
            var containerRef = overlayRef.attach(containerPortal);
            return containerRef.instance;
        };
        FsDrawerService.prototype._attachComponent = function (componentRef, drawerContainer, drawerRef, dataFactory) {
            var injector = this._createInjector(drawerRef, dataFactory);
            return drawerContainer.attachComponentPortal(new portal.ComponentPortal(componentRef, undefined, injector));
        };
        FsDrawerService.prototype._createInjector = function (componentRef, dataFactory) {
            var injectionTokens = new WeakMap([
                [DrawerRef, componentRef],
                [DRAWER_DATA, dataFactory]
            ]);
            return new portal.PortalInjector(this._injector, injectionTokens);
        };
        FsDrawerService.ctorParameters = function () { return [
            { type: FsDrawerService, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
            { type: overlay.Overlay },
            { type: core.Injector }
        ]; };
        FsDrawerService = __decorate([
            core.Injectable(),
            __param(0, core.Optional()), __param(0, core.SkipSelf()),
            __metadata("design:paramtypes", [FsDrawerService,
                overlay.Overlay,
                core.Injector])
        ], FsDrawerService);
        return FsDrawerService;
    }());

    var FsDrawerModule = /** @class */ (function () {
        function FsDrawerModule() {
        }
        FsDrawerModule = __decorate([
            core.NgModule({
                imports: [
                    common.CommonModule,
                    tooltip.MatTooltipModule,
                    button.MatButtonModule,
                    icon.MatIconModule,
                    overlay.OverlayModule,
                    portal.PortalModule,
                    menu$1.FsMenuModule,
                    menu.MatMenuModule,
                ],
                exports: [
                    FsDrawerComponent,
                    FsDrawerSideComponent,
                    FsDrawerContentComponent,
                    FsDrawerActionDirective,
                    FsDrawerResizerDirective,
                ],
                declarations: [
                    FsDrawerSideComponent,
                    FsDrawerComponent,
                    FsDrawerActionsComponent,
                    FsDrawerActionItemComponent,
                    FsDrawerContentComponent,
                    FsDrawerActionDirective,
                    FsDrawerResizerDirective,
                    FsDrawerMenuComponent,
                ],
                providers: [FsDrawerService],
            })
        ], FsDrawerModule);
        return FsDrawerModule;
    }());

    exports.DRAWER_DATA = DRAWER_DATA;
    exports.DRAWER_MENU_DATA = DRAWER_MENU_DATA;
    exports.DrawerData = DrawerData;
    exports.DrawerMenuRef = DrawerMenuRef;
    exports.DrawerRef = DrawerRef;
    exports.FsDrawerActionDirective = FsDrawerActionDirective;
    exports.FsDrawerComponent = FsDrawerComponent;
    exports.FsDrawerContentComponent = FsDrawerContentComponent;
    exports.FsDrawerModule = FsDrawerModule;
    exports.FsDrawerResizerDirective = FsDrawerResizerDirective;
    exports.FsDrawerService = FsDrawerService;
    exports.FsDrawerSideComponent = FsDrawerSideComponent;
    exports.a = FsDrawerMenuService;
    exports.b = DrawerSizeController;
    exports.c = FsDrawerActionsComponent;
    exports.d = FsDrawerActionItemComponent;
    exports.e = FsDrawerMenuComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=firestitch-drawer.umd.js.map
