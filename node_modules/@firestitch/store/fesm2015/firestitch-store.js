import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Observable } from 'rxjs';
import * as i2 from '@angular/router';
import { isAfter, subMinutes } from 'date-fns';
import { cloneDeep, pickBy } from 'lodash-es';

class FsStoreObject {
    constructor(name, event, value) {
        this.name = name;
        this.event = event;
        this.value = value;
    }
}
FsStoreObject.EVENT_SET = 'set';
FsStoreObject.EVENT_REMOVE = 'remove';
FsStoreObject.EVENT_INIT = 'init';

class FsStore {
    constructor() {
        this._storage = window.localStorage;
        this._storeObservers = [];
    }
    observe(name) {
        return new Observable((observer) => {
            this._getObservers().push({ name: name, observer: observer });
            observer.next(new FsStoreObject(name, FsStoreObject.EVENT_INIT, this.get(name)));
        });
    }
    get(key, options = {}) {
        if (this._storage.hasOwnProperty(key)) {
            try {
                return JSON.parse(this._storage[key]);
            }
            catch (e) { }
        }
        if (options.default !== undefined) {
            return options.default;
        }
        return undefined;
    }
    set(name, value, options = {}) {
        this._storage[name] = JSON.stringify(value);
        this._getObservers()
            .filter((storeObserver) => {
            return storeObserver.name === name;
        }).forEach((storeObserver) => {
            storeObserver.observer.next(new FsStoreObject(name, FsStoreObject.EVENT_SET, value));
        });
        return this;
    }
    remove(name, options = {}) {
        delete this._storage[name];
        this._getObservers()
            .filter((item) => {
            return item.name === name;
        })
            .forEach((storeObserver) => {
            storeObserver.observer.next(new FsStoreObject(name, FsStoreObject.EVENT_REMOVE));
        });
        return this;
    }
    clear() {
        for (let i = 0; i < this._storage.length; i++) {
            const key = this._storage.key(i);
            this._getObservers().forEach(item => {
                item.observer.next(new FsStoreObject(key, FsStoreObject.EVENT_REMOVE));
            });
        }
        this._storage.clear();
        return this;
    }
    _getObservers() {
        return this._storeObservers;
    }
}
FsStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStore, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
FsStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStore, decorators: [{
            type: Injectable
        }] });

class FsStoreModule {
    static forRoot() {
        return {
            ngModule: FsStoreModule,
            providers: [
                FsStore
            ],
        };
    }
}
FsStoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsStoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStoreModule, imports: [CommonModule] });
FsStoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStoreModule, imports: [[
            CommonModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsStoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                    ]
                }]
        }] });

class FsPersistanceStore {
    constructor(_store, _route) {
        this._store = _store;
        this._route = _route;
        this._enabled = false;
        this._openedInDialog = false;
        // Initialize store
        if (!this._store.get(this.STORE_KEY)) {
            this._store.set(this.STORE_KEY, {});
        }
    }
    get enabled() {
        return this._enabled;
    }
    get value() {
        return cloneDeep(this._value);
    }
    get namespace() {
        return this._namespace;
    }
    setConfig(persistanceConfig, namespace, inDialog = false) {
        this._namespace = namespace;
        this._openedInDialog = inDialog;
        if (typeof persistanceConfig === 'object') {
            this._persistConfig = Object.assign({}, persistanceConfig);
        }
        else {
            this._persistConfig = {};
        }
        if (this._route.snapshot.queryParams.persist === 'clear') {
            this.save({}, true);
        }
        // if filter in dialog - we should disable persistance
        if (this._route.snapshot.queryParams.persist !== 'disable'
            && persistanceConfig
            && !this._openedInDialog) {
            this._enabled = true;
        }
        this.restore();
    }
    save(data, force = false) {
        if (!this._enabled && !force) {
            return;
        }
        if (typeof data === 'object') {
            data = pickBy(data, (val) => {
                return val !== null && val !== void 0;
            });
        }
        // if filter in dialog - we should disable persistance
        if (!this._namespace && !force) {
            return;
        }
        this._putDataToLocalStore({
            data,
            date: new Date()
        });
    }
    /**
     * Restoring values from local storage
     */
    restore() {
        if (!this.enabled) {
            return;
        }
        let value = this._retrieveDataFromLocalStore();
        // Default value if data doesn't exists
        if (!value || !value.data) {
            value = { data: {}, date: new Date() };
        }
        else if (value) {
            // Check if data is too old
            if (this._persistConfig.timeout) {
                const date = new Date(value.date);
                if (isAfter(subMinutes(date, this._persistConfig.timeout), new Date())) {
                    value = { data: {}, date: new Date() };
                }
            }
        }
        this._value = value;
    }
    clear() {
        this.save({});
    }
    getDataFromScope(name) {
        return this.value.data[name];
    }
    saveDataToScope(name, value) {
        const data = Object.assign(Object.assign({}, this.value.data), { [name]: value });
        this.save(data);
    }
    _putDataToLocalStore(value) {
        const storeData = this._store.get(this.STORE_KEY) || {};
        storeData[this._namespace] = value;
        this._value = value;
        this._store.set(this.STORE_KEY, storeData);
    }
    _retrieveDataFromLocalStore() {
        const storeData = this._store.get(this.STORE_KEY);
        if (storeData) {
            return storeData[this._namespace];
        }
        else {
            return {};
        }
    }
}
FsPersistanceStore.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsPersistanceStore, deps: [{ token: FsStore }, { token: i2.ActivatedRoute }], target: i0.ɵɵFactoryTarget.Injectable });
FsPersistanceStore.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsPersistanceStore });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsPersistanceStore, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: FsStore }, { type: i2.ActivatedRoute }]; } });

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsPersistanceStore, FsStore, FsStoreModule, FsStoreObject };
//# sourceMappingURL=firestitch-store.js.map
