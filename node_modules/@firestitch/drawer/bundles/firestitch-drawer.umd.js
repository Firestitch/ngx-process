(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/cdk/portal'), require('@angular/cdk/overlay'), require('@angular/material/button'), require('@angular/material/icon'), require('@angular/material/menu'), require('@angular/material/tooltip'), require('@firestitch/menu'), require('rxjs'), require('@angular/cdk/keycodes'), require('rxjs/operators'), require('@angular/cdk/layout'), require('@firestitch/store'), require('@firestitch/common'), require('lodash-es')) :
    typeof define === 'function' && define.amd ? define('@firestitch/drawer', ['exports', '@angular/core', '@angular/common', '@angular/cdk/portal', '@angular/cdk/overlay', '@angular/material/button', '@angular/material/icon', '@angular/material/menu', '@angular/material/tooltip', '@firestitch/menu', 'rxjs', '@angular/cdk/keycodes', 'rxjs/operators', '@angular/cdk/layout', '@firestitch/store', '@firestitch/common', 'lodash-es'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.firestitch = global.firestitch || {}, global.firestitch.drawer = {}), global.ng.core, global.ng.common, global.ng.cdk.portal, global.ng.cdk.overlay, global.ng.material.button, global.ng.material.icon, global.ng.material.menu, global.ng.material.tooltip, global.i3, global.rxjs, global.ng.cdk.keycodes, global.rxjs.operators, global.ng.cdk.layout, global.store, global.common, global.lodashEs));
})(this, (function (exports, i0, i5, i1, i1$1, i2$1, i4, menu, i6, i3, rxjs, keycodes, operators, i2, store, common, lodashEs) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i5__namespace = /*#__PURE__*/_interopNamespace(i5);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);
    var i1__namespace$1 = /*#__PURE__*/_interopNamespace(i1$1);
    var i2__namespace$1 = /*#__PURE__*/_interopNamespace(i2$1);
    var i4__namespace = /*#__PURE__*/_interopNamespace(i4);
    var i6__namespace = /*#__PURE__*/_interopNamespace(i6);
    var i3__namespace = /*#__PURE__*/_interopNamespace(i3);
    var i2__namespace = /*#__PURE__*/_interopNamespace(i2);

    exports.FsDrawerAction = void 0;
    (function (FsDrawerAction) {
        FsDrawerAction["Button"] = "button";
        FsDrawerAction["Menu"] = "menu";
        FsDrawerAction["Component"] = "component";
    })(exports.FsDrawerAction || (exports.FsDrawerAction = {}));

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var BaseAction = /** @class */ (function () {
        function BaseAction(data) {
            if (data === void 0) { data = {}; }
            this._visible = true;
            this._icon = data.icon || '';
            this._click = data.click || null;
            this._link = data.link;
            this._show = data.show || null;
        }
        Object.defineProperty(BaseAction.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "click", {
            get: function () {
                return this._click;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "routerLink", {
            get: function () {
                return this._routerLink;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(BaseAction.prototype, "visible", {
            get: function () {
                return this._visible;
            },
            enumerable: false,
            configurable: true
        });
        BaseAction.prototype.checkVisibility = function (data) {
            if (this._show) {
                this._visible = this._show(data);
            }
        };
        BaseAction.prototype.updateRouterLink = function (data) {
            if (this._visible && this._link) {
                this._routerLink = this._link(data);
            }
        };
        return BaseAction;
    }());

    var MenuAction = /** @class */ (function (_super) {
        __extends(MenuAction, _super);
        function MenuAction(data) {
            if (data === void 0) { data = {}; }
            var _this = _super.call(this, data) || this;
            _this.actions = [];
            _this._isGroup = false;
            if (Array.isArray(data.actions)) {
                _this._isGroup = true;
                _this.actions = data.actions.map(function (action) { return new MenuAction(action); });
            }
            _this._label = data.label || '';
            return _this;
        }
        Object.defineProperty(MenuAction.prototype, "isGroup", {
            get: function () {
                return this._isGroup;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(MenuAction.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: false,
            configurable: true
        });
        MenuAction.prototype.updateRouterLink = function (data) {
            _super.prototype.updateRouterLink.call(this, data);
            if (this.actions.length > 0) {
                this.actions.forEach(function (action) {
                    action.updateRouterLink(data);
                });
            }
        };
        MenuAction.prototype.checkVisibility = function (data) {
            _super.prototype.checkVisibility.call(this, data);
            if (this.actions.length > 0) {
                this.actions.forEach(function (action) {
                    action.checkVisibility(data);
                });
            }
            if (this.actions.length > 0) {
                this._visible = this.actions.some(function (action) { return action.visible; });
            }
        };
        return MenuAction;
    }(BaseAction));

    var Action = /** @class */ (function (_super) {
        __extends(Action, _super);
        function Action(data) {
            if (data === void 0) { data = {}; }
            var _this = this;
            var _a;
            _this = _super.call(this, data) || this;
            _this._data = null;
            _this._disabled = false;
            _this._close = false;
            _this._closeSide = true;
            _this._menuActions = [];
            _this._component = null;
            _this._menuRefName = null;
            _this._icon = data.icon || '';
            _this._type = data.type || '';
            _this._name = data.name || '';
            _this._toggle = data.toggle === void 0 ? true : data.toggle;
            _this._tooltip = data.tooltip || '';
            _this._close = !!data.close;
            _this._component = data.component || null;
            _this._data = data.data === void 0 ? {} : data.data;
            _this._disabled = (_a = data.disabled) !== null && _a !== void 0 ? _a : false;
            if (_this._type === exports.FsDrawerAction.Component) {
                _this._menuRefName = data.name || data.icon;
            }
            if (_this._type === exports.FsDrawerAction.Menu && data.closeSide === void 0) {
                _this._closeSide = false;
            }
            else {
                _this._closeSide = data.closeSide === void 0 ? true : !!data.closeSide;
            }
            if (Array.isArray(data.actions)) {
                _this._menuActions = data.actions.map(function (action) { return new MenuAction(action); });
            }
            return _this;
        }
        Object.defineProperty(Action.prototype, "icon", {
            get: function () {
                return this._icon;
            },
            set: function (value) {
                this._icon = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "toggle", {
            get: function () {
                return this._toggle;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "name", {
            get: function () {
                return this._name;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._tooltip = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "close", {
            get: function () {
                return this._close;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "closeSide", {
            get: function () {
                return this._closeSide;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "menuActions", {
            get: function () {
                return this._menuActions;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "component", {
            get: function () {
                return this._component;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "data", {
            get: function () {
                return this._data;
            },
            set: function (value) {
                this._data = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "menuRefName", {
            get: function () {
                return this._menuRefName;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "disabled", {
            get: function () {
                return this._disabled;
            },
            set: function (value) {
                this._disabled = value;
            },
            enumerable: false,
            configurable: true
        });
        Action.prototype.updateRouterLink = function (data) {
            if (this._visible) {
                _super.prototype.updateRouterLink.call(this, data);
                if (this._menuActions.length > 0) {
                    this._menuActions.forEach(function (action) {
                        action.updateRouterLink(data);
                    });
                }
            }
        };
        Action.prototype.checkVisibility = function (data) {
            _super.prototype.checkVisibility.call(this, data);
            if (this._menuActions.length > 0) {
                this._menuActions.forEach(function (action) {
                    action.checkVisibility(data);
                });
            }
            if (this.menuActions.length > 0) {
                this._visible = this.menuActions.some(function (action) { return action.visible; });
            }
        };
        return Action;
    }(BaseAction));

    var DrawerConfig = /** @class */ (function () {
        function DrawerConfig(data) {
            if (data === void 0) { data = {}; }
            this.disableClose = data.disableClose || false;
            this.position = data.position || 'right';
            this.activeAction = data.activeAction || '';
            this.persist = data.persist;
            this.resizable = data.resizable === void 0 ? true : data.resizable;
            if (data.width) {
                this.width = data.width;
            }
            this.actions = data.actions && data.actions.map(function (action) { return new Action(action); }) || null;
        }
        return DrawerConfig;
    }());

    var DrawerRef = /** @class */ (function () {
        function DrawerRef(_overlayRef, _dataFactory, _config) {
            this._overlayRef = _overlayRef;
            this._dataFactory = _dataFactory;
            /** Subject for notifying the user that the drawer has finished opening. */
            this._afterOpened$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has finished closing. */
            this._afterClosed$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started closing. */
            this._closeStart$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started opening. */
            this._openStart$ = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has started closing. */
            this._sideToggle = new rxjs.Subject();
            /** Subject for notifying the user that the drawer has finished opening. */
            this._actionsUpdated$ = new rxjs.Subject();
            /** Destroy notifier **/
            this._destroy$ = new rxjs.Subject();
            this._activeAction = new rxjs.BehaviorSubject(void 0);
            this._menuRefs = new Map();
            this._isOpen = false;
            this._isSideOpen = false;
            this.drawerConfig = new DrawerConfig(_config);
            this._initActiveAction();
        }
        Object.defineProperty(DrawerRef.prototype, "overlayRef", {
            get: function () {
                return this._overlayRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerData", {
            /**
             * Getter for DRAWER_DATA for current drawer
             */
            get: function () {
                return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "destroy$", {
            get: function () {
                return this._destroy$.asObservable();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "containerRef", {
            /**
             * Set reference to drawer container
             * @param value
             */
            set: function (value) {
                this._drawerContainerRef = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "componentRef", {
            /**
             * Set reference to drawer component
             * @param value
             */
            set: function (value) {
                this._drawerComponentRef = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerContainer", {
            get: function () {
                return this._drawerContainer;
            },
            set: function (value) {
                this._drawerContainer = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "drawerActionsContainer", {
            get: function () {
                return this._drawerActionsContainer;
            },
            set: function (value) {
                this._drawerActionsContainer = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "activeAction", {
            get: function () {
                return this._activeAction.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "activeAction$", {
            get: function () {
                return this._activeAction.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "isOpen", {
            /**
             * Return actual status of the drawer
             */
            get: function () {
                return this._isOpen;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "isSideOpen", {
            /**
             * Return actual status of the side of the drawer
             */
            get: function () {
                return this._isSideOpen;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "resizeController", {
            get: function () {
                return this._resizeController;
            },
            set: function (value) {
                this._resizeController = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "actionUpdated$", {
            /**
             * Gets an observable that action was updated and change detection should be started
             */
            get: function () {
                return this._actionsUpdated$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "afterClosed$", {
            /**
             * Gets an observable that is notified when the dialog is finished closing.
             */
            get: function () {
                return this._afterClosed$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "afterOpened$", {
            /**
             * Gets an observable that is notified when the dialog is finished opening.
             */
            get: function () {
                return this._afterOpened$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "openStart$", {
            /**
             * Gets an observable that is notified when the dialog open starts.
             */
            get: function () {
                return this._openStart$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "closeStart$", {
            /**
             * Gets an observable that is notified when the dialog is finished opening.
             */
            get: function () {
                return this._closeStart$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        DrawerRef.prototype.closeWhen = function () {
            var _this = this;
            return function (source) {
                _this._closeStart$
                    .pipe(operators.switchMap(function (observer) {
                    return source.pipe(operators.map(function () {
                        return observer;
                    }));
                }))
                    .subscribe(function (observer) {
                    observer.next();
                    observer.complete();
                });
                //   switchMap(() => {
                //     debugger;
                //     return source;
                //   })
                // )
                // .subscribe((observer) => {
                // source.pipe(
                //   tap(() => {
                //     debugger;
                //     observer.next();
                //     observer.complete();
                //   }),
                // );
                return source;
                // return new Observable(subscriber => {
                //   source.subscribe({
                //     next(value) {
                //       if (value !== undefined && value !== null) {
                //         subscriber.next(value);
                //       }
                //     },
                //     error(error) {
                //       subscriber.error(error);
                //     },
                //     complete() {
                //       subscriber.complete();
                //     }
                //   })
                // });
            };
        };
        Object.defineProperty(DrawerRef.prototype, "dataChanged$", {
            /**
             * Gets an observable that is notified when data in DRAWER_DATA was changed
             */
            get: function () {
                return this._dataFactory.dataChange$;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerRef.prototype, "sideToggle$", {
            /**
             * Gets an observable that is notify that side status toggled
             */
            get: function () {
                return this._sideToggle.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Subscribe on keydown events to react on escape
         */
        DrawerRef.prototype.events = function () {
            var _this = this;
            this._overlayRef.keydownEvents()
                .pipe(operators.filter(function (event) { return event.keyCode === keycodes.ESCAPE && !_this.drawerConfig.disableClose; }), operators.takeUntil(this._destroy$))
                .subscribe(function () { return _this.close(); });
        };
        /**
         * Set value for DRAWER_DATA
         * @param data
         */
        DrawerRef.prototype.dataChange = function (data) {
            this._dataFactory.setValue(data);
        };
        /**
         * Open drawer and notify observable
         */
        DrawerRef.prototype.open = function () {
            var _this = this;
            new rxjs.Observable(function (obs) {
                setTimeout(function () {
                    if (_this._openStart$.observers.length) {
                        _this._openStart$.next(obs);
                    }
                    else {
                        obs.next();
                        obs.complete();
                    }
                });
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    if (_this.activeAction) {
                        _this.openSide();
                    }
                    _this._drawerContainerRef.open();
                    _this._afterOpened$.next();
                    _this._afterOpened$.complete();
                },
                error: function () {
                    _this.destroy();
                },
            });
        };
        /**
         * Close the drawer.
         * @param result Optional result to return to the dialog opener.
         */
        DrawerRef.prototype.close = function (result) {
            var _this = this;
            new rxjs.Observable(function (observer) {
                if (_this._closeStart$.observers.length) {
                    rxjs.zip.apply(void 0, __spreadArray([], __read(_this._closeStart$.observers.map(function (item) {
                        return rxjs.Observable.create(function (closeObserver) {
                            item.next(closeObserver);
                        });
                    })))).pipe(operators.takeUntil(_this._destroy$))
                        .subscribe(function () {
                        observer.next();
                        observer.complete();
                    }, function () {
                        observer.error();
                    });
                }
                else {
                    observer.next();
                    observer.complete();
                }
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    _this._drawerContainerRef.close();
                    _this._result = result;
                    _this._afterClosed$.next(result);
                    _this.destroy();
                }
            });
        };
        /**
         * Open the side of the drawer
         */
        DrawerRef.prototype.openSide = function () {
            this._isSideOpen = true;
            this._sideToggle.next(this._isSideOpen);
        };
        /**
         * Close the side of the drawer
         */
        DrawerRef.prototype.closeSide = function () {
            this._isSideOpen = false;
            this._sideToggle.next(this._isSideOpen);
            this.activateAction(null);
        };
        /**
         * Toggle the side of the drawer
         */
        DrawerRef.prototype.toggleSide = function () {
            this.isSideOpen ? this.closeSide() : this.openSide();
        };
        /**
         * Change active action
         * @param name
         */
        DrawerRef.prototype.activateAction = function (name) {
            this._activeAction.next(name);
            if (name) {
                this.openSide();
            }
        };
        DrawerRef.prototype.enableAction = function (name) {
            var action = this.getAction(name);
            if (action) {
                action.disabled = false;
                this._actionsUpdated$.next(name);
            }
        };
        DrawerRef.prototype.disableAction = function (name) {
            var action = this.getAction(name);
            if (action) {
                action.disabled = true;
                this._actionsUpdated$.next(name);
            }
        };
        /**
         * Store opened menu reference and subscribe for auto remove
         * @param name
         * @param ref
         */
        DrawerRef.prototype.addMenuRef = function (name, ref) {
            var _this = this;
            this._menuRefs.set(name, ref);
            ref.afterClosed()
                .pipe(operators.take(1), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._menuRefs.delete(name);
            });
        };
        /**
         * Get opened menu reference by name
         * @param name
         */
        DrawerRef.prototype.getMenuRef = function (name) {
            return this._menuRefs.get(name);
        };
        DrawerRef.prototype.getAction = function (name) {
            return this.drawerConfig.actions.find(function (action) { return action.name === name; });
        };
        /**
         * Do update for icon for target action
         * @param name
         * @param icon
         */
        DrawerRef.prototype.updateActionIcon = function (name, icon) {
            var action = this.getAction(name);
            if (action) {
                action.icon = icon;
                this._actionsUpdated$.next(name);
            }
        };
        /**
         * Do update
         * @param name
         * @param data
         */
        DrawerRef.prototype.updateAction = function (name, data) {
            var action = this.getAction(name);
            if (action) {
                var allowedFields_1 = ['icon', 'type', 'toggle', 'tooltip', 'close', 'closeSide', 'component', 'data'];
                var forUpdate = Object.keys(data).filter(function (key) { return allowedFields_1.indexOf(key) > -1; });
                forUpdate.forEach(function (key) {
                    action[key] = data[key];
                });
                this._actionsUpdated$.next(name);
            }
        };
        DrawerRef.prototype.updateDrawerWidth = function (width) {
            this.resizeController.updateMainWidth(width);
        };
        DrawerRef.prototype.updateSideDrawerWidth = function (width) {
            this.resizeController.updateSideWidth(width);
        };
        DrawerRef.prototype.destroy = function () {
            this._overlayRef.detachBackdrop();
            this._overlayRef.detach();
            this._drawerComponentRef.destroy();
            this._dataFactory.destroy();
            this._destroy$.next();
            this._destroy$.complete();
        };
        DrawerRef.prototype._initActiveAction = function () {
            var _this = this;
            if (this.drawerConfig.activeAction) {
                var action = this.drawerConfig.actions
                    .find(function (a) { return a.name === _this.drawerConfig.activeAction; });
                if (action) {
                    this._activeAction.next(this.drawerConfig.activeAction);
                }
                else {
                    console.warn("Drawer active action - \"" + this.drawerConfig.activeAction + "\" does not exists\n        ");
                }
            }
        };
        return DrawerRef;
    }());

    var FsDrawerMenuComponent = /** @class */ (function (_super) {
        __extends(FsDrawerMenuComponent, _super);
        function FsDrawerMenuComponent() {
            return _super.call(this) || this;
        }
        FsDrawerMenuComponent.prototype.setDrawerMenuRef = function (value) {
            this.ref = value;
            // this.config = this.externalMenuRef.config;
        };
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerMenuComponent.prototype.attachComponentPortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer component already attached');
            }
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerMenuComponent.prototype.attachTemplatePortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer template already attached');
            }
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        return FsDrawerMenuComponent;
    }(i1.BasePortalOutlet));
    FsDrawerMenuComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerMenuComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerMenuComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerMenuComponent, selector: "fs-drawer-menu", host: { classAttribute: "mat-elevation-z2" }, viewQueries: [{ propertyName: "_portalOutlet", first: true, predicate: i1.CdkPortalOutlet, descendants: true, static: true }], usesInheritance: true, ngImport: i0__namespace, template: "<ng-template cdkPortalOutlet></ng-template>\n", styles: [":host{padding:15px;background:#fff;border-radius:2px;overflow:auto}\n"], directives: [{ type: i1__namespace.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerMenuComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'fs-drawer-menu',
                        templateUrl: 'drawer-menu.component.html',
                        styleUrls: ['drawer-menu.component.scss'],
                        host: {
                            'class': 'mat-elevation-z2'
                        },
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return []; }, propDecorators: { _portalOutlet: [{
                    type: i0.ViewChild,
                    args: [i1.CdkPortalOutlet, { static: true }]
                }] } });

    var DrawerMenuRef = /** @class */ (function () {
        function DrawerMenuRef(_overlayRef, _dataFactory) {
            var _this = this;
            this._overlayRef = _overlayRef;
            this._dataFactory = _dataFactory;
            /** Subject for notifying the user that the menu has finished closing. */
            this._afterClosed$ = new rxjs.Subject();
            /** Subject for notifying the user that the menu has started closing. */
            this._closeStart$ = new rxjs.Subject();
            /** Destroy notifier **/
            this._destroy$ = new rxjs.Subject();
            this._overlayRef.backdropClick()
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this.close();
            });
        }
        Object.defineProperty(DrawerMenuRef.prototype, "menuData", {
            /**
             * Getter for DRAWER_MENU_DATA for current drawer
             */
            get: function () {
                return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "containerRef", {
            /**
             * Set reference to menu container
             * @param value
             */
            set: function (value) {
                this._externalMenuContainerRef = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "componentRef", {
            /**
             * Set reference to menu component
             * @param value
             */
            set: function (value) {
                this._externalMenuComponentRef = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerMenuRef.prototype, "dataChanged$", {
            /**
             * Gets an observable that is notified when data in DRAWER_DATA was changed
             */
            get: function () {
                return this._dataFactory.dataChange$;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Set value for DRAWER_DATA
         * @param data
         */
        DrawerMenuRef.prototype.dataChange = function (data) {
            this._dataFactory.setValue(data);
        };
        /**
         * Gets an observable that is notified when the dialog is finished closing.
         */
        DrawerMenuRef.prototype.afterClosed = function () {
            return this._afterClosed$.pipe(operators.takeUntil(this._destroy$));
        };
        /**
         * Gets an observable that is notified when the dialog is finished opening.
         */
        DrawerMenuRef.prototype.closeStart = function () {
            return this._closeStart$.pipe(operators.takeUntil(this._destroy$));
        };
        /**
         * Close the menu.
         * @param result Optional result to return to the dialog opener.
         */
        DrawerMenuRef.prototype.close = function (result) {
            var _this = this;
            new rxjs.Observable(function (observer) {
                if (_this._closeStart$.observers.length) {
                    rxjs.zip.apply(void 0, __spreadArray([], __read(_this._closeStart$.observers.map(function (item) {
                        return rxjs.Observable.create(function (closeObserver) {
                            item.next(closeObserver);
                        });
                    })))).pipe(operators.takeUntil(_this._destroy$))
                        .subscribe(function () {
                        observer.next();
                        observer.complete();
                    }, function () {
                        observer.error();
                    });
                }
                else {
                    observer.next();
                    observer.complete();
                }
            }).pipe(operators.takeUntil(this._destroy$))
                .subscribe({
                next: function () {
                    _this._result = result;
                    _this._afterClosed$.next(result);
                    _this.destroy();
                }
            });
        };
        DrawerMenuRef.prototype.destroy = function () {
            this._overlayRef.detachBackdrop();
            this._overlayRef.detach();
            this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
            this._dataFactory.destroy();
            this._destroy$.next();
            this._destroy$.complete();
        };
        return DrawerMenuRef;
    }());

    var DrawerData = /** @class */ (function () {
        function DrawerData(data) {
            if (data === void 0) { data = {}; }
            this._dataChange = new rxjs.Subject();
            this._destroy = new rxjs.Subject();
            this._data = data;
        }
        DrawerData.createWithProxy = function (data) {
            if (data === void 0) { data = {}; }
            var drawerData = new DrawerData(data);
            return new Proxy(drawerData, {
                get: function (target, property) {
                    if (typeof target[property] === 'function'
                        || property === '_data'
                        || target[property] instanceof rxjs.Observable) {
                        return target[property];
                    }
                    else {
                        return target._data[property];
                    }
                },
                set: function (target, property, value) {
                    if (property !== '_data') {
                        target._data[property] = value;
                    }
                    else {
                        target[property] = value;
                    }
                    return true;
                },
                has: function (target, property) {
                    return property in target._data;
                },
                ownKeys: function (target) {
                    return Object.keys(target._data);
                },
                getOwnPropertyDescriptor: function (target, property) {
                    return Object.getOwnPropertyDescriptor(target._data, property);
                }
            });
        };
        Object.defineProperty(DrawerData.prototype, "dataChange$", {
            get: function () {
                return this._dataChange.pipe(operators.takeUntil(this._destroy));
            },
            enumerable: false,
            configurable: true
        });
        DrawerData.prototype.getValue = function () {
            return this._data;
        };
        DrawerData.prototype.setValue = function (value) {
            this._data = value;
            this._dataChange.next(this._data);
        };
        DrawerData.prototype.destroy = function () {
            this._destroy.next();
            this._destroy.complete();
        };
        return DrawerData;
    }());

    /** Injection token that can be used to access the data that was passed in to a drawer. */
    var DRAWER_MENU_DATA = new i0.InjectionToken('fs.drawer.menu-data');

    var FsDrawerMenuService = /** @class */ (function () {
        function FsDrawerMenuService(_overlay, _injector, _breakpointObserver) {
            this._overlay = _overlay;
            this._injector = _injector;
            this._breakpointObserver = _breakpointObserver;
        }
        FsDrawerMenuService.prototype.create = function (component, container, config) {
            var overlayRef = this.createOverlay(container);
            var dataFactory = DrawerData.createWithProxy(config.data);
            var menuRef = new DrawerMenuRef(overlayRef, dataFactory);
            var containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
            var componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
            menuRef.containerRef = containerRef;
            containerRef.setDrawerMenuRef(menuRef);
            menuRef.componentRef = componentRef;
            return menuRef;
        };
        FsDrawerMenuService.prototype.createOverlay = function (container) {
            var overlayConfig = this.getOverlayConfig(container);
            return this._overlay.create(overlayConfig);
        };
        FsDrawerMenuService.prototype.getOverlayConfig = function (container) {
            var element = new i0.ElementRef(container); // positionStrategy needs ElementRef;
            var strategy = null;
            if (this._breakpointObserver.isMatched(i2.Breakpoints.XSmall)) {
                strategy = this._overlay
                    .position()
                    .global()
                    .centerHorizontally()
                    .centerVertically();
            }
            else {
                var positions = [
                    { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
                ];
                strategy = this._overlay
                    .position()
                    .flexibleConnectedTo(element)
                    .withPositions(positions);
            }
            return new i1$1.OverlayConfig({
                positionStrategy: strategy,
                scrollStrategy: this._overlay.scrollStrategies.reposition(),
                hasBackdrop: true,
                backdropClass: 'cdk-overlay-transparent-backdrop'
            });
        };
        FsDrawerMenuService.prototype.attachContainer = function (overlayRef, menuRef, dataFactory) {
            var injector = this.createInjector(menuRef, dataFactory);
            var containerPortal = new i1.ComponentPortal(FsDrawerMenuComponent, undefined, injector);
            var containerRef = overlayRef.attach(containerPortal);
            return containerRef.instance;
        };
        FsDrawerMenuService.prototype.attachComponent = function (componentRef, externalContainer, externalRef, config) {
            var injector = this.createInjector(externalRef, config);
            return externalContainer.attachComponentPortal(new i1.ComponentPortal(componentRef, undefined, injector));
        };
        FsDrawerMenuService.prototype.createInjector = function (componentRef, dataFactory) {
            var injectionTokens = new WeakMap([
                [DrawerMenuRef, componentRef],
                [DRAWER_MENU_DATA, dataFactory]
            ]);
            return new i1.PortalInjector(this._injector, injectionTokens);
        };
        return FsDrawerMenuService;
    }());
    FsDrawerMenuService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerMenuService, deps: [{ token: i1__namespace$1.Overlay }, { token: i0__namespace.Injector }, { token: i2__namespace.BreakpointObserver }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FsDrawerMenuService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerMenuService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerMenuService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: i1__namespace$1.Overlay }, { type: i0__namespace.Injector }, { type: i2__namespace.BreakpointObserver }]; } });

    var FsDrawerActionItemComponent = /** @class */ (function () {
        function FsDrawerActionItemComponent(drawer, _cdRef) {
            this.drawer = drawer;
            this._cdRef = _cdRef;
            this.actionClicked = new i0.EventEmitter();
            this.isActive = false;
            this.actionTypes = exports.FsDrawerAction;
            this._destroy$ = new rxjs.Subject();
            this._listenActionChanges();
            this._listenDataChanges();
        }
        FsDrawerActionItemComponent.prototype.ngOnInit = function () {
            this._updateVisibilityAndLinks();
        };
        FsDrawerActionItemComponent.prototype.ngOnChanges = function (changes) {
            if (changes.activeAction) {
                this.isActive = this.action.name !== '' && this.action.name === this.activeAction;
            }
        };
        FsDrawerActionItemComponent.prototype.actionClick = function (event) {
            this.actionClicked.emit(event);
        };
        FsDrawerActionItemComponent.prototype.menuActionClick = function (action, event) {
            if (action.click) {
                action.click.call(null, {
                    data: this.drawer.drawerData,
                    event: event,
                    drawerRef: this.drawer,
                    action: action
                });
            }
        };
        FsDrawerActionItemComponent.prototype._listenActionChanges = function () {
            var _this = this;
            this.drawer.actionUpdated$
                .pipe(operators.filter(function (name) { return name === _this.action.name; }), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._cdRef.detectChanges();
            });
        };
        FsDrawerActionItemComponent.prototype._listenDataChanges = function () {
            var _this = this;
            this.drawer.dataChanged$
                .pipe(operators.takeUntil(this._destroy$), operators.debounceTime(50))
                .subscribe(function () {
                _this._updateVisibilityAndLinks();
            });
        };
        FsDrawerActionItemComponent.prototype._updateVisibilityAndLinks = function () {
            this._updateVisibility();
            this._updateRouterLinks();
            this._cdRef.detectChanges();
        };
        FsDrawerActionItemComponent.prototype._updateVisibility = function () {
            this.action.checkVisibility(this.drawer.drawerData);
        };
        FsDrawerActionItemComponent.prototype._updateRouterLinks = function () {
            if (this.action.type === this.actionTypes.Menu) {
                this.action.updateRouterLink({
                    data: this.drawer.drawerData,
                    drawerRef: this.drawer
                });
            }
        };
        return FsDrawerActionItemComponent;
    }());
    FsDrawerActionItemComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionItemComponent, deps: [{ token: DrawerRef }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerActionItemComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionItemComponent, selector: "fs-drawer-action-item", inputs: { action: "action", activeAction: "activeAction" }, outputs: { actionClicked: "actionClicked" }, usesOnChanges: true, ngImport: i0__namespace, template: "<ng-container [ngSwitch]=\"action.type\">\n  <ng-container *ngSwitchCase=\"actionTypes.Button\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [disabled]=\"action.disabled\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Menu\">\n    <ng-container *ngIf=\"action.visible\">\n      <button mat-icon-button\n              type=\"button\"\n              class=\"sub-action\"\n              [fsMenuTriggerFor]=\"menu\"\n              [matTooltip]=\"action.tooltip\"\n              [disabled]=\"action.disabled\"\n              [class.active]=\"isActive\"\n              (click)=\"actionClick($event)\">\n        <i class=\"material-icons\">{{action.icon}}</i>\n      </button>\n\n      <fs-menu #menu>\n        <ng-container *ngFor=\"let menuAction of action.menuActions\">\n          <ng-container *ngIf=\"menuAction.isGroup else simpleMenuItem\">\n            <fs-menu-group [label]=\"menuAction.label\" [hidden]=\"!menuAction.visible\">\n              <ng-container *ngFor=\"let groupAction of menuAction.actions\">\n                <ng-template fs-menu-item\n                             [hidden]=\"!groupAction.visible\"\n                             [link]=\"groupAction.routerLink?.link\"\n                             [queryParams]=\"groupAction.routerLink?.queryParams\"\n                             (click)=\"menuActionClick(groupAction, $event);\">\n                  <mat-icon *ngIf=\"menuAction.icon\">{{groupAction.icon}}</mat-icon>\n                  {{groupAction.label}}\n                </ng-template>\n              </ng-container>\n            </fs-menu-group>\n          </ng-container>\n          <ng-template #simpleMenuItem>\n            <ng-template fs-menu-item\n                         [hidden]=\"!menuAction.visible\"\n                         [link]=\"menuAction.routerLink?.link\"\n                         [queryParams]=\"menuAction.routerLink?.queryParams\"\n                         (click)=\"menuActionClick(menuAction, $event);\">\n              <i class=\"material-icons\" *ngIf=\"menuAction.icon\">{{menuAction.icon}}</i>\n              <span>{{menuAction.label}}</span>\n            </ng-template>\n          </ng-template>\n        </ng-container>\n      </fs-menu>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Component\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [disabled]=\"action.disabled\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n</ng-container>\n", styles: [".mat-icon-button{width:35px;height:35px;line-height:35px}.mat-icon-button[disabled=true]{opacity:.5}\n"], components: [{ type: i2__namespace$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { type: i3__namespace.FsMenuComponent, selector: "fs-menu", inputs: ["class", "buttonClass"], outputs: ["opened", "closed"] }, { type: i4__namespace.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5__namespace.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i5__namespace.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i5__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6__namespace.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { type: i3__namespace.FsMenuTriggerDirective, selector: "[fsMenuTriggerFor]", inputs: ["fsMenuTriggerFor"] }, { type: i5__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3__namespace.FsMenuItemDirective, selector: "fs-menu-group,[fs-menu-item]", inputs: ["fsClass", "class", "id", "label", "hidden", "groupHidden", "dismissAfterClick", "link", "target", "queryParams"], outputs: ["click"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionItemComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'fs-drawer-action-item',
                        templateUrl: './drawer-action-item.component.html',
                        styleUrls: [
                            './drawer-action-item.component.scss',
                        ],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: DrawerRef }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { action: [{
                    type: i0.Input
                }], activeAction: [{
                    type: i0.Input
                }], actionClicked: [{
                    type: i0.Output
                }] } });

    var FsDrawerActionsComponent = /** @class */ (function () {
        function FsDrawerActionsComponent(_drawerRef, _drawerMenu, _cdRef) {
            this._drawerRef = _drawerRef;
            this._drawerMenu = _drawerMenu;
            this._cdRef = _cdRef;
            this._destroy$ = new rxjs.Subject();
        }
        FsDrawerActionsComponent.prototype.ngOnInit = function () {
        };
        FsDrawerActionsComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerActionsComponent.prototype.actionClick = function (action, event) {
            var hasComponentType = action.type === exports.FsDrawerAction.Component;
            var hasMenuType = action.type === exports.FsDrawerAction.Menu;
            if (hasComponentType) {
                var menuRef = this._drawerMenu.create(action.component, event.srcElement, action);
                this._drawerRef.addMenuRef(action.menuRefName, menuRef);
                var params = {
                    event: event,
                    action: action,
                    drawerRef: this._drawerRef,
                    menuRef: menuRef
                };
                // Call click
                action.click.call(null, params);
                if (action.closeSide) {
                    this._drawerRef.closeSide();
                }
            }
            else if (action.click) {
                var params = { event: event, action: action };
                action.click.call(null, params);
            }
            if (action.close) {
                this._drawerRef.close();
            }
            if (action.toggle && ((!hasComponentType && !hasMenuType) || action.closeSide)) {
                if (this._drawerRef.isSideOpen && this._drawerRef.activeAction === action.name) {
                    this._drawerRef.toggleSide();
                }
                else {
                    this._drawerRef.activateAction(action.name);
                }
            }
        };
        FsDrawerActionsComponent.prototype.muteEvent = function (e) {
            e.stopImmediatePropagation();
            e.stopPropagation();
        };
        return FsDrawerActionsComponent;
    }());
    FsDrawerActionsComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionsComponent, deps: [{ token: DrawerRef }, { token: FsDrawerMenuService }, { token: i0__namespace.ChangeDetectorRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerActionsComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionsComponent, selector: "fs-drawer-actions", inputs: { actions: "actions", activeAction: "activeAction" }, ngImport: i0__namespace, template: "<div class=\"actions-container\" (mousedown)=\"muteEvent($event)\" (dragstart)=\"muteEvent($event)\">\n  <div *ngFor=\"let action of actions\" class=\"action-btn\">\n    <fs-drawer-action-item [action]=\"action\"\n                           [activeAction]=\"activeAction\"\n                           (actionClicked)=\"actionClick(action, $event)\">\n    </fs-drawer-action-item>\n  </div>\n</div>\n<div class=\"drag-icon\">\n  <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n</div>\n<div class=\"drag-ripple\"></div>\n", styles: [":host{display:flex}.actions-container{flex:0;margin-top:5px;cursor:pointer}.drag-icon{opacity:0;flex:1;display:flex;align-items:center}.drag-ripple{position:absolute;top:0;bottom:0;width:100%;background:transparent;transition:.2s}\n"], components: [{ type: FsDrawerActionItemComponent, selector: "fs-drawer-action-item", inputs: ["action", "activeAction"], outputs: ["actionClicked"] }, { type: i2__namespace$1.MatAnchor, selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matButton", "matAnchor"] }, { type: i4__namespace.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5__namespace.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionsComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'fs-drawer-actions',
                        templateUrl: './drawer-actions.component.html',
                        styleUrls: ['./drawer-actions.component.scss'],
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: DrawerRef }, { type: FsDrawerMenuService }, { type: i0__namespace.ChangeDetectorRef }]; }, propDecorators: { actions: [{
                    type: i0.Input
                }], activeAction: [{
                    type: i0.Input
                }] } });

    var MAIN_DRAWER_DEFAULT_WIDTH = 500;
    var SIDE_DRAWER_DEFAULT_WIDTH = 200;
    var SIDE_RESIZE_BAR_WIDTH = 46;
    var MAIN_RESIZE_ACTION_BAR_WIDTH = 45;

    var FsDrawerPersistanceController = /** @class */ (function (_super) {
        __extends(FsDrawerPersistanceController, _super);
        function FsDrawerPersistanceController() {
            var _this = _super.apply(this, __spreadArray([], __read(arguments))) || this;
            _this.STORE_KEY = 'fs-drawer-persist';
            return _this;
        }
        return FsDrawerPersistanceController;
    }(store.FsPersistanceStore));
    FsDrawerPersistanceController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerPersistanceController, deps: null, target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FsDrawerPersistanceController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerPersistanceController });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerPersistanceController, decorators: [{
                type: i0.Injectable
            }] });

    var DrawerStoreService = /** @class */ (function () {
        function DrawerStoreService() {
            this._openedDrawers = [];
        }
        Object.defineProperty(DrawerStoreService.prototype, "drawerRefs", {
            get: function () {
                return __spreadArray([], __read(this._openedDrawers));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerStoreService.prototype, "numberOfOpenedDrawers", {
            get: function () {
                return this._openedDrawers.length;
            },
            enumerable: false,
            configurable: true
        });
        DrawerStoreService.prototype.getLevelForRef = function (value) {
            return this._openedDrawers.indexOf(value) + 1;
        };
        DrawerStoreService.prototype.addRef = function (value) {
            if (this._openedDrawers.indexOf(value) === -1) {
                this._openedDrawers.push(value);
                this._pushDrawersCascade();
            }
        };
        DrawerStoreService.prototype.deleteRef = function (value) {
            this._openedDrawers = this._openedDrawers
                .filter(function (ref) { return ref !== value; });
        };
        /**
         * In case, when we want to open more than 1 drawer
         * our previously opened drawers should be visible
         *
         *      d1   d2   d3
         *     ---- ---- ---
         *    | x  | x1 | x2
         *    | y  | y1 | y2
         *    | z  | z1 | z2
         *     ---- ---- ---
         *
         * Where d1, d2 - previously opened drawers
         * d1 and d2 must be pushed left to be visible under just opened d3
         */
        DrawerStoreService.prototype._pushDrawersCascade = function () {
            var _this = this;
            if (this.numberOfOpenedDrawers > 1) {
                // SetTimeout should be here because we must wait render newly opened drawer
                // to be able to get his width
                setTimeout(function () {
                    var refsArr = Array.from(_this._openedDrawers.values());
                    for (var i = refsArr.length - 1; i > 0; i--) {
                        var prevRef = refsArr[i - 1];
                        var currRef = refsArr[i];
                        prevRef.resizeController.pushMainWidth(currRef);
                    }
                });
            }
        };
        return DrawerStoreService;
    }());
    DrawerStoreService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerStoreService, deps: [], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DrawerStoreService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerStoreService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerStoreService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }] });

    var DrawerSizeController = /** @class */ (function () {
        function DrawerSizeController(_drawerRef, _ngZone, _persistanceController, _drawerStore) {
            this._drawerRef = _drawerRef;
            this._ngZone = _ngZone;
            this._persistanceController = _persistanceController;
            this._drawerStore = _drawerStore;
            this._sideOpened = false;
            this._borderPadding = 0;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(DrawerSizeController.prototype, "mainElRef", {
            get: function () {
                return this._mainElRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "sideElRef", {
            get: function () {
                return this._sideElRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "mainConfig", {
            get: function () {
                return this._mainConfig;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "sideConfig", {
            get: function () {
                return this._sideConfig;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "screenWidth", {
            get: function () {
                return this._screenWidth;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "persistedMainWidth", {
            get: function () {
                return this._persistanceController.enabled
                    ? this._persistanceController.getDataFromScope('mainWidth')
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DrawerSizeController.prototype, "persistedSideWidth", {
            get: function () {
                return this._persistanceController.enabled
                    ? this._persistanceController.getDataFromScope('sideWidth')
                    : null;
            },
            enumerable: false,
            configurable: true
        });
        DrawerSizeController.prototype.init = function () {
            this._initDefaultConfigs();
            this._updateScreenWidth();
            this._listenWindowResize();
            this._listenSideToggle();
        };
        DrawerSizeController.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        DrawerSizeController.prototype.registerElRef = function (el) {
            if (el.isMainDrawer) {
                this._registerMainRef(el);
                this._listenWidthChanges(el);
            }
            else if (el.isSideDrawer) {
                this._registerSideRef(el);
                this._listenWidthChanges(el);
            }
            else {
                throw Error('Unrecognized resize element type');
            }
        };
        DrawerSizeController.prototype.removeElRef = function (el) {
            if (el.isMainDrawer) {
                this._removeMainRef();
            }
            else if (el.isSideDrawer) {
                this._removeSideRef();
            }
        };
        DrawerSizeController.prototype.getInitialWidth = function (type) {
            if (type === 'main') {
                return this.mainConfig.initial;
            }
            else if (type === 'side') {
                return this.sideConfig.initial;
            }
            else {
                return void 0;
            }
        };
        DrawerSizeController.prototype.getMinWidth = function (type) {
            var _a, _b;
            if (type === 'main') {
                return (_a = this.mainConfig.min) !== null && _a !== void 0 ? _a : 0;
            }
            else if (type === 'side') {
                return (_b = this.sideConfig.min) !== null && _b !== void 0 ? _b : 0;
            }
            else {
                return 0;
            }
        };
        DrawerSizeController.prototype.getMaxWidth = function (type) {
            var _a, _b;
            if (type === 'main') {
                return (_a = this.mainConfig.max) !== null && _a !== void 0 ? _a : window.innerWidth;
            }
            else if (type === 'side') {
                return (_b = this.sideConfig.max) !== null && _b !== void 0 ? _b : window.innerWidth;
            }
            else {
                return window.innerWidth;
            }
        };
        /**
         * Update width from outside with all calculations to be done
         * @param width
         */
        DrawerSizeController.prototype.updateMainWidth = function (width) {
            var sideWidth = (this.sideElRef && this.sideElRef.width) || 0;
            this.mainElRef.updateWidth(sideWidth + width);
        };
        /**
         * Update width from outside with all calculations to be done
         * @param width
         */
        DrawerSizeController.prototype.updateSideWidth = function (width) {
            if (this.sideElRef) {
                var currentWidth = this.mainElRef.width - this.sideElRef.width;
                this.mainElRef.updateWidth(currentWidth + width);
                this.sideElRef.updateWidth(width);
            }
        };
        /**
         * Push current drawer to be visible under new one opened
         * @param inFrontDrawer
         */
        DrawerSizeController.prototype.pushMainWidth = function (inFrontDrawer) {
            var inFrontDrawerTotalWidth = inFrontDrawer.resizeController.mainElRef.width
                + MAIN_RESIZE_ACTION_BAR_WIDTH;
            if (this.mainElRef.width <= inFrontDrawerTotalWidth) {
                this.updateMainWidth(inFrontDrawerTotalWidth);
            }
        };
        /**
         * Listen for browser resize and update restrictions
         */
        DrawerSizeController.prototype._listenWindowResize = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                rxjs.fromEvent(window, 'resize')
                    .pipe(operators.debounceTime(50), operators.takeUntil(_this._destroy$))
                    .subscribe(function () {
                    _this._updateScreenWidth();
                    _this._updateMinMaxStyles();
                });
            });
        };
        /**
         * Copy initial configs or set default values
         */
        DrawerSizeController.prototype._initDefaultConfigs = function () {
            // Main initialization
            this._mainConfig =
                (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.main)
                    || {};
            this._mainConfig.initial = this.persistedMainWidth
                || this._mainConfig.initial
                || MAIN_DRAWER_DEFAULT_WIDTH;
            // Side initialization
            this._sideConfig =
                (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.side)
                    || {};
            this._sideConfig.initial = this.persistedSideWidth
                || this._sideConfig.initial
                || SIDE_DRAWER_DEFAULT_WIDTH;
        };
        DrawerSizeController.prototype._registerMainRef = function (el) {
            this._mainElRef = el;
        };
        DrawerSizeController.prototype._registerSideRef = function (el) {
            this._sideElRef = el;
        };
        DrawerSizeController.prototype._removeMainRef = function () {
            this._mainElRef = null;
        };
        DrawerSizeController.prototype._removeSideRef = function () {
            this._sideElRef = null;
        };
        /**
         * Update current window size
         */
        DrawerSizeController.prototype._updateScreenWidth = function () {
            this._screenWidth = (window.innerWidth - this._borderPadding);
        };
        /**
         * Update min&max css props for containers
         */
        DrawerSizeController.prototype._updateMinMaxStyles = function () {
            this.mainElRef.setMinMaxStyles();
            if (this.sideElRef) {
                this.sideElRef.setMinMaxStyles();
            }
        };
        DrawerSizeController.prototype._listenSideToggle = function () {
            var _this = this;
            this._drawerRef.sideToggle$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (opened) {
                if (_this._sideOpened === opened) {
                    return;
                }
                _this._sideOpened = opened;
                if (opened) {
                    var currentWidth = _this.mainElRef.width;
                    var sideWidth = _this.getInitialWidth('side');
                    _this._mainElRef.updateWidth(currentWidth + sideWidth + SIDE_RESIZE_BAR_WIDTH);
                }
                else {
                    var actualSideWidth = _this.sideElRef.fsDrawerResizer.getBoundingClientRect().width;
                    var mainWidth = _this.mainElRef.width - actualSideWidth - SIDE_RESIZE_BAR_WIDTH;
                    _this._mainElRef.updateWidth(mainWidth);
                }
            });
        };
        DrawerSizeController.prototype._listenWidthChanges = function (el) {
            var _this = this;
            if (!this._persistanceController.enabled) {
                return;
            }
            el.width$
                .pipe(operators.debounceTime(200), operators.filter(function () {
                return _this._drawerStore.getLevelForRef(el.drawerRef) === _this._drawerStore.numberOfOpenedDrawers;
            }))
                .subscribe({
                next: function () {
                    var _a;
                    var sideWidth = ((_a = _this._sideElRef) === null || _a === void 0 ? void 0 : _a.width) || 0;
                    if (_this._mainElRef) {
                        _this._persistanceController.saveDataToScope('mainWidth', _this._mainElRef.width - sideWidth - SIDE_RESIZE_BAR_WIDTH);
                    }
                    if (_this._sideElRef) {
                        _this._persistanceController.saveDataToScope('sideWidth', sideWidth);
                    }
                }
            });
        };
        return DrawerSizeController;
    }());
    DrawerSizeController.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerSizeController, deps: [{ token: DrawerRef }, { token: i0__namespace.NgZone }, { token: FsDrawerPersistanceController }, { token: DrawerStoreService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    DrawerSizeController.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerSizeController });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: DrawerSizeController, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: DrawerRef }, { type: i0__namespace.NgZone }, { type: FsDrawerPersistanceController }, { type: DrawerStoreService }]; } });

    var FsDrawerResizerDirective = /** @class */ (function () {
        function FsDrawerResizerDirective(_el, _renderer, _ngZone, _drawerRef) {
            this._el = _el;
            this._renderer = _renderer;
            this._ngZone = _ngZone;
            this._drawerRef = _drawerRef;
            this.fsDrawerResizer = this._el.nativeElement;
            this.direction = 'left';
            this.resizable = true;
            this._dragStartHandler = this._dragStart.bind(this);
            this._dragHandler = this._drag.bind(this);
            this._dragEndHandler = this._dragEnd.bind(this);
            this._x = 0;
            this._width$ = new rxjs.BehaviorSubject(0);
            this._actionsWidth = 0;
            this._destroy$ = new rxjs.Subject();
        }
        Object.defineProperty(FsDrawerResizerDirective.prototype, "drawerRef", {
            get: function () {
                return this._drawerRef;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "isMainDrawer", {
            get: function () {
                return this.type === 'main';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "isSideDrawer", {
            get: function () {
                return this.type === 'side';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "width", {
            get: function () {
                return this._width$.getValue();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "width$", {
            get: function () {
                return this._width$.pipe(operators.takeUntil(this._destroy$));
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "minWidth", {
            get: function () {
                var minWidth = this.sizeController.getMinWidth(this.type);
                if (minWidth && minWidth >= 0) {
                    var screenWidth = this.sizeController.screenWidth;
                    var barWidth = this.barWidth;
                    if (screenWidth - minWidth < barWidth) {
                        return this.sizeController.screenWidth - barWidth;
                    }
                    else {
                        return minWidth;
                    }
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "maxWidth", {
            get: function () {
                var maxWidth = this.sizeController.getMaxWidth(this.type);
                var parentContainerWidth = null;
                if (this.parentContainer) {
                    parentContainerWidth = this._getElementWidth(this.parentContainer.nativeElement);
                }
                if (parentContainerWidth !== null) {
                    return !maxWidth || maxWidth >= parentContainerWidth
                        ? parentContainerWidth - this._actionsWidth * 2
                        : maxWidth;
                }
                else {
                    return !maxWidth || maxWidth >= this.sizeController.screenWidth
                        ? this.sizeController.screenWidth
                        : maxWidth;
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FsDrawerResizerDirective.prototype, "barWidth", {
            get: function () {
                return this.isMainDrawer
                    ? MAIN_RESIZE_ACTION_BAR_WIDTH
                    : SIDE_RESIZE_BAR_WIDTH;
            },
            enumerable: false,
            configurable: true
        });
        FsDrawerResizerDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.sizeController.registerElRef(this);
            if (this.resizable) {
                this._ngZone.runOutsideAngular(function () {
                    _this._el.nativeElement.addEventListener('mousedown', _this._dragStartHandler, false);
                    _this._el.nativeElement.addEventListener('touchstart', _this._dragStartHandler, false);
                });
                if (this.actionsContainer) {
                    this._actionsWidth = this._getElementWidth(this.actionsContainer.nativeElement);
                }
                this.setMinMaxStyles();
                var minWidth = this.sizeController.getMinWidth(this.type);
                var width = this.sizeController.getInitialWidth(this.type)
                    || this._getElementWidth(this.fsDrawerResizer);
                if (width < minWidth) {
                    width = minWidth;
                }
                this.updateWidth(width);
            }
        };
        FsDrawerResizerDirective.prototype.updateWidth = function (width) {
            var _this = this;
            var minConfiguredWidth = this.sizeController.getMinWidth(this.type);
            var maxConfiguredWidth = this.sizeController.getMaxWidth(this.type);
            var availableWidth = this.sizeController.screenWidth;
            // newWidth should not be
            // greater than maxConfiguredWidth
            // and not lesser than minConfiguredWidth
            width = Math.max(minConfiguredWidth, Math.min(width, maxConfiguredWidth));
            // and sure it shouldn't be greater than screen width
            width = Math.min(width, availableWidth);
            if (width === this.width) {
                return;
            }
            this._width$.next(width);
            requestAnimationFrame(function () {
                _this._renderer.setStyle(_this.fsDrawerResizer, 'width', width + "px");
            });
        };
        FsDrawerResizerDirective.prototype.ngOnDestroy = function () {
            this._el.nativeElement.removeEventListener('mousedown', this._dragStartHandler, false);
            this._el.nativeElement.removeEventListener('touchstart', this._dragStartHandler, false);
            this.sizeController.removeElRef(this);
            this._destroy$.next();
            this._destroy$.complete();
        };
        /**
         * Set inline styles min/max width
         */
        FsDrawerResizerDirective.prototype.setMinMaxStyles = function () {
            var _this = this;
            requestAnimationFrame(function () {
                _this._renderer.setStyle(_this.fsDrawerResizer, 'min-width', _this.minWidth + "px");
                _this._renderer.setStyle(_this.fsDrawerResizer, 'max-width', _this.maxWidth + "px");
            });
        };
        /**
         * Subscribe to move events and init base dimensions/restrictions
         * @param event { MouseEvent }
         */
        FsDrawerResizerDirective.prototype._dragStart = function (event) {
            this._x = this._getClientX(event);
            this.updateWidth(this._getElementWidth(this.fsDrawerResizer));
            this.setMinMaxStyles();
            document.addEventListener('touchmove', this._dragHandler, false);
            document.addEventListener('touchend', this._dragEndHandler, false);
            document.addEventListener('mousemove', this._dragHandler, false);
            document.addEventListener('mouseup', this._dragEndHandler, false);
        };
        /**
         * Update coordinates during drag
         * @param event
         */
        FsDrawerResizerDirective.prototype._drag = function (event) {
            var clientX = this._getClientX(event);
            var predictedWidth = this._calcWidth(this.direction, clientX);
            this._updatePosition(clientX, predictedWidth);
            // this._emitResizeEvent();
        };
        /**
         * Remove listeners when drag finished
         * @param event
         */
        FsDrawerResizerDirective.prototype._dragEnd = function (event) {
            document.removeEventListener('mousemove', this._dragHandler, false);
            document.removeEventListener('mouseup', this._dragEndHandler, false);
            document.removeEventListener('touchmove', this._dragHandler, false);
            document.removeEventListener('touchend', this._dragEndHandler, false);
        };
        /**
         *
         * @param event
         */
        FsDrawerResizerDirective.prototype._getClientX = function (event) {
            return event.touches ? event.touches[0].clientX : event.clientX;
        };
        /**
         * Will return width of element
         * @param el
         */
        FsDrawerResizerDirective.prototype._getElementWidth = function (el) {
            return el.getBoundingClientRect().width;
        };
        /**
         * Update width and position of target element
         * @param clientX
         * @param width
         */
        FsDrawerResizerDirective.prototype._updatePosition = function (clientX, width) {
            this._x = clientX;
            this.updateWidth(width < 0 ? 0 : width);
        };
        /**
         * Calc new width based on offset from previous position
         * @param direction
         * @param clientX
         */
        FsDrawerResizerDirective.prototype._calcWidth = function (direction, clientX) {
            var directionSign = direction === 'left' ? -1 : 1;
            return this.width + (this._x - clientX) * directionSign;
        };
        return FsDrawerResizerDirective;
    }());
    FsDrawerResizerDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerResizerDirective, deps: [{ token: i0__namespace.ElementRef }, { token: i0__namespace.Renderer2 }, { token: i0__namespace.NgZone }, { token: DrawerRef }], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsDrawerResizerDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: { fsDrawerResizer: "fsDrawerResizer", type: "type", direction: "direction", resizable: "resizable", parentContainer: "parentContainer", actionsContainer: "actionsContainer", sizeController: "sizeController" }, host: { properties: { "style.cursor": "\"col-resize\"" } }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerResizerDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsDrawerResizer]',
                        host: {
                            '[style.cursor]': '"col-resize"',
                        }
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.NgZone }, { type: DrawerRef }]; }, propDecorators: { fsDrawerResizer: [{
                    type: i0.Input
                }], type: [{
                    type: i0.Input
                }], direction: [{
                    type: i0.Input
                }], resizable: [{
                    type: i0.Input
                }], parentContainer: [{
                    type: i0.Input
                }], actionsContainer: [{
                    type: i0.Input
                }], sizeController: [{
                    type: i0.Input
                }] } });

    var FsDrawerComponent = /** @class */ (function (_super) {
        __extends(FsDrawerComponent, _super);
        function FsDrawerComponent(_el, _drawerMenu, _drawerRef, _cdRef, _resizeController, _persistanceController, _location) {
            var _this = _super.call(this) || this;
            _this._el = _el;
            _this._drawerMenu = _drawerMenu;
            _this._drawerRef = _drawerRef;
            _this._cdRef = _cdRef;
            _this._resizeController = _resizeController;
            _this._persistanceController = _persistanceController;
            _this._location = _location;
            _this.isOpen = false;
            _this.isOpenSide = false;
            _this.initialized = false;
            _this._sideOpen = false;
            _this._destroy$ = new rxjs.Subject();
            _this._drawerRef.resizeController = _this._resizeController;
            return _this;
        }
        Object.defineProperty(FsDrawerComponent.prototype, "sideOpen", {
            get: function () {
                return this._sideOpen;
            },
            set: function (value) {
                this._sideOpen = value;
                this._el.nativeElement.classList
                    .toggle('side-open', this.sideOpen);
            },
            enumerable: false,
            configurable: true
        });
        FsDrawerComponent.prototype.ngOnInit = function () {
            this._listenDataChanges();
            this.config = this.drawerRef.drawerConfig;
            if (this.config.persist) {
                var namespace = common.getNormalizedPath(this._location);
                this._persistanceController.setConfig(this.config.persist, namespace);
            }
            this._resizeController.init();
        };
        FsDrawerComponent.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerComponent.prototype.open = function () {
            this.isOpen = true;
        };
        FsDrawerComponent.prototype.close = function () {
            this.isOpen = false;
        };
        FsDrawerComponent.prototype.openSide = function () {
            this.isOpenSide = true;
        };
        FsDrawerComponent.prototype.closeSide = function () {
            this.isOpenSide = false;
        };
        FsDrawerComponent.prototype.setDrawerRef = function (value) {
            var _this = this;
            this.drawerRef = value;
            // Need to be like a parent for children resize
            this.drawerRef.drawerContainer = this._drawerContainer;
            this.drawerRef.drawerActionsContainer = this._drawerActionsContainer;
            this.drawerRef.sideToggle$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function (opened) {
                _this.sideOpen = opened;
            });
            this.initialized = true;
        };
        /**
         * Attach a ComponentPortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerComponent.prototype.attachComponentPortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer component already attached');
            }
            return this._portalOutlet.attachComponentPortal(portal);
        };
        /**
         * Attach a TemplatePortal as content to this dialog container.
         * @param portal Portal to be attached as the dialog content.
         */
        FsDrawerComponent.prototype.attachTemplatePortal = function (portal) {
            if (this._portalOutlet.hasAttached()) {
                throw Error('Drawer template already attached');
            }
            return this._portalOutlet.attachTemplatePortal(portal);
        };
        FsDrawerComponent.prototype._listenDataChanges = function () {
            var _this = this;
            this._drawerRef.dataChanged$
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._cdRef.detectChanges();
            });
        };
        return FsDrawerComponent;
    }(i1.BasePortalOutlet));
    FsDrawerComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerComponent, deps: [{ token: i0__namespace.ElementRef }, { token: FsDrawerMenuService }, { token: DrawerRef }, { token: i0__namespace.ChangeDetectorRef }, { token: DrawerSizeController }, { token: FsDrawerPersistanceController }, { token: i5__namespace.Location }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerComponent, selector: "fs-drawer", host: { classAttribute: "fs-drawer-container" }, providers: [
            FsDrawerMenuService,
            FsDrawerPersistanceController,
            DrawerSizeController,
        ], viewQueries: [{ propertyName: "_portalOutlet", first: true, predicate: i1.CdkPortalOutlet, descendants: true, static: true }, { propertyName: "_drawerContainer", first: true, predicate: ["drawerContainer"], descendants: true, static: true }, { propertyName: "_drawerActionsContainer", first: true, predicate: ["drawerActionsContainer"], descendants: true, read: i0.ElementRef, static: true }], usesInheritance: true, ngImport: i0__namespace, template: "<div class=\"mat-elevation-z2 drawer\" #drawer\n     hidden\n     [ngClass]=\"config.position\"\n     [hidden]=\"!initialized\">\n  <ng-container>\n    <fs-drawer-actions class=\"drawer-actions\"\n                       #drawerActionsContainer\n                       type=\"main\"\n                       [fsDrawerResizer]=\"drawer\"\n                       [resizable]=\"drawerRef.drawerConfig.resizable\"\n                       [sizeController]=\"drawerRef.resizeController\"\n                       [direction]=\"config.position\"\n                       [actions]=\"config.actions\"\n                       [activeAction]=\"drawerRef.activeAction$ | async\">\n    </fs-drawer-actions>\n    <div class=\"drawer-container\" #drawerContainer>\n      <ng-template cdkPortalOutlet></ng-template>\n    </div>\n  </ng-container>\n</div>\n", components: [{ type: FsDrawerActionsComponent, selector: "fs-drawer-actions", inputs: ["actions", "activeAction"] }], directives: [{ type: i5__namespace.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: ["fsDrawerResizer", "type", "direction", "resizable", "parentContainer", "actionsContainer", "sizeController"] }, { type: i1__namespace.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }], pipes: { "async": i5__namespace.AsyncPipe }, changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush, encapsulation: i0__namespace.ViewEncapsulation.None });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: 'fs-drawer',
                        templateUrl: './drawer.component.html',
                        providers: [
                            FsDrawerMenuService,
                            FsDrawerPersistanceController,
                            DrawerSizeController,
                        ],
                        host: {
                            'class': 'fs-drawer-container',
                        },
                        encapsulation: i0.ViewEncapsulation.None,
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ElementRef }, { type: FsDrawerMenuService }, { type: DrawerRef }, { type: i0__namespace.ChangeDetectorRef }, { type: DrawerSizeController }, { type: FsDrawerPersistanceController }, { type: i5__namespace.Location }]; }, propDecorators: { _portalOutlet: [{
                    type: i0.ViewChild,
                    args: [i1.CdkPortalOutlet, { static: true }]
                }], _drawerContainer: [{
                    type: i0.ViewChild,
                    args: ['drawerContainer', { static: true }]
                }], _drawerActionsContainer: [{
                    type: i0.ViewChild,
                    args: ['drawerActionsContainer', { read: i0.ElementRef, static: true }]
                }] } });

    var FsDrawerActionDirective = /** @class */ (function () {
        function FsDrawerActionDirective() {
        }
        return FsDrawerActionDirective;
    }());
    FsDrawerActionDirective.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionDirective, deps: [], target: i0__namespace.ɵɵFactoryTarget.Directive });
    FsDrawerActionDirective.ɵdir = i0__namespace.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionDirective, selector: "[fsDrawerAction]", inputs: { name: ["fsDrawerAction", "name"] }, ngImport: i0__namespace });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerActionDirective, decorators: [{
                type: i0.Directive,
                args: [{
                        selector: '[fsDrawerAction]',
                    }]
            }], propDecorators: { name: [{
                    type: i0.Input,
                    args: ['fsDrawerAction']
                }] } });

    var FsDrawerSideComponent = /** @class */ (function () {
        function FsDrawerSideComponent(_cdRef, _renderer, _elRef) {
            this._cdRef = _cdRef;
            this._renderer = _renderer;
            this._elRef = _elRef;
            this.classSide = true;
            this.activeTemplate = null;
            this._hidden = false;
            this._destroy$ = new i0.EventEmitter();
        }
        Object.defineProperty(FsDrawerSideComponent.prototype, "hidden", {
            set: function (value) {
                this._hidden = value;
                if (this._hidden) {
                    this._renderer.setAttribute(this._elRef.nativeElement, 'hidden', 'true');
                }
                else {
                    this._renderer.removeAttribute(this._elRef.nativeElement, 'hidden');
                }
            },
            enumerable: false,
            configurable: true
        });
        FsDrawerSideComponent.prototype.ngOnInit = function () {
            this.hidden = true;
            if (!this.drawer) {
                console.error('Drawer reference is null for @Input("fsDrawerSide")');
            }
            this._subscribeToActionChanges();
        };
        FsDrawerSideComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            setTimeout(function () {
                // Check current side status
                if (_this.drawer) {
                    _this.hidden = !_this.drawer.isSideOpen;
                }
                _this._updateActiveActionTemplate();
                _this._cdRef.detectChanges();
            });
        };
        FsDrawerSideComponent.prototype.ngOnDestroy = function () {
            this._destroy$.emit();
            this._destroy$.complete();
        };
        FsDrawerSideComponent.prototype._subscribeToActionChanges = function () {
            var _this = this;
            if (this.drawer) {
                this.drawer.sideToggle$
                    .pipe(operators.takeUntil(this._destroy$))
                    .subscribe(function () {
                    _this.hidden = !_this.drawer.isSideOpen;
                    _this._updateActiveActionTemplate();
                    _this._cdRef.detectChanges();
                });
            }
        };
        FsDrawerSideComponent.prototype._updateActiveActionTemplate = function () {
            if (this.drawer) {
                var activatedAction_1 = this.drawer.activeAction;
                if (this.drawer.isSideOpen && activatedAction_1) {
                    var selectedActionIndex = this.actions
                        .toArray()
                        .findIndex(function (action) { return action.name === activatedAction_1; });
                    this.activeTemplate = this.actionsTemplates.toArray()[selectedActionIndex];
                }
                else {
                    this.activeTemplate = null;
                }
            }
        };
        return FsDrawerSideComponent;
    }());
    FsDrawerSideComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerSideComponent, deps: [{ token: i0__namespace.ChangeDetectorRef }, { token: i0__namespace.Renderer2 }, { token: i0__namespace.ElementRef }], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerSideComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerSideComponent, selector: "[fsDrawerSide]", inputs: { drawer: ["fsDrawerSide", "drawer"] }, host: { properties: { "class.side": "this.classSide" } }, queries: [{ propertyName: "actions", predicate: FsDrawerActionDirective }, { propertyName: "actionsTemplates", predicate: FsDrawerActionDirective, read: i0.TemplateRef }], ngImport: i0__namespace, template: "<ng-container [ngSwitch]=\"drawer.drawerConfig.position\" *ngIf=\"activeTemplate\">\n  <ng-container *ngSwitchCase=\"'right'\">\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"left\"\n         type=\"side\"\n         [fsDrawerResizer]=\"sideContainer\"\n         [resizable]=\"drawer.drawerConfig.resizable\"\n         [sizeController]=\"drawer.resizeController\"\n         [parentContainer]=\"drawer.drawerContainer\"\n         [actionsContainer]=\"drawer.drawerActionsContainer\"\n    >\n      <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'left'\">\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"right\"\n         [fsDrawerResizer]=\"sideContainer\"\n    >\n    <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", styles: [".resize-icon{width:45px;height:45px;line-height:45px}.resize-icon span{width:45px}\n"], components: [{ type: i2__namespace$1.MatAnchor, selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matButton", "matAnchor"] }, { type: i4__namespace.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5__namespace.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5__namespace.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i5__namespace.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i5__namespace.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: ["fsDrawerResizer", "type", "direction", "resizable", "parentContainer", "actionsContainer", "sizeController"] }], changeDetection: i0__namespace.ChangeDetectionStrategy.OnPush });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerSideComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: '[fsDrawerSide]',
                        templateUrl: './drawer-side.component.html',
                        changeDetection: i0.ChangeDetectionStrategy.OnPush,
                        styleUrls: [
                            './drawer-side.component.scss',
                        ],
                    }]
            }], ctorParameters: function () { return [{ type: i0__namespace.ChangeDetectorRef }, { type: i0__namespace.Renderer2 }, { type: i0__namespace.ElementRef }]; }, propDecorators: { drawer: [{
                    type: i0.Input,
                    args: ['fsDrawerSide']
                }], classSide: [{
                    type: i0.HostBinding,
                    args: ['class.side']
                }], actions: [{
                    type: i0.ContentChildren,
                    args: [FsDrawerActionDirective]
                }], actionsTemplates: [{
                    type: i0.ContentChildren,
                    args: [FsDrawerActionDirective, { read: i0.TemplateRef }]
                }] } });

    var FsDrawerContentComponent = /** @class */ (function () {
        function FsDrawerContentComponent() {
        }
        return FsDrawerContentComponent;
    }());
    FsDrawerContentComponent.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerContentComponent, deps: [], target: i0__namespace.ɵɵFactoryTarget.Component });
    FsDrawerContentComponent.ɵcmp = i0__namespace.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerContentComponent, selector: "[fsDrawerContent]", host: { classAttribute: "content-container" }, ngImport: i0__namespace, template: '<div class="content"><ng-content></ng-content></div>', isInline: true });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerContentComponent, decorators: [{
                type: i0.Component,
                args: [{
                        selector: '[fsDrawerContent]',
                        template: '<div class="content"><ng-content></ng-content></div>',
                        host: {
                            'class': 'content-container'
                        }
                    }]
            }] });

    var FsDrawerModule = /** @class */ (function () {
        function FsDrawerModule() {
        }
        return FsDrawerModule;
    }());
    FsDrawerModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    FsDrawerModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerModule, declarations: [FsDrawerSideComponent,
            FsDrawerComponent,
            FsDrawerActionsComponent,
            FsDrawerActionItemComponent,
            FsDrawerContentComponent,
            FsDrawerActionDirective,
            FsDrawerResizerDirective,
            FsDrawerMenuComponent], imports: [i5.CommonModule,
            i6.MatTooltipModule,
            i2$1.MatButtonModule,
            i4.MatIconModule,
            i1$1.OverlayModule,
            i1.PortalModule,
            i3.FsMenuModule,
            menu.MatMenuModule], exports: [FsDrawerComponent,
            FsDrawerSideComponent,
            FsDrawerContentComponent,
            FsDrawerActionDirective,
            FsDrawerResizerDirective] });
    FsDrawerModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerModule, imports: [[
                i5.CommonModule,
                i6.MatTooltipModule,
                i2$1.MatButtonModule,
                i4.MatIconModule,
                i1$1.OverlayModule,
                i1.PortalModule,
                i3.FsMenuModule,
                menu.MatMenuModule,
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i5.CommonModule,
                            i6.MatTooltipModule,
                            i2$1.MatButtonModule,
                            i4.MatIconModule,
                            i1$1.OverlayModule,
                            i1.PortalModule,
                            i3.FsMenuModule,
                            menu.MatMenuModule,
                        ],
                        exports: [
                            FsDrawerComponent,
                            FsDrawerSideComponent,
                            FsDrawerContentComponent,
                            FsDrawerActionDirective,
                            FsDrawerResizerDirective,
                        ],
                        declarations: [
                            FsDrawerSideComponent,
                            FsDrawerComponent,
                            FsDrawerActionsComponent,
                            FsDrawerActionItemComponent,
                            FsDrawerContentComponent,
                            FsDrawerActionDirective,
                            FsDrawerResizerDirective,
                            FsDrawerMenuComponent,
                        ],
                    }]
            }] });

    /** Injection token that can be used to access the data that was passed in to a drawer. */
    var DRAWER_DATA = new i0.InjectionToken('DrawerData');

    var DRAWER_DEFAULT_CONFIG = new i0.InjectionToken('fs.drawer-default-config');

    var FsDrawerService = /** @class */ (function () {
        function FsDrawerService(_parentDrawerService, _defaultConfig, _overlay, _injector, _drawerStore) {
            this._parentDrawerService = _parentDrawerService;
            this._defaultConfig = _defaultConfig;
            this._overlay = _overlay;
            this._injector = _injector;
            this._drawerStore = _drawerStore;
            this._destroy$ = new rxjs.Subject();
        }
        FsDrawerService.prototype.ngOnDestroy = function () {
            this._destroy$.next();
            this._destroy$.complete();
        };
        FsDrawerService.prototype.open = function (component, config) {
            var _this = this;
            var overlayRef = this._createOverlay();
            var dataFactory = DrawerData.createWithProxy(config.data);
            delete config.data;
            config = lodashEs.merge({}, this._defaultConfig || {}, config);
            var drawerRef = new DrawerRef(overlayRef, dataFactory, config);
            var containerRef = this._attachDrawerContainer(overlayRef, drawerRef, dataFactory);
            var componentRef = this._attachComponent(component, containerRef, drawerRef, dataFactory);
            drawerRef.containerRef = containerRef;
            containerRef.setDrawerRef(drawerRef);
            drawerRef.componentRef = componentRef;
            drawerRef.events();
            drawerRef.open();
            this._storeDrawerRef(drawerRef);
            rxjs.merge(drawerRef.afterOpened$, drawerRef.afterClosed$)
                .pipe(operators.takeUntil(this._destroy$))
                .subscribe(function () {
                setTimeout(function () {
                    _this._applyBackdrop();
                    _this._applyBodyOpenClass();
                });
            });
            return drawerRef;
        };
        FsDrawerService.prototype.closeAll = function () {
            this._drawerStore.drawerRefs
                .forEach(function (ref) { return ref.close(); });
            if (this._parentDrawerService) {
                this._parentDrawerService.closeAll();
            }
        };
        FsDrawerService.prototype._applyBackdrop = function () {
            var _this = this;
            Array.from(this._drawerStore.drawerRefs)
                .forEach(function (drawerRef, index) {
                var backdrop = drawerRef.overlayRef.backdropElement;
                if (backdrop) {
                    if (index && index === (_this._drawerStore.numberOfOpenedDrawers - 1)) {
                        backdrop.classList.add('fs-drawer-backdrop-active');
                    }
                    else {
                        backdrop.classList.remove('fs-drawer-backdrop-active');
                    }
                }
            });
        };
        FsDrawerService.prototype._applyBodyOpenClass = function () {
            if (this._drawerStore.numberOfOpenedDrawers) {
                document.body.classList.add('fs-drawer-open');
            }
            else {
                document.body.classList.remove('fs-drawer-open');
            }
        };
        FsDrawerService.prototype._storeDrawerRef = function (ref) {
            var _this = this;
            this._drawerStore.addRef(ref);
            ref.destroy$
                .pipe(operators.take(1), operators.takeUntil(this._destroy$))
                .subscribe(function () {
                _this._drawerStore.deleteRef(ref);
            });
        };
        FsDrawerService.prototype._createOverlay = function () {
            var overlayConfig = this._getOverlayConfig();
            return this._overlay.create(overlayConfig);
        };
        FsDrawerService.prototype._getOverlayConfig = function () {
            return new i1$1.OverlayConfig({
                hasBackdrop: true,
                backdropClass: 'fs-drawer-backdrop'
            });
        };
        FsDrawerService.prototype._attachDrawerContainer = function (overlayRef, drawerRef, dataFactory) {
            var injector = this._createInjector(drawerRef, dataFactory);
            var containerPortal = new i1.ComponentPortal(FsDrawerComponent, undefined, injector);
            var containerRef = overlayRef.attach(containerPortal);
            return containerRef.instance;
        };
        FsDrawerService.prototype._attachComponent = function (componentRef, drawerContainer, drawerRef, dataFactory) {
            var injector = this._createInjector(drawerRef, dataFactory);
            return drawerContainer.attachComponentPortal(new i1.ComponentPortal(componentRef, undefined, injector));
        };
        FsDrawerService.prototype._createInjector = function (componentRef, dataFactory) {
            var injectionTokens = new WeakMap([
                [DrawerRef, componentRef],
                [DRAWER_DATA, dataFactory]
            ]);
            return new i1.PortalInjector(this._injector, injectionTokens);
        };
        return FsDrawerService;
    }());
    FsDrawerService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerService, deps: [{ token: FsDrawerService, optional: true, skipSelf: true }, { token: DRAWER_DEFAULT_CONFIG, optional: true }, { token: i1__namespace$1.Overlay }, { token: i0__namespace.Injector }, { token: DrawerStoreService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    FsDrawerService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerService, providedIn: 'root' });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0__namespace, type: FsDrawerService, decorators: [{
                type: i0.Injectable,
                args: [{
                        providedIn: 'root',
                    }]
            }], ctorParameters: function () {
            return [{ type: FsDrawerService, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.SkipSelf
                        }] }, { type: undefined, decorators: [{
                            type: i0.Optional
                        }, {
                            type: i0.Inject,
                            args: [DRAWER_DEFAULT_CONFIG]
                        }] }, { type: i1__namespace$1.Overlay }, { type: i0__namespace.Injector }, { type: DrawerStoreService }];
        } });

    /*
     * Public API Surface of fs-menu
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DRAWER_DATA = DRAWER_DATA;
    exports.DRAWER_DEFAULT_CONFIG = DRAWER_DEFAULT_CONFIG;
    exports.DRAWER_MENU_DATA = DRAWER_MENU_DATA;
    exports.DrawerData = DrawerData;
    exports.DrawerMenuRef = DrawerMenuRef;
    exports.DrawerRef = DrawerRef;
    exports.FsDrawerActionDirective = FsDrawerActionDirective;
    exports.FsDrawerComponent = FsDrawerComponent;
    exports.FsDrawerContentComponent = FsDrawerContentComponent;
    exports.FsDrawerModule = FsDrawerModule;
    exports.FsDrawerResizerDirective = FsDrawerResizerDirective;
    exports.FsDrawerService = FsDrawerService;
    exports.FsDrawerSideComponent = FsDrawerSideComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=firestitch-drawer.umd.js.map
