import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ViewChild, InjectionToken, ElementRef, Injectable, EventEmitter, Input, Output, Directive, ViewEncapsulation, TemplateRef, HostBinding, ContentChildren, NgModule, Optional, SkipSelf, Inject } from '@angular/core';
import * as i5 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1 from '@angular/cdk/portal';
import { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, PortalInjector, PortalModule } from '@angular/cdk/portal';
import * as i1$1 from '@angular/cdk/overlay';
import { OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import * as i2$1 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i4 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import { MatMenuModule } from '@angular/material/menu';
import * as i6 from '@angular/material/tooltip';
import { MatTooltipModule } from '@angular/material/tooltip';
import * as i3 from '@firestitch/menu';
import { FsMenuModule } from '@firestitch/menu';
import { Subject, BehaviorSubject, Observable, zip, fromEvent, merge as merge$1 } from 'rxjs';
import { ESCAPE } from '@angular/cdk/keycodes';
import { takeUntil, switchMap, map, filter, take, debounceTime } from 'rxjs/operators';
import * as i2 from '@angular/cdk/layout';
import { Breakpoints } from '@angular/cdk/layout';
import { FsPersistanceStore } from '@firestitch/store';
import { getNormalizedPath } from '@firestitch/common';
import { merge } from 'lodash-es';

var FsDrawerAction;
(function (FsDrawerAction) {
    FsDrawerAction["Button"] = "button";
    FsDrawerAction["Menu"] = "menu";
    FsDrawerAction["Component"] = "component";
})(FsDrawerAction || (FsDrawerAction = {}));

class BaseAction {
    constructor(data = {}) {
        this._visible = true;
        this._icon = data.icon || '';
        this._click = data.click || null;
        this._link = data.link;
        this._show = data.show || null;
    }
    get icon() {
        return this._icon;
    }
    get click() {
        return this._click;
    }
    get routerLink() {
        return this._routerLink;
    }
    get visible() {
        return this._visible;
    }
    checkVisibility(data) {
        if (this._show) {
            this._visible = this._show(data);
        }
    }
    updateRouterLink(data) {
        if (this._visible && this._link) {
            this._routerLink = this._link(data);
        }
    }
}

class MenuAction extends BaseAction {
    constructor(data = {}) {
        super(data);
        this.actions = [];
        this._isGroup = false;
        if (Array.isArray(data.actions)) {
            this._isGroup = true;
            this.actions = data.actions.map((action) => new MenuAction(action));
        }
        this._label = data.label || '';
    }
    get isGroup() {
        return this._isGroup;
    }
    get label() {
        return this._label;
    }
    updateRouterLink(data) {
        super.updateRouterLink(data);
        if (this.actions.length > 0) {
            this.actions.forEach((action) => {
                action.updateRouterLink(data);
            });
        }
    }
    checkVisibility(data) {
        super.checkVisibility(data);
        if (this.actions.length > 0) {
            this.actions.forEach((action) => {
                action.checkVisibility(data);
            });
        }
        if (this.actions.length > 0) {
            this._visible = this.actions.some((action) => action.visible);
        }
    }
}

class Action extends BaseAction {
    constructor(data = {}) {
        var _a;
        super(data);
        this._data = null;
        this._disabled = false;
        this._close = false;
        this._closeSide = true;
        this._menuActions = [];
        this._component = null;
        this._menuRefName = null;
        this._icon = data.icon || '';
        this._type = data.type || '';
        this._name = data.name || '';
        this._toggle = data.toggle === void 0 ? true : data.toggle;
        this._tooltip = data.tooltip || '';
        this._close = !!data.close;
        this._component = data.component || null;
        this._data = data.data === void 0 ? {} : data.data;
        this._disabled = (_a = data.disabled) !== null && _a !== void 0 ? _a : false;
        if (this._type === FsDrawerAction.Component) {
            this._menuRefName = data.name || data.icon;
        }
        if (this._type === FsDrawerAction.Menu && data.closeSide === void 0) {
            this._closeSide = false;
        }
        else {
            this._closeSide = data.closeSide === void 0 ? true : !!data.closeSide;
        }
        if (Array.isArray(data.actions)) {
            this._menuActions = data.actions.map((action) => new MenuAction(action));
        }
    }
    get icon() {
        return this._icon;
    }
    set icon(value) {
        this._icon = value;
    }
    get type() {
        return this._type;
    }
    get toggle() {
        return this._toggle;
    }
    get name() {
        return this._name;
    }
    get tooltip() {
        return this._tooltip;
    }
    set tooltip(value) {
        this._tooltip = value;
    }
    get close() {
        return this._close;
    }
    get closeSide() {
        return this._closeSide;
    }
    get menuActions() {
        return this._menuActions;
    }
    get component() {
        return this._component;
    }
    get data() {
        return this._data;
    }
    set data(value) {
        this._data = value;
    }
    get menuRefName() {
        return this._menuRefName;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    updateRouterLink(data) {
        if (this._visible) {
            super.updateRouterLink(data);
            if (this._menuActions.length > 0) {
                this._menuActions.forEach((action) => {
                    action.updateRouterLink(data);
                });
            }
        }
    }
    checkVisibility(data) {
        super.checkVisibility(data);
        if (this._menuActions.length > 0) {
            this._menuActions.forEach((action) => {
                action.checkVisibility(data);
            });
        }
        if (this.menuActions.length > 0) {
            this._visible = this.menuActions.some((action) => action.visible);
        }
    }
}

class DrawerConfig {
    constructor(data = {}) {
        this.disableClose = data.disableClose || false;
        this.position = data.position || 'right';
        this.activeAction = data.activeAction || '';
        this.persist = data.persist;
        this.resizable = data.resizable === void 0 ? true : data.resizable;
        if (data.width) {
            this.width = data.width;
        }
        this.actions = data.actions && data.actions.map((action) => new Action(action)) || null;
    }
}

class DrawerRef {
    constructor(_overlayRef, _dataFactory, _config) {
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the drawer has finished opening. */
        this._afterOpened$ = new Subject();
        /** Subject for notifying the user that the drawer has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._closeStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started opening. */
        this._openStart$ = new Subject();
        /** Subject for notifying the user that the drawer has started closing. */
        this._sideToggle = new Subject();
        /** Subject for notifying the user that the drawer has finished opening. */
        this._actionsUpdated$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._activeAction = new BehaviorSubject(void 0);
        this._menuRefs = new Map();
        this._isOpen = false;
        this._isSideOpen = false;
        this.drawerConfig = new DrawerConfig(_config);
        this._initActiveAction();
    }
    get overlayRef() {
        return this._overlayRef;
    }
    /**
     * Getter for DRAWER_DATA for current drawer
     */
    get drawerData() {
        return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
    }
    get destroy$() {
        return this._destroy$.asObservable();
    }
    /**
     * Set reference to drawer container
     * @param value
     */
    set containerRef(value) {
        this._drawerContainerRef = value;
    }
    /**
     * Set reference to drawer component
     * @param value
     */
    set componentRef(value) {
        this._drawerComponentRef = value;
    }
    set drawerContainer(value) {
        this._drawerContainer = value;
    }
    set drawerActionsContainer(value) {
        this._drawerActionsContainer = value;
    }
    get drawerContainer() {
        return this._drawerContainer;
    }
    get drawerActionsContainer() {
        return this._drawerActionsContainer;
    }
    get activeAction() {
        return this._activeAction.getValue();
    }
    get activeAction$() {
        return this._activeAction.pipe(takeUntil(this._destroy$));
    }
    /**
     * Return actual status of the drawer
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * Return actual status of the side of the drawer
     */
    get isSideOpen() {
        return this._isSideOpen;
    }
    set resizeController(value) {
        this._resizeController = value;
    }
    get resizeController() {
        return this._resizeController;
    }
    /**
     * Gets an observable that action was updated and change detection should be started
     */
    get actionUpdated$() {
        return this._actionsUpdated$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    get afterClosed$() {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    get afterOpened$() {
        return this._afterOpened$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog open starts.
     */
    get openStart$() {
        return this._openStart$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    get closeStart$() {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    }
    closeWhen() {
        return (source) => {
            this._closeStart$
                .pipe(switchMap((observer) => {
                return source.pipe(map(() => {
                    return observer;
                }));
            }))
                .subscribe((observer) => {
                observer.next();
                observer.complete();
            });
            //   switchMap(() => {
            //     debugger;
            //     return source;
            //   })
            // )
            // .subscribe((observer) => {
            // source.pipe(
            //   tap(() => {
            //     debugger;
            //     observer.next();
            //     observer.complete();
            //   }),
            // );
            return source;
            // return new Observable(subscriber => {
            //   source.subscribe({
            //     next(value) {
            //       if (value !== undefined && value !== null) {
            //         subscriber.next(value);
            //       }
            //     },
            //     error(error) {
            //       subscriber.error(error);
            //     },
            //     complete() {
            //       subscriber.complete();
            //     }
            //   })
            // });
        };
    }
    /**
     * Gets an observable that is notified when data in DRAWER_DATA was changed
     */
    get dataChanged$() {
        return this._dataFactory.dataChange$;
    }
    /**
     * Gets an observable that is notify that side status toggled
     */
    get sideToggle$() {
        return this._sideToggle.pipe(takeUntil(this._destroy$));
    }
    /**
     * Subscribe on keydown events to react on escape
     */
    events() {
        this._overlayRef.keydownEvents()
            .pipe(filter(event => event.keyCode === ESCAPE && !this.drawerConfig.disableClose), takeUntil(this._destroy$))
            .subscribe(() => this.close());
    }
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    dataChange(data) {
        this._dataFactory.setValue(data);
    }
    /**
     * Open drawer and notify observable
     */
    open() {
        new Observable((obs) => {
            setTimeout(() => {
                if (this._openStart$.observers.length) {
                    this._openStart$.next(obs);
                }
                else {
                    obs.next();
                    obs.complete();
                }
            });
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                if (this.activeAction) {
                    this.openSide();
                }
                this._drawerContainerRef.open();
                this._afterOpened$.next();
                this._afterOpened$.complete();
            },
            error: () => {
                this.destroy();
            },
        });
    }
    /**
     * Close the drawer.
     * @param result Optional result to return to the dialog opener.
     */
    close(result) {
        new Observable(observer => {
            if (this._closeStart$.observers.length) {
                zip(...this._closeStart$.observers.map(item => {
                    return Observable.create(closeObserver => {
                        item.next(closeObserver);
                    });
                }))
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => {
                    observer.next();
                    observer.complete();
                }, () => {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                this._drawerContainerRef.close();
                this._result = result;
                this._afterClosed$.next(result);
                this.destroy();
            }
        });
    }
    /**
     * Open the side of the drawer
     */
    openSide() {
        this._isSideOpen = true;
        this._sideToggle.next(this._isSideOpen);
    }
    /**
     * Close the side of the drawer
     */
    closeSide() {
        this._isSideOpen = false;
        this._sideToggle.next(this._isSideOpen);
        this.activateAction(null);
    }
    /**
     * Toggle the side of the drawer
     */
    toggleSide() {
        this.isSideOpen ? this.closeSide() : this.openSide();
    }
    /**
     * Change active action
     * @param name
     */
    activateAction(name) {
        this._activeAction.next(name);
        if (name) {
            this.openSide();
        }
    }
    enableAction(name) {
        const action = this.getAction(name);
        if (action) {
            action.disabled = false;
            this._actionsUpdated$.next(name);
        }
    }
    disableAction(name) {
        const action = this.getAction(name);
        if (action) {
            action.disabled = true;
            this._actionsUpdated$.next(name);
        }
    }
    /**
     * Store opened menu reference and subscribe for auto remove
     * @param name
     * @param ref
     */
    addMenuRef(name, ref) {
        this._menuRefs.set(name, ref);
        ref.afterClosed()
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._menuRefs.delete(name);
        });
    }
    /**
     * Get opened menu reference by name
     * @param name
     */
    getMenuRef(name) {
        return this._menuRefs.get(name);
    }
    getAction(name) {
        return this.drawerConfig.actions.find((action) => action.name === name);
    }
    /**
     * Do update for icon for target action
     * @param name
     * @param icon
     */
    updateActionIcon(name, icon) {
        const action = this.getAction(name);
        if (action) {
            action.icon = icon;
            this._actionsUpdated$.next(name);
        }
    }
    /**
     * Do update
     * @param name
     * @param data
     */
    updateAction(name, data) {
        const action = this.getAction(name);
        if (action) {
            const allowedFields = ['icon', 'type', 'toggle', 'tooltip', 'close', 'closeSide', 'component', 'data'];
            const forUpdate = Object.keys(data).filter((key) => allowedFields.indexOf(key) > -1);
            forUpdate.forEach((key) => {
                action[key] = data[key];
            });
            this._actionsUpdated$.next(name);
        }
    }
    updateDrawerWidth(width) {
        this.resizeController.updateMainWidth(width);
    }
    updateSideDrawerWidth(width) {
        this.resizeController.updateSideWidth(width);
    }
    destroy() {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._drawerComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    }
    _initActiveAction() {
        if (this.drawerConfig.activeAction) {
            const action = this.drawerConfig.actions
                .find((a) => a.name === this.drawerConfig.activeAction);
            if (action) {
                this._activeAction.next(this.drawerConfig.activeAction);
            }
            else {
                console.warn(`Drawer active action - "${this.drawerConfig.activeAction}" does not exists
        `);
            }
        }
    }
}

class FsDrawerMenuComponent extends BasePortalOutlet {
    constructor() {
        super();
    }
    setDrawerMenuRef(value) {
        this.ref = value;
        // this.config = this.externalMenuRef.config;
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    }
}
FsDrawerMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FsDrawerMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerMenuComponent, selector: "fs-drawer-menu", host: { classAttribute: "mat-elevation-z2" }, viewQueries: [{ propertyName: "_portalOutlet", first: true, predicate: CdkPortalOutlet, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<ng-template cdkPortalOutlet></ng-template>\n", styles: [":host{padding:15px;background:#fff;border-radius:2px;overflow:auto}\n"], directives: [{ type: i1.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-drawer-menu',
                    templateUrl: 'drawer-menu.component.html',
                    styleUrls: ['drawer-menu.component.scss'],
                    host: {
                        'class': 'mat-elevation-z2'
                    },
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return []; }, propDecorators: { _portalOutlet: [{
                type: ViewChild,
                args: [CdkPortalOutlet, { static: true }]
            }] } });

class DrawerMenuRef {
    constructor(_overlayRef, _dataFactory) {
        this._overlayRef = _overlayRef;
        this._dataFactory = _dataFactory;
        /** Subject for notifying the user that the menu has finished closing. */
        this._afterClosed$ = new Subject();
        /** Subject for notifying the user that the menu has started closing. */
        this._closeStart$ = new Subject();
        /** Destroy notifier **/
        this._destroy$ = new Subject();
        this._overlayRef.backdropClick()
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this.close();
        });
    }
    /**
     * Getter for DRAWER_MENU_DATA for current drawer
     */
    get menuData() {
        return Object.assign({}, this._dataFactory.getValue()); // Like immutable.... TODO switch to Immer
    }
    /**
     * Set reference to menu container
     * @param value
     */
    set containerRef(value) {
        this._externalMenuContainerRef = value;
    }
    /**
     * Set reference to menu component
     * @param value
     */
    set componentRef(value) {
        this._externalMenuComponentRef = value;
    }
    /**
     * Gets an observable that is notified when data in DRAWER_DATA was changed
     */
    get dataChanged$() {
        return this._dataFactory.dataChange$;
    }
    /**
     * Set value for DRAWER_DATA
     * @param data
     */
    dataChange(data) {
        this._dataFactory.setValue(data);
    }
    /**
     * Gets an observable that is notified when the dialog is finished closing.
     */
    afterClosed() {
        return this._afterClosed$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Gets an observable that is notified when the dialog is finished opening.
     */
    closeStart() {
        return this._closeStart$.pipe(takeUntil(this._destroy$));
    }
    /**
     * Close the menu.
     * @param result Optional result to return to the dialog opener.
     */
    close(result) {
        new Observable(observer => {
            if (this._closeStart$.observers.length) {
                zip(...this._closeStart$.observers.map((item) => {
                    return Observable.create(closeObserver => {
                        item.next(closeObserver);
                    });
                }))
                    .pipe(takeUntil(this._destroy$))
                    .subscribe(() => {
                    observer.next();
                    observer.complete();
                }, () => {
                    observer.error();
                });
            }
            else {
                observer.next();
                observer.complete();
            }
        }).pipe(takeUntil(this._destroy$))
            .subscribe({
            next: () => {
                this._result = result;
                this._afterClosed$.next(result);
                this.destroy();
            }
        });
    }
    destroy() {
        this._overlayRef.detachBackdrop();
        this._overlayRef.detach();
        this._externalMenuComponentRef && this._externalMenuComponentRef.destroy();
        this._dataFactory.destroy();
        this._destroy$.next();
        this._destroy$.complete();
    }
}

class DrawerData {
    constructor(data = {}) {
        this._dataChange = new Subject();
        this._destroy = new Subject();
        this._data = data;
    }
    static createWithProxy(data = {}) {
        const drawerData = new DrawerData(data);
        return new Proxy(drawerData, {
            get(target, property) {
                if (typeof target[property] === 'function'
                    || property === '_data'
                    || target[property] instanceof Observable) {
                    return target[property];
                }
                else {
                    return target._data[property];
                }
            },
            set(target, property, value) {
                if (property !== '_data') {
                    target._data[property] = value;
                }
                else {
                    target[property] = value;
                }
                return true;
            },
            has(target, property) {
                return property in target._data;
            },
            ownKeys(target) {
                return Object.keys(target._data);
            },
            getOwnPropertyDescriptor(target, property) {
                return Object.getOwnPropertyDescriptor(target._data, property);
            }
        });
    }
    get dataChange$() {
        return this._dataChange.pipe(takeUntil(this._destroy));
    }
    getValue() {
        return this._data;
    }
    setValue(value) {
        this._data = value;
        this._dataChange.next(this._data);
    }
    destroy() {
        this._destroy.next();
        this._destroy.complete();
    }
}

/** Injection token that can be used to access the data that was passed in to a drawer. */
const DRAWER_MENU_DATA = new InjectionToken('fs.drawer.menu-data');

class FsDrawerMenuService {
    constructor(_overlay, _injector, _breakpointObserver) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._breakpointObserver = _breakpointObserver;
    }
    create(component, container, config) {
        const overlayRef = this.createOverlay(container);
        const dataFactory = DrawerData.createWithProxy(config.data);
        const menuRef = new DrawerMenuRef(overlayRef, dataFactory);
        const containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
        const componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
        menuRef.containerRef = containerRef;
        containerRef.setDrawerMenuRef(menuRef);
        menuRef.componentRef = componentRef;
        return menuRef;
    }
    createOverlay(container) {
        const overlayConfig = this.getOverlayConfig(container);
        return this._overlay.create(overlayConfig);
    }
    getOverlayConfig(container) {
        const element = new ElementRef(container); // positionStrategy needs ElementRef;
        let strategy = null;
        if (this._breakpointObserver.isMatched(Breakpoints.XSmall)) {
            strategy = this._overlay
                .position()
                .global()
                .centerHorizontally()
                .centerVertically();
        }
        else {
            const positions = [
                { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
            ];
            strategy = this._overlay
                .position()
                .flexibleConnectedTo(element)
                .withPositions(positions);
        }
        return new OverlayConfig({
            positionStrategy: strategy,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop'
        });
    }
    attachContainer(overlayRef, menuRef, dataFactory) {
        const injector = this.createInjector(menuRef, dataFactory);
        const containerPortal = new ComponentPortal(FsDrawerMenuComponent, undefined, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    attachComponent(componentRef, externalContainer, externalRef, config) {
        const injector = this.createInjector(externalRef, config);
        return externalContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    }
    createInjector(componentRef, dataFactory) {
        const injectionTokens = new WeakMap([
            [DrawerMenuRef, componentRef],
            [DRAWER_MENU_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    }
}
FsDrawerMenuService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService, deps: [{ token: i1$1.Overlay }, { token: i0.Injector }, { token: i2.BreakpointObserver }], target: i0.ɵɵFactoryTarget.Injectable });
FsDrawerMenuService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Overlay }, { type: i0.Injector }, { type: i2.BreakpointObserver }]; } });

class FsDrawerActionItemComponent {
    constructor(drawer, _cdRef) {
        this.drawer = drawer;
        this._cdRef = _cdRef;
        this.actionClicked = new EventEmitter();
        this.isActive = false;
        this.actionTypes = FsDrawerAction;
        this._destroy$ = new Subject();
        this._listenActionChanges();
        this._listenDataChanges();
    }
    ngOnInit() {
        this._updateVisibilityAndLinks();
    }
    ngOnChanges(changes) {
        if (changes.activeAction) {
            this.isActive = this.action.name !== '' && this.action.name === this.activeAction;
        }
    }
    actionClick(event) {
        this.actionClicked.emit(event);
    }
    menuActionClick(action, event) {
        if (action.click) {
            action.click.call(null, {
                data: this.drawer.drawerData,
                event: event,
                drawerRef: this.drawer,
                action: action
            });
        }
    }
    _listenActionChanges() {
        this.drawer.actionUpdated$
            .pipe(filter((name) => name === this.action.name), takeUntil(this._destroy$))
            .subscribe(() => {
            this._cdRef.detectChanges();
        });
    }
    _listenDataChanges() {
        this.drawer.dataChanged$
            .pipe(takeUntil(this._destroy$), debounceTime(50))
            .subscribe(() => {
            this._updateVisibilityAndLinks();
        });
    }
    _updateVisibilityAndLinks() {
        this._updateVisibility();
        this._updateRouterLinks();
        this._cdRef.detectChanges();
    }
    _updateVisibility() {
        this.action.checkVisibility(this.drawer.drawerData);
    }
    _updateRouterLinks() {
        if (this.action.type === this.actionTypes.Menu) {
            this.action.updateRouterLink({
                data: this.drawer.drawerData,
                drawerRef: this.drawer
            });
        }
    }
}
FsDrawerActionItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionItemComponent, deps: [{ token: DrawerRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsDrawerActionItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionItemComponent, selector: "fs-drawer-action-item", inputs: { action: "action", activeAction: "activeAction" }, outputs: { actionClicked: "actionClicked" }, usesOnChanges: true, ngImport: i0, template: "<ng-container [ngSwitch]=\"action.type\">\n  <ng-container *ngSwitchCase=\"actionTypes.Button\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [disabled]=\"action.disabled\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Menu\">\n    <ng-container *ngIf=\"action.visible\">\n      <button mat-icon-button\n              type=\"button\"\n              class=\"sub-action\"\n              [fsMenuTriggerFor]=\"menu\"\n              [matTooltip]=\"action.tooltip\"\n              [disabled]=\"action.disabled\"\n              [class.active]=\"isActive\"\n              (click)=\"actionClick($event)\">\n        <i class=\"material-icons\">{{action.icon}}</i>\n      </button>\n\n      <fs-menu #menu>\n        <ng-container *ngFor=\"let menuAction of action.menuActions\">\n          <ng-container *ngIf=\"menuAction.isGroup else simpleMenuItem\">\n            <fs-menu-group [label]=\"menuAction.label\" [hidden]=\"!menuAction.visible\">\n              <ng-container *ngFor=\"let groupAction of menuAction.actions\">\n                <ng-template fs-menu-item\n                             [hidden]=\"!groupAction.visible\"\n                             [link]=\"groupAction.routerLink?.link\"\n                             [queryParams]=\"groupAction.routerLink?.queryParams\"\n                             (click)=\"menuActionClick(groupAction, $event);\">\n                  <mat-icon *ngIf=\"menuAction.icon\">{{groupAction.icon}}</mat-icon>\n                  {{groupAction.label}}\n                </ng-template>\n              </ng-container>\n            </fs-menu-group>\n          </ng-container>\n          <ng-template #simpleMenuItem>\n            <ng-template fs-menu-item\n                         [hidden]=\"!menuAction.visible\"\n                         [link]=\"menuAction.routerLink?.link\"\n                         [queryParams]=\"menuAction.routerLink?.queryParams\"\n                         (click)=\"menuActionClick(menuAction, $event);\">\n              <i class=\"material-icons\" *ngIf=\"menuAction.icon\">{{menuAction.icon}}</i>\n              <span>{{menuAction.label}}</span>\n            </ng-template>\n          </ng-template>\n        </ng-container>\n      </fs-menu>\n    </ng-container>\n  </ng-container>\n\n  <ng-container *ngSwitchCase=\"actionTypes.Component\">\n    <button mat-icon-button\n            type=\"button\"\n            *ngIf=\"action.visible\"\n            [matTooltip]=\"action.tooltip\"\n            [disabled]=\"action.disabled\"\n            [class.active]=\"isActive\"\n            (click)=\"actionClick($event)\">\n      <i class=\"material-icons\">{{action.icon}}</i>\n    </button>\n  </ng-container>\n</ng-container>\n", styles: [".mat-icon-button{width:35px;height:35px;line-height:35px}.mat-icon-button[disabled=true]{opacity:.5}\n"], components: [{ type: i2$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { type: i3.FsMenuComponent, selector: "fs-menu", inputs: ["class", "buttonClass"], outputs: ["opened", "closed"] }, { type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i5.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.MatTooltip, selector: "[matTooltip]", exportAs: ["matTooltip"] }, { type: i3.FsMenuTriggerDirective, selector: "[fsMenuTriggerFor]", inputs: ["fsMenuTriggerFor"] }, { type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.FsMenuItemDirective, selector: "fs-menu-group,[fs-menu-item]", inputs: ["fsClass", "class", "id", "label", "hidden", "groupHidden", "dismissAfterClick", "link", "target", "queryParams"], outputs: ["click"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionItemComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-drawer-action-item',
                    templateUrl: './drawer-action-item.component.html',
                    styleUrls: [
                        './drawer-action-item.component.scss',
                    ],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: DrawerRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { action: [{
                type: Input
            }], activeAction: [{
                type: Input
            }], actionClicked: [{
                type: Output
            }] } });

class FsDrawerActionsComponent {
    constructor(_drawerRef, _drawerMenu, _cdRef) {
        this._drawerRef = _drawerRef;
        this._drawerMenu = _drawerMenu;
        this._cdRef = _cdRef;
        this._destroy$ = new Subject();
    }
    ngOnInit() {
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    actionClick(action, event) {
        const hasComponentType = action.type === FsDrawerAction.Component;
        const hasMenuType = action.type === FsDrawerAction.Menu;
        if (hasComponentType) {
            const menuRef = this._drawerMenu.create(action.component, event.srcElement, action);
            this._drawerRef.addMenuRef(action.menuRefName, menuRef);
            const params = {
                event: event,
                action: action,
                drawerRef: this._drawerRef,
                menuRef: menuRef
            };
            // Call click
            action.click.call(null, params);
            if (action.closeSide) {
                this._drawerRef.closeSide();
            }
        }
        else if (action.click) {
            const params = { event: event, action: action };
            action.click.call(null, params);
        }
        if (action.close) {
            this._drawerRef.close();
        }
        if (action.toggle && ((!hasComponentType && !hasMenuType) || action.closeSide)) {
            if (this._drawerRef.isSideOpen && this._drawerRef.activeAction === action.name) {
                this._drawerRef.toggleSide();
            }
            else {
                this._drawerRef.activateAction(action.name);
            }
        }
    }
    muteEvent(e) {
        e.stopImmediatePropagation();
        e.stopPropagation();
    }
}
FsDrawerActionsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionsComponent, deps: [{ token: DrawerRef }, { token: FsDrawerMenuService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FsDrawerActionsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionsComponent, selector: "fs-drawer-actions", inputs: { actions: "actions", activeAction: "activeAction" }, ngImport: i0, template: "<div class=\"actions-container\" (mousedown)=\"muteEvent($event)\" (dragstart)=\"muteEvent($event)\">\n  <div *ngFor=\"let action of actions\" class=\"action-btn\">\n    <fs-drawer-action-item [action]=\"action\"\n                           [activeAction]=\"activeAction\"\n                           (actionClicked)=\"actionClick(action, $event)\">\n    </fs-drawer-action-item>\n  </div>\n</div>\n<div class=\"drag-icon\">\n  <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n</div>\n<div class=\"drag-ripple\"></div>\n", styles: [":host{display:flex}.actions-container{flex:0;margin-top:5px;cursor:pointer}.drag-icon{opacity:0;flex:1;display:flex;align-items:center}.drag-ripple{position:absolute;top:0;bottom:0;width:100%;background:transparent;transition:.2s}\n"], components: [{ type: FsDrawerActionItemComponent, selector: "fs-drawer-action-item", inputs: ["action", "activeAction"], outputs: ["actionClicked"] }, { type: i2$1.MatAnchor, selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matButton", "matAnchor"] }, { type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-drawer-actions',
                    templateUrl: './drawer-actions.component.html',
                    styleUrls: ['./drawer-actions.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: DrawerRef }, { type: FsDrawerMenuService }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { actions: [{
                type: Input
            }], activeAction: [{
                type: Input
            }] } });

class FsDrawerPersistanceController extends FsPersistanceStore {
    constructor() {
        super(...arguments);
        this.STORE_KEY = 'fs-drawer-persist';
    }
}
FsDrawerPersistanceController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerPersistanceController, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
FsDrawerPersistanceController.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerPersistanceController });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerPersistanceController, decorators: [{
            type: Injectable
        }] });

class DrawerStoreService {
    constructor() {
        this._openedDrawers = [];
    }
    get drawerRefs() {
        return [...this._openedDrawers];
    }
    get numberOfOpenedDrawers() {
        return this._openedDrawers.length;
    }
    getLevelForRef(value) {
        return this._openedDrawers.indexOf(value) + 1;
    }
    addRef(value) {
        if (this._openedDrawers.indexOf(value) === -1) {
            this._openedDrawers.push(value);
            this._pushDrawersCascade();
        }
    }
    deleteRef(value) {
        this._openedDrawers = this._openedDrawers
            .filter((ref) => ref !== value);
    }
    /**
     * In case, when we want to open more than 1 drawer
     * our previously opened drawers should be visible
     *
     *      d1   d2   d3
     *     ---- ---- ---
     *    | x  | x1 | x2
     *    | y  | y1 | y2
     *    | z  | z1 | z2
     *     ---- ---- ---
     *
     * Where d1, d2 - previously opened drawers
     * d1 and d2 must be pushed left to be visible under just opened d3
     */
    _pushDrawersCascade() {
        if (this.numberOfOpenedDrawers > 1) {
            // SetTimeout should be here because we must wait render newly opened drawer
            // to be able to get his width
            setTimeout(() => {
                const refsArr = Array.from(this._openedDrawers.values());
                for (let i = refsArr.length - 1; i > 0; i--) {
                    const prevRef = refsArr[i - 1];
                    const currRef = refsArr[i];
                    prevRef.resizeController.pushMainWidth(currRef);
                }
            });
        }
    }
}
DrawerStoreService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerStoreService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
DrawerStoreService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerStoreService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerStoreService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });

const MAIN_DRAWER_DEFAULT_WIDTH = 500;
const SIDE_DRAWER_DEFAULT_WIDTH = 200;
const SIDE_RESIZE_BAR_WIDTH = 46;
const MAIN_RESIZE_ACTION_BAR_WIDTH = 45;

class DrawerSizeController {
    constructor(_drawerRef, _ngZone, _persistanceController, _drawerStore) {
        this._drawerRef = _drawerRef;
        this._ngZone = _ngZone;
        this._persistanceController = _persistanceController;
        this._drawerStore = _drawerStore;
        this._sideOpened = false;
        this._borderPadding = 0;
        this._destroy$ = new Subject();
    }
    get mainElRef() {
        return this._mainElRef;
    }
    get sideElRef() {
        return this._sideElRef;
    }
    get mainConfig() {
        return this._mainConfig;
    }
    get sideConfig() {
        return this._sideConfig;
    }
    get screenWidth() {
        return this._screenWidth;
    }
    get persistedMainWidth() {
        return this._persistanceController.enabled
            ? this._persistanceController.getDataFromScope('mainWidth')
            : null;
    }
    get persistedSideWidth() {
        return this._persistanceController.enabled
            ? this._persistanceController.getDataFromScope('sideWidth')
            : null;
    }
    init() {
        this._initDefaultConfigs();
        this._updateScreenWidth();
        this._listenWindowResize();
        this._listenSideToggle();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    registerElRef(el) {
        if (el.isMainDrawer) {
            this._registerMainRef(el);
            this._listenWidthChanges(el);
        }
        else if (el.isSideDrawer) {
            this._registerSideRef(el);
            this._listenWidthChanges(el);
        }
        else {
            throw Error('Unrecognized resize element type');
        }
    }
    removeElRef(el) {
        if (el.isMainDrawer) {
            this._removeMainRef();
        }
        else if (el.isSideDrawer) {
            this._removeSideRef();
        }
    }
    getInitialWidth(type) {
        if (type === 'main') {
            return this.mainConfig.initial;
        }
        else if (type === 'side') {
            return this.sideConfig.initial;
        }
        else {
            return void 0;
        }
    }
    getMinWidth(type) {
        var _a, _b;
        if (type === 'main') {
            return (_a = this.mainConfig.min) !== null && _a !== void 0 ? _a : 0;
        }
        else if (type === 'side') {
            return (_b = this.sideConfig.min) !== null && _b !== void 0 ? _b : 0;
        }
        else {
            return 0;
        }
    }
    getMaxWidth(type) {
        var _a, _b;
        if (type === 'main') {
            return (_a = this.mainConfig.max) !== null && _a !== void 0 ? _a : window.innerWidth;
        }
        else if (type === 'side') {
            return (_b = this.sideConfig.max) !== null && _b !== void 0 ? _b : window.innerWidth;
        }
        else {
            return window.innerWidth;
        }
    }
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    updateMainWidth(width) {
        const sideWidth = (this.sideElRef && this.sideElRef.width) || 0;
        this.mainElRef.updateWidth(sideWidth + width);
    }
    /**
     * Update width from outside with all calculations to be done
     * @param width
     */
    updateSideWidth(width) {
        if (this.sideElRef) {
            const currentWidth = this.mainElRef.width - this.sideElRef.width;
            this.mainElRef.updateWidth(currentWidth + width);
            this.sideElRef.updateWidth(width);
        }
    }
    /**
     * Push current drawer to be visible under new one opened
     * @param inFrontDrawer
     */
    pushMainWidth(inFrontDrawer) {
        const inFrontDrawerTotalWidth = inFrontDrawer.resizeController.mainElRef.width
            + MAIN_RESIZE_ACTION_BAR_WIDTH;
        if (this.mainElRef.width <= inFrontDrawerTotalWidth) {
            this.updateMainWidth(inFrontDrawerTotalWidth);
        }
    }
    /**
     * Listen for browser resize and update restrictions
     */
    _listenWindowResize() {
        this._ngZone.runOutsideAngular(() => {
            fromEvent(window, 'resize')
                .pipe(debounceTime(50), takeUntil(this._destroy$))
                .subscribe(() => {
                this._updateScreenWidth();
                this._updateMinMaxStyles();
            });
        });
    }
    /**
     * Copy initial configs or set default values
     */
    _initDefaultConfigs() {
        // Main initialization
        this._mainConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.main)
                || {};
        this._mainConfig.initial = this.persistedMainWidth
            || this._mainConfig.initial
            || MAIN_DRAWER_DEFAULT_WIDTH;
        // Side initialization
        this._sideConfig =
            (this._drawerRef.drawerConfig.width && this._drawerRef.drawerConfig.width.side)
                || {};
        this._sideConfig.initial = this.persistedSideWidth
            || this._sideConfig.initial
            || SIDE_DRAWER_DEFAULT_WIDTH;
    }
    _registerMainRef(el) {
        this._mainElRef = el;
    }
    _registerSideRef(el) {
        this._sideElRef = el;
    }
    _removeMainRef() {
        this._mainElRef = null;
    }
    _removeSideRef() {
        this._sideElRef = null;
    }
    /**
     * Update current window size
     */
    _updateScreenWidth() {
        this._screenWidth = (window.innerWidth - this._borderPadding);
    }
    /**
     * Update min&max css props for containers
     */
    _updateMinMaxStyles() {
        this.mainElRef.setMinMaxStyles();
        if (this.sideElRef) {
            this.sideElRef.setMinMaxStyles();
        }
    }
    _listenSideToggle() {
        this._drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe((opened) => {
            if (this._sideOpened === opened) {
                return;
            }
            this._sideOpened = opened;
            if (opened) {
                const currentWidth = this.mainElRef.width;
                const sideWidth = this.getInitialWidth('side');
                this._mainElRef.updateWidth(currentWidth + sideWidth + SIDE_RESIZE_BAR_WIDTH);
            }
            else {
                const actualSideWidth = this.sideElRef.fsDrawerResizer.getBoundingClientRect().width;
                const mainWidth = this.mainElRef.width - actualSideWidth - SIDE_RESIZE_BAR_WIDTH;
                this._mainElRef.updateWidth(mainWidth);
            }
        });
    }
    _listenWidthChanges(el) {
        if (!this._persistanceController.enabled) {
            return;
        }
        el.width$
            .pipe(debounceTime(200), filter(() => {
            return this._drawerStore.getLevelForRef(el.drawerRef) === this._drawerStore.numberOfOpenedDrawers;
        }))
            .subscribe({
            next: () => {
                var _a;
                const sideWidth = ((_a = this._sideElRef) === null || _a === void 0 ? void 0 : _a.width) || 0;
                if (this._mainElRef) {
                    this._persistanceController.saveDataToScope('mainWidth', this._mainElRef.width - sideWidth - SIDE_RESIZE_BAR_WIDTH);
                }
                if (this._sideElRef) {
                    this._persistanceController.saveDataToScope('sideWidth', sideWidth);
                }
            }
        });
    }
}
DrawerSizeController.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerSizeController, deps: [{ token: DrawerRef }, { token: i0.NgZone }, { token: FsDrawerPersistanceController }, { token: DrawerStoreService }], target: i0.ɵɵFactoryTarget.Injectable });
DrawerSizeController.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerSizeController });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: DrawerSizeController, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: DrawerRef }, { type: i0.NgZone }, { type: FsDrawerPersistanceController }, { type: DrawerStoreService }]; } });

class FsDrawerResizerDirective {
    constructor(_el, _renderer, _ngZone, _drawerRef) {
        this._el = _el;
        this._renderer = _renderer;
        this._ngZone = _ngZone;
        this._drawerRef = _drawerRef;
        this.fsDrawerResizer = this._el.nativeElement;
        this.direction = 'left';
        this.resizable = true;
        this._dragStartHandler = this._dragStart.bind(this);
        this._dragHandler = this._drag.bind(this);
        this._dragEndHandler = this._dragEnd.bind(this);
        this._x = 0;
        this._width$ = new BehaviorSubject(0);
        this._actionsWidth = 0;
        this._destroy$ = new Subject();
    }
    get drawerRef() {
        return this._drawerRef;
    }
    get isMainDrawer() {
        return this.type === 'main';
    }
    get isSideDrawer() {
        return this.type === 'side';
    }
    get width() {
        return this._width$.getValue();
    }
    get width$() {
        return this._width$.pipe(takeUntil(this._destroy$));
    }
    get minWidth() {
        const minWidth = this.sizeController.getMinWidth(this.type);
        if (minWidth && minWidth >= 0) {
            const screenWidth = this.sizeController.screenWidth;
            const barWidth = this.barWidth;
            if (screenWidth - minWidth < barWidth) {
                return this.sizeController.screenWidth - barWidth;
            }
            else {
                return minWidth;
            }
        }
    }
    get maxWidth() {
        const maxWidth = this.sizeController.getMaxWidth(this.type);
        let parentContainerWidth = null;
        if (this.parentContainer) {
            parentContainerWidth = this._getElementWidth(this.parentContainer.nativeElement);
        }
        if (parentContainerWidth !== null) {
            return !maxWidth || maxWidth >= parentContainerWidth
                ? parentContainerWidth - this._actionsWidth * 2
                : maxWidth;
        }
        else {
            return !maxWidth || maxWidth >= this.sizeController.screenWidth
                ? this.sizeController.screenWidth
                : maxWidth;
        }
    }
    get barWidth() {
        return this.isMainDrawer
            ? MAIN_RESIZE_ACTION_BAR_WIDTH
            : SIDE_RESIZE_BAR_WIDTH;
    }
    ngOnInit() {
        this.sizeController.registerElRef(this);
        if (this.resizable) {
            this._ngZone.runOutsideAngular(() => {
                this._el.nativeElement.addEventListener('mousedown', this._dragStartHandler, false);
                this._el.nativeElement.addEventListener('touchstart', this._dragStartHandler, false);
            });
            if (this.actionsContainer) {
                this._actionsWidth = this._getElementWidth(this.actionsContainer.nativeElement);
            }
            this.setMinMaxStyles();
            const minWidth = this.sizeController.getMinWidth(this.type);
            let width = this.sizeController.getInitialWidth(this.type)
                || this._getElementWidth(this.fsDrawerResizer);
            if (width < minWidth) {
                width = minWidth;
            }
            this.updateWidth(width);
        }
    }
    updateWidth(width) {
        const minConfiguredWidth = this.sizeController.getMinWidth(this.type);
        const maxConfiguredWidth = this.sizeController.getMaxWidth(this.type);
        const availableWidth = this.sizeController.screenWidth;
        // newWidth should not be
        // greater than maxConfiguredWidth
        // and not lesser than minConfiguredWidth
        width = Math.max(minConfiguredWidth, Math.min(width, maxConfiguredWidth));
        // and sure it shouldn't be greater than screen width
        width = Math.min(width, availableWidth);
        if (width === this.width) {
            return;
        }
        this._width$.next(width);
        requestAnimationFrame(() => {
            this._renderer.setStyle(this.fsDrawerResizer, 'width', `${width}px`);
        });
    }
    ngOnDestroy() {
        this._el.nativeElement.removeEventListener('mousedown', this._dragStartHandler, false);
        this._el.nativeElement.removeEventListener('touchstart', this._dragStartHandler, false);
        this.sizeController.removeElRef(this);
        this._destroy$.next();
        this._destroy$.complete();
    }
    /**
     * Set inline styles min/max width
     */
    setMinMaxStyles() {
        requestAnimationFrame(() => {
            this._renderer.setStyle(this.fsDrawerResizer, 'min-width', `${this.minWidth}px`);
            this._renderer.setStyle(this.fsDrawerResizer, 'max-width', `${this.maxWidth}px`);
        });
    }
    /**
     * Subscribe to move events and init base dimensions/restrictions
     * @param event { MouseEvent }
     */
    _dragStart(event) {
        this._x = this._getClientX(event);
        this.updateWidth(this._getElementWidth(this.fsDrawerResizer));
        this.setMinMaxStyles();
        document.addEventListener('touchmove', this._dragHandler, false);
        document.addEventListener('touchend', this._dragEndHandler, false);
        document.addEventListener('mousemove', this._dragHandler, false);
        document.addEventListener('mouseup', this._dragEndHandler, false);
    }
    /**
     * Update coordinates during drag
     * @param event
     */
    _drag(event) {
        const clientX = this._getClientX(event);
        const predictedWidth = this._calcWidth(this.direction, clientX);
        this._updatePosition(clientX, predictedWidth);
        // this._emitResizeEvent();
    }
    /**
     * Remove listeners when drag finished
     * @param event
     */
    _dragEnd(event) {
        document.removeEventListener('mousemove', this._dragHandler, false);
        document.removeEventListener('mouseup', this._dragEndHandler, false);
        document.removeEventListener('touchmove', this._dragHandler, false);
        document.removeEventListener('touchend', this._dragEndHandler, false);
    }
    /**
     *
     * @param event
     */
    _getClientX(event) {
        return event.touches ? event.touches[0].clientX : event.clientX;
    }
    /**
     * Will return width of element
     * @param el
     */
    _getElementWidth(el) {
        return el.getBoundingClientRect().width;
    }
    /**
     * Update width and position of target element
     * @param clientX
     * @param width
     */
    _updatePosition(clientX, width) {
        this._x = clientX;
        this.updateWidth(width < 0 ? 0 : width);
    }
    /**
     * Calc new width based on offset from previous position
     * @param direction
     * @param clientX
     */
    _calcWidth(direction, clientX) {
        const directionSign = direction === 'left' ? -1 : 1;
        return this.width + (this._x - clientX) * directionSign;
    }
}
FsDrawerResizerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerResizerDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: DrawerRef }], target: i0.ɵɵFactoryTarget.Directive });
FsDrawerResizerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: { fsDrawerResizer: "fsDrawerResizer", type: "type", direction: "direction", resizable: "resizable", parentContainer: "parentContainer", actionsContainer: "actionsContainer", sizeController: "sizeController" }, host: { properties: { "style.cursor": "\"col-resize\"" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerResizerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsDrawerResizer]',
                    host: {
                        '[style.cursor]': '"col-resize"',
                    }
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: DrawerRef }]; }, propDecorators: { fsDrawerResizer: [{
                type: Input
            }], type: [{
                type: Input
            }], direction: [{
                type: Input
            }], resizable: [{
                type: Input
            }], parentContainer: [{
                type: Input
            }], actionsContainer: [{
                type: Input
            }], sizeController: [{
                type: Input
            }] } });

class FsDrawerComponent extends BasePortalOutlet {
    constructor(_el, _drawerMenu, _drawerRef, _cdRef, _resizeController, _persistanceController, _location) {
        super();
        this._el = _el;
        this._drawerMenu = _drawerMenu;
        this._drawerRef = _drawerRef;
        this._cdRef = _cdRef;
        this._resizeController = _resizeController;
        this._persistanceController = _persistanceController;
        this._location = _location;
        this.isOpen = false;
        this.isOpenSide = false;
        this.initialized = false;
        this._sideOpen = false;
        this._destroy$ = new Subject();
        this._drawerRef.resizeController = this._resizeController;
    }
    get sideOpen() {
        return this._sideOpen;
    }
    set sideOpen(value) {
        this._sideOpen = value;
        this._el.nativeElement.classList
            .toggle('side-open', this.sideOpen);
    }
    ngOnInit() {
        this._listenDataChanges();
        this.config = this.drawerRef.drawerConfig;
        if (this.config.persist) {
            const namespace = getNormalizedPath(this._location);
            this._persistanceController.setConfig(this.config.persist, namespace);
        }
        this._resizeController.init();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    open() {
        this.isOpen = true;
    }
    close() {
        this.isOpen = false;
    }
    openSide() {
        this.isOpenSide = true;
    }
    closeSide() {
        this.isOpenSide = false;
    }
    setDrawerRef(value) {
        this.drawerRef = value;
        // Need to be like a parent for children resize
        this.drawerRef.drawerContainer = this._drawerContainer;
        this.drawerRef.drawerActionsContainer = this._drawerActionsContainer;
        this.drawerRef.sideToggle$
            .pipe(takeUntil(this._destroy$))
            .subscribe((opened) => {
            this.sideOpen = opened;
        });
        this.initialized = true;
    }
    /**
     * Attach a ComponentPortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer component already attached');
        }
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this dialog container.
     * @param portal Portal to be attached as the dialog content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throw Error('Drawer template already attached');
        }
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    _listenDataChanges() {
        this._drawerRef.dataChanged$
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            this._cdRef.detectChanges();
        });
    }
}
FsDrawerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerComponent, deps: [{ token: i0.ElementRef }, { token: FsDrawerMenuService }, { token: DrawerRef }, { token: i0.ChangeDetectorRef }, { token: DrawerSizeController }, { token: FsDrawerPersistanceController }, { token: i5.Location }], target: i0.ɵɵFactoryTarget.Component });
FsDrawerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerComponent, selector: "fs-drawer", host: { classAttribute: "fs-drawer-container" }, providers: [
        FsDrawerMenuService,
        FsDrawerPersistanceController,
        DrawerSizeController,
    ], viewQueries: [{ propertyName: "_portalOutlet", first: true, predicate: CdkPortalOutlet, descendants: true, static: true }, { propertyName: "_drawerContainer", first: true, predicate: ["drawerContainer"], descendants: true, static: true }, { propertyName: "_drawerActionsContainer", first: true, predicate: ["drawerActionsContainer"], descendants: true, read: ElementRef, static: true }], usesInheritance: true, ngImport: i0, template: "<div class=\"mat-elevation-z2 drawer\" #drawer\n     hidden\n     [ngClass]=\"config.position\"\n     [hidden]=\"!initialized\">\n  <ng-container>\n    <fs-drawer-actions class=\"drawer-actions\"\n                       #drawerActionsContainer\n                       type=\"main\"\n                       [fsDrawerResizer]=\"drawer\"\n                       [resizable]=\"drawerRef.drawerConfig.resizable\"\n                       [sizeController]=\"drawerRef.resizeController\"\n                       [direction]=\"config.position\"\n                       [actions]=\"config.actions\"\n                       [activeAction]=\"drawerRef.activeAction$ | async\">\n    </fs-drawer-actions>\n    <div class=\"drawer-container\" #drawerContainer>\n      <ng-template cdkPortalOutlet></ng-template>\n    </div>\n  </ng-container>\n</div>\n", components: [{ type: FsDrawerActionsComponent, selector: "fs-drawer-actions", inputs: ["actions", "activeAction"] }], directives: [{ type: i5.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: ["fsDrawerResizer", "type", "direction", "resizable", "parentContainer", "actionsContainer", "sizeController"] }, { type: i1.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }], pipes: { "async": i5.AsyncPipe }, changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-drawer',
                    templateUrl: './drawer.component.html',
                    providers: [
                        FsDrawerMenuService,
                        FsDrawerPersistanceController,
                        DrawerSizeController,
                    ],
                    host: {
                        'class': 'fs-drawer-container',
                    },
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: FsDrawerMenuService }, { type: DrawerRef }, { type: i0.ChangeDetectorRef }, { type: DrawerSizeController }, { type: FsDrawerPersistanceController }, { type: i5.Location }]; }, propDecorators: { _portalOutlet: [{
                type: ViewChild,
                args: [CdkPortalOutlet, { static: true }]
            }], _drawerContainer: [{
                type: ViewChild,
                args: ['drawerContainer', { static: true }]
            }], _drawerActionsContainer: [{
                type: ViewChild,
                args: ['drawerActionsContainer', { read: ElementRef, static: true }]
            }] } });

class FsDrawerActionDirective {
}
FsDrawerActionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
FsDrawerActionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerActionDirective, selector: "[fsDrawerAction]", inputs: { name: ["fsDrawerAction", "name"] }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerActionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsDrawerAction]',
                }]
        }], propDecorators: { name: [{
                type: Input,
                args: ['fsDrawerAction']
            }] } });

class FsDrawerSideComponent {
    constructor(_cdRef, _renderer, _elRef) {
        this._cdRef = _cdRef;
        this._renderer = _renderer;
        this._elRef = _elRef;
        this.classSide = true;
        this.activeTemplate = null;
        this._hidden = false;
        this._destroy$ = new EventEmitter();
    }
    set hidden(value) {
        this._hidden = value;
        if (this._hidden) {
            this._renderer.setAttribute(this._elRef.nativeElement, 'hidden', 'true');
        }
        else {
            this._renderer.removeAttribute(this._elRef.nativeElement, 'hidden');
        }
    }
    ngOnInit() {
        this.hidden = true;
        if (!this.drawer) {
            console.error('Drawer reference is null for @Input("fsDrawerSide")');
        }
        this._subscribeToActionChanges();
    }
    ngAfterViewInit() {
        setTimeout(() => {
            // Check current side status
            if (this.drawer) {
                this.hidden = !this.drawer.isSideOpen;
            }
            this._updateActiveActionTemplate();
            this._cdRef.detectChanges();
        });
    }
    ngOnDestroy() {
        this._destroy$.emit();
        this._destroy$.complete();
    }
    _subscribeToActionChanges() {
        if (this.drawer) {
            this.drawer.sideToggle$
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this.hidden = !this.drawer.isSideOpen;
                this._updateActiveActionTemplate();
                this._cdRef.detectChanges();
            });
        }
    }
    _updateActiveActionTemplate() {
        if (this.drawer) {
            const activatedAction = this.drawer.activeAction;
            if (this.drawer.isSideOpen && activatedAction) {
                const selectedActionIndex = this.actions
                    .toArray()
                    .findIndex((action) => action.name === activatedAction);
                this.activeTemplate = this.actionsTemplates.toArray()[selectedActionIndex];
            }
            else {
                this.activeTemplate = null;
            }
        }
    }
}
FsDrawerSideComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerSideComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
FsDrawerSideComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerSideComponent, selector: "[fsDrawerSide]", inputs: { drawer: ["fsDrawerSide", "drawer"] }, host: { properties: { "class.side": "this.classSide" } }, queries: [{ propertyName: "actions", predicate: FsDrawerActionDirective }, { propertyName: "actionsTemplates", predicate: FsDrawerActionDirective, read: TemplateRef }], ngImport: i0, template: "<ng-container [ngSwitch]=\"drawer.drawerConfig.position\" *ngIf=\"activeTemplate\">\n  <ng-container *ngSwitchCase=\"'right'\">\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"left\"\n         type=\"side\"\n         [fsDrawerResizer]=\"sideContainer\"\n         [resizable]=\"drawer.drawerConfig.resizable\"\n         [sizeController]=\"drawer.resizeController\"\n         [parentContainer]=\"drawer.drawerContainer\"\n         [actionsContainer]=\"drawer.drawerActionsContainer\"\n    >\n      <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n  </ng-container>\n  <ng-container *ngSwitchCase=\"'left'\">\n    <div class=\"resize-side\"\n         resizable=\"true\"\n         direction=\"right\"\n         [fsDrawerResizer]=\"sideContainer\"\n    >\n    <a mat-icon-button class=\"resize-icon\"><mat-icon>drag_indicator</mat-icon></a>\n    </div>\n    <div class=\"side-container\" #sideContainer>\n      <div class=\"side-content\">\n        <ng-template [ngTemplateOutlet]=\"activeTemplate\"></ng-template>\n      </div>\n    </div>\n  </ng-container>\n</ng-container>\n", styles: [".resize-icon{width:45px;height:45px;line-height:45px}.resize-icon span{width:45px}\n"], components: [{ type: i2$1.MatAnchor, selector: "a[mat-button], a[mat-raised-button], a[mat-icon-button], a[mat-fab],             a[mat-mini-fab], a[mat-stroked-button], a[mat-flat-button]", inputs: ["disabled", "disableRipple", "color", "tabIndex"], exportAs: ["matButton", "matAnchor"] }, { type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5.NgSwitch, selector: "[ngSwitch]", inputs: ["ngSwitch"] }, { type: i5.NgSwitchCase, selector: "[ngSwitchCase]", inputs: ["ngSwitchCase"] }, { type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: FsDrawerResizerDirective, selector: "[fsDrawerResizer]", inputs: ["fsDrawerResizer", "type", "direction", "resizable", "parentContainer", "actionsContainer", "sizeController"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerSideComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDrawerSide]',
                    templateUrl: './drawer-side.component.html',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styleUrls: [
                        './drawer-side.component.scss',
                    ],
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i0.ElementRef }]; }, propDecorators: { drawer: [{
                type: Input,
                args: ['fsDrawerSide']
            }], classSide: [{
                type: HostBinding,
                args: ['class.side']
            }], actions: [{
                type: ContentChildren,
                args: [FsDrawerActionDirective]
            }], actionsTemplates: [{
                type: ContentChildren,
                args: [FsDrawerActionDirective, { read: TemplateRef }]
            }] } });

class FsDrawerContentComponent {
}
FsDrawerContentComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
FsDrawerContentComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: FsDrawerContentComponent, selector: "[fsDrawerContent]", host: { classAttribute: "content-container" }, ngImport: i0, template: '<div class="content"><ng-content></ng-content></div>', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerContentComponent, decorators: [{
            type: Component,
            args: [{
                    selector: '[fsDrawerContent]',
                    template: '<div class="content"><ng-content></ng-content></div>',
                    host: {
                        'class': 'content-container'
                    }
                }]
        }] });

class FsDrawerModule {
}
FsDrawerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
FsDrawerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerModule, declarations: [FsDrawerSideComponent,
        FsDrawerComponent,
        FsDrawerActionsComponent,
        FsDrawerActionItemComponent,
        FsDrawerContentComponent,
        FsDrawerActionDirective,
        FsDrawerResizerDirective,
        FsDrawerMenuComponent], imports: [CommonModule,
        MatTooltipModule,
        MatButtonModule,
        MatIconModule,
        OverlayModule,
        PortalModule,
        FsMenuModule,
        MatMenuModule], exports: [FsDrawerComponent,
        FsDrawerSideComponent,
        FsDrawerContentComponent,
        FsDrawerActionDirective,
        FsDrawerResizerDirective] });
FsDrawerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerModule, imports: [[
            CommonModule,
            MatTooltipModule,
            MatButtonModule,
            MatIconModule,
            OverlayModule,
            PortalModule,
            FsMenuModule,
            MatMenuModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        MatTooltipModule,
                        MatButtonModule,
                        MatIconModule,
                        OverlayModule,
                        PortalModule,
                        FsMenuModule,
                        MatMenuModule,
                    ],
                    exports: [
                        FsDrawerComponent,
                        FsDrawerSideComponent,
                        FsDrawerContentComponent,
                        FsDrawerActionDirective,
                        FsDrawerResizerDirective,
                    ],
                    declarations: [
                        FsDrawerSideComponent,
                        FsDrawerComponent,
                        FsDrawerActionsComponent,
                        FsDrawerActionItemComponent,
                        FsDrawerContentComponent,
                        FsDrawerActionDirective,
                        FsDrawerResizerDirective,
                        FsDrawerMenuComponent,
                    ],
                }]
        }] });

/** Injection token that can be used to access the data that was passed in to a drawer. */
const DRAWER_DATA = new InjectionToken('DrawerData');

const DRAWER_DEFAULT_CONFIG = new InjectionToken('fs.drawer-default-config');

class FsDrawerService {
    constructor(_parentDrawerService, _defaultConfig, _overlay, _injector, _drawerStore) {
        this._parentDrawerService = _parentDrawerService;
        this._defaultConfig = _defaultConfig;
        this._overlay = _overlay;
        this._injector = _injector;
        this._drawerStore = _drawerStore;
        this._destroy$ = new Subject();
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    open(component, config) {
        const overlayRef = this._createOverlay();
        const dataFactory = DrawerData.createWithProxy(config.data);
        delete config.data;
        config = merge({}, this._defaultConfig || {}, config);
        const drawerRef = new DrawerRef(overlayRef, dataFactory, config);
        const containerRef = this._attachDrawerContainer(overlayRef, drawerRef, dataFactory);
        const componentRef = this._attachComponent(component, containerRef, drawerRef, dataFactory);
        drawerRef.containerRef = containerRef;
        containerRef.setDrawerRef(drawerRef);
        drawerRef.componentRef = componentRef;
        drawerRef.events();
        drawerRef.open();
        this._storeDrawerRef(drawerRef);
        merge$1(drawerRef.afterOpened$, drawerRef.afterClosed$)
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            setTimeout(() => {
                this._applyBackdrop();
                this._applyBodyOpenClass();
            });
        });
        return drawerRef;
    }
    closeAll() {
        this._drawerStore.drawerRefs
            .forEach((ref) => ref.close());
        if (this._parentDrawerService) {
            this._parentDrawerService.closeAll();
        }
    }
    _applyBackdrop() {
        Array.from(this._drawerStore.drawerRefs)
            .forEach((drawerRef, index) => {
            const backdrop = drawerRef.overlayRef.backdropElement;
            if (backdrop) {
                if (index && index === (this._drawerStore.numberOfOpenedDrawers - 1)) {
                    backdrop.classList.add('fs-drawer-backdrop-active');
                }
                else {
                    backdrop.classList.remove('fs-drawer-backdrop-active');
                }
            }
        });
    }
    _applyBodyOpenClass() {
        if (this._drawerStore.numberOfOpenedDrawers) {
            document.body.classList.add('fs-drawer-open');
        }
        else {
            document.body.classList.remove('fs-drawer-open');
        }
    }
    _storeDrawerRef(ref) {
        this._drawerStore.addRef(ref);
        ref.destroy$
            .pipe(take(1), takeUntil(this._destroy$))
            .subscribe(() => {
            this._drawerStore.deleteRef(ref);
        });
    }
    _createOverlay() {
        const overlayConfig = this._getOverlayConfig();
        return this._overlay.create(overlayConfig);
    }
    _getOverlayConfig() {
        return new OverlayConfig({
            hasBackdrop: true,
            backdropClass: 'fs-drawer-backdrop'
        });
    }
    _attachDrawerContainer(overlayRef, drawerRef, dataFactory) {
        const injector = this._createInjector(drawerRef, dataFactory);
        const containerPortal = new ComponentPortal(FsDrawerComponent, undefined, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    _attachComponent(componentRef, drawerContainer, drawerRef, dataFactory) {
        const injector = this._createInjector(drawerRef, dataFactory);
        return drawerContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    }
    _createInjector(componentRef, dataFactory) {
        const injectionTokens = new WeakMap([
            [DrawerRef, componentRef],
            [DRAWER_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    }
}
FsDrawerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerService, deps: [{ token: FsDrawerService, optional: true, skipSelf: true }, { token: DRAWER_DEFAULT_CONFIG, optional: true }, { token: i1$1.Overlay }, { token: i0.Injector }, { token: DrawerStoreService }], target: i0.ɵɵFactoryTarget.Injectable });
FsDrawerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: FsDrawerService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DRAWER_DEFAULT_CONFIG]
                }] }, { type: i1$1.Overlay }, { type: i0.Injector }, { type: DrawerStoreService }]; } });

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DRAWER_DATA, DRAWER_DEFAULT_CONFIG, DRAWER_MENU_DATA, DrawerData, DrawerMenuRef, DrawerRef, FsDrawerAction, FsDrawerActionDirective, FsDrawerComponent, FsDrawerContentComponent, FsDrawerModule, FsDrawerResizerDirective, FsDrawerService, FsDrawerSideComponent };
//# sourceMappingURL=firestitch-drawer.js.map
