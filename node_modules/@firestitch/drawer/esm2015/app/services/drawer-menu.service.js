import { ElementRef, Injectable, Injector } from '@angular/core';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';
import { FsDrawerMenuComponent } from '../components/drawer-menu/drawer-menu.component';
import { DrawerMenuRef } from '../classes/drawer-menu-ref';
import { DrawerData } from '../classes/drawer-data';
import { DRAWER_MENU_DATA } from '../services/drawer-menu-data';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/layout";
export class FsDrawerMenuService {
    constructor(_overlay, _injector, _breakpointObserver) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._breakpointObserver = _breakpointObserver;
    }
    create(component, container, config) {
        const overlayRef = this.createOverlay(container);
        const dataFactory = DrawerData.createWithProxy(config.data);
        const menuRef = new DrawerMenuRef(overlayRef, dataFactory);
        const containerRef = this.attachContainer(overlayRef, menuRef, dataFactory);
        const componentRef = this.attachComponent(component, containerRef, menuRef, dataFactory);
        menuRef.containerRef = containerRef;
        containerRef.setDrawerMenuRef(menuRef);
        menuRef.componentRef = componentRef;
        return menuRef;
    }
    createOverlay(container) {
        const overlayConfig = this.getOverlayConfig(container);
        return this._overlay.create(overlayConfig);
    }
    getOverlayConfig(container) {
        const element = new ElementRef(container); // positionStrategy needs ElementRef;
        let strategy = null;
        if (this._breakpointObserver.isMatched(Breakpoints.XSmall)) {
            strategy = this._overlay
                .position()
                .global()
                .centerHorizontally()
                .centerVertically();
        }
        else {
            const positions = [
                { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' }
            ];
            strategy = this._overlay
                .position()
                .flexibleConnectedTo(element)
                .withPositions(positions);
        }
        return new OverlayConfig({
            positionStrategy: strategy,
            scrollStrategy: this._overlay.scrollStrategies.reposition(),
            hasBackdrop: true,
            backdropClass: 'cdk-overlay-transparent-backdrop'
        });
    }
    attachContainer(overlayRef, menuRef, dataFactory) {
        const injector = this.createInjector(menuRef, dataFactory);
        const containerPortal = new ComponentPortal(FsDrawerMenuComponent, undefined, injector);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    attachComponent(componentRef, externalContainer, externalRef, config) {
        const injector = this.createInjector(externalRef, config);
        return externalContainer.attachComponentPortal(new ComponentPortal(componentRef, undefined, injector));
    }
    createInjector(componentRef, dataFactory) {
        const injectionTokens = new WeakMap([
            [DrawerMenuRef, componentRef],
            [DRAWER_MENU_DATA, dataFactory]
        ]);
        return new PortalInjector(this._injector, injectionTokens);
    }
}
FsDrawerMenuService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService, deps: [{ token: i1.Overlay }, { token: i0.Injector }, { token: i2.BreakpointObserver }], target: i0.ɵɵFactoryTarget.Injectable });
FsDrawerMenuService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: FsDrawerMenuService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.Injector }, { type: i2.BreakpointObserver }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLW1lbnUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9hcHAvc2VydmljZXMvZHJhd2VyLW1lbnUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDL0QsT0FBTyxFQUFxQixPQUFPLEVBQUUsYUFBYSxFQUFjLE1BQU0sc0JBQXNCLENBQUM7QUFDN0YsT0FBTyxFQUFFLGVBQWUsRUFBaUIsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckYsT0FBTyxFQUFFLGtCQUFrQixFQUFFLFdBQVcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXRFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGlEQUFpRCxDQUFDO0FBQ3hGLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUMzRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sOEJBQThCLENBQUM7Ozs7QUFJaEUsTUFBTSxPQUFPLG1CQUFtQjtJQUU5QixZQUFvQixRQUFpQixFQUNqQixTQUFtQixFQUNuQixtQkFBdUM7UUFGdkMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUNqQixjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQ25CLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBb0I7SUFDM0QsQ0FBQztJQUVNLE1BQU0sQ0FBQyxTQUE2QixFQUFFLFNBQWtCLEVBQUUsTUFBWTtRQUMzRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pELE1BQU0sV0FBVyxHQUFHLFVBQVUsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVELE1BQU0sT0FBTyxHQUFHLElB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RSxZQUFZLENBQUM7WUFDN0IsQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLENBQUM7U0FDaEMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQzdELENBQUM7O2lIQXBGVSxtQkFBbUI7cUhBQW5CLG1CQUFtQjs0RkFBbkIsbUJBQW1CO2tCQUQvQixVQUFVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtFbGVtZW50UmVmLCBJbmplY3RhYmxlLCBJbmplY3Rvcn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25uZWN0ZWRQb3NpdGlvbiwgT3ZlcmxheSwgT3ZlcmxheUNvbmZpZywgT3ZlcmxheVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCwgQ29tcG9uZW50VHlwZSwgUG9ydGFsSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IEJyZWFrcG9pbnRPYnNlcnZlciwgQnJlYWtwb2ludHMgfSBmcm9tICdAYW5ndWxhci9jZGsvbGF5b3V0JztcblxuaW1wb3J0IHsgRnNEcmF3ZXJNZW51Q29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9kcmF3ZXItbWVudS9kcmF3ZXItbWVudS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJhd2VyTWVudVJlZiB9IGZyb20gJy4uL2NsYXNzZXMvZHJhd2VyLW1lbnUtcmVmJztcbmltcG9ydCB7IERyYXdlckRhdGEgfSBmcm9tICcuLi9jbGFzc2VzL2RyYXdlci1kYXRhJztcbmltcG9ydCB7IERSQVdFUl9NRU5VX0RBVEEgfSBmcm9tICcuLi9zZXJ2aWNlcy9kcmF3ZXItbWVudS1kYXRhJztcblxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRnNEcmF3ZXJNZW51U2VydmljZSB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICAgICAgICBwcml2YXRlIF9icmVha3BvaW50T2JzZXJ2ZXI6IEJyZWFrcG9pbnRPYnNlcnZlcikge1xuICB9XG5cbiAgcHVibGljIGNyZWF0ZShjb21wb25lbnQ6IENvbXBvbmVudFR5cGU8YW55PiwgY29udGFpbmVyOiBFbGVtZW50LCBjb25maWc/OiBhbnkpIHtcbiAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5jcmVhdGVPdmVybGF5KGNvbnRhaW5lcik7XG4gICAgY29uc3QgZGF0YUZhY3RvcnkgPSBEcmF3ZXJEYXRhLmNyZWF0ZVdpdGhQcm94eShjb25maWcuZGF0YSk7XG4gICAgY29uc3QgbWVudVJlZiA9IG5ldyBEcmF3ZXJNZW51UmVmKG92ZXJsYXlSZWYsIGRhdGFGYWN0b3J5KTtcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB0aGlzLmF0dGFjaENvbnRhaW5lcihvdmVybGF5UmVmLCBtZW51UmVmLCBkYXRhRmFjdG9yeSk7XG4gICAgY29uc3QgY29tcG9uZW50UmVmID0gdGhpcy5hdHRhY2hDb21wb25lbnQoY29tcG9uZW50LCBjb250YWluZXJSZWYsIG1lbnVSZWYsIGRhdGFGYWN0b3J5KTtcbiAgICBtZW51UmVmLmNvbnRhaW5lclJlZiA9IGNvbnRhaW5lclJlZjtcbiAgICBjb250YWluZXJSZWYuc2V0RHJhd2VyTWVudVJlZihtZW51UmVmKTtcblxuICAgIG1lbnVSZWYuY29tcG9uZW50UmVmID0gY29tcG9uZW50UmVmO1xuXG4gICAgcmV0dXJuIG1lbnVSZWY7XG4gIH1cblxuICBwcml2YXRlIGNyZWF0ZU92ZXJsYXkoY29udGFpbmVyOiBFbGVtZW50KTogT3ZlcmxheVJlZiB7XG4gICAgY29uc3Qgb3ZlcmxheUNvbmZpZyA9IHRoaXMuZ2V0T3ZlcmxheUNvbmZpZyhjb250YWluZXIpO1xuICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5Q29uZmlnKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0T3ZlcmxheUNvbmZpZyhjb250YWluZXI6IEVsZW1lbnQpOiBPdmVybGF5Q29uZmlnIHtcbiAgICBjb25zdCBlbGVtZW50ID0gbmV3IEVsZW1lbnRSZWYoY29udGFpbmVyKTsgLy8gcG9zaXRpb25TdHJhdGVneSBuZWVkcyBFbGVtZW50UmVmO1xuXG4gICAgbGV0IHN0cmF0ZWd5ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fYnJlYWtwb2ludE9ic2VydmVyLmlzTWF0Y2hlZChCcmVha3BvaW50cy5YU21hbGwpKSB7XG4gICAgICBzdHJhdGVneSA9IHRoaXMuX292ZXJsYXlcbiAgICAgICAgLnBvc2l0aW9uKClcbiAgICAgICAgLmdsb2JhbCgpXG4gICAgICAgIC5jZW50ZXJIb3Jpem9udGFsbHkoKVxuICAgICAgICAuY2VudGVyVmVydGljYWxseSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbnM6IENvbm5lY3RlZFBvc2l0aW9uW10gPSBbXG4gICAgICAgIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2JvdHRvbScsIG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ3RvcCcgfVxuICAgICAgXTtcbiAgICAgIHN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheVxuICAgICAgICAucG9zaXRpb24oKVxuICAgICAgICAuZmxleGlibGVDb25uZWN0ZWRUbyhlbGVtZW50KVxuICAgICAgICAud2l0aFBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgT3ZlcmxheUNvbmZpZyh7XG4gICAgICBwb3NpdGlvblN0cmF0ZWd5OiBzdHJhdGVneSxcbiAgICAgIHNjcm9sbFN0cmF0ZWd5OiAgdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKSxcbiAgICAgIGhhc0JhY2tkcm9wOiB0cnVlLFxuICAgICAgYmFja2Ryb3BDbGFzczogJ2Nkay1vdmVybGF5LXRyYW5zcGFyZW50LWJhY2tkcm9wJ1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRhY2hDb250YWluZXI8VCwgUj4ob3ZlcmxheVJlZjogT3ZlcmxheVJlZiwgbWVudVJlZjogRHJhd2VyTWVudVJlZjxULCBSPiwgZGF0YUZhY3Rvcnk6IERyYXdlckRhdGEpIHtcbiAgICBjb25zdCBpbmplY3RvciA9IHRoaXMuY3JlYXRlSW5qZWN0b3IobWVudVJlZiwgZGF0YUZhY3RvcnkpO1xuICAgIGNvbnN0IGNvbnRhaW5lclBvcnRhbCA9IG5ldyBDb21wb25lbnRQb3J0YWwoRnNEcmF3ZXJNZW51Q29tcG9uZW50LCB1bmRlZmluZWQsIGluamVjdG9yKTtcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSBvdmVybGF5UmVmLmF0dGFjaDxGc0RyYXdlck1lbnVDb21wb25lbnQ+KGNvbnRhaW5lclBvcnRhbCk7XG5cbiAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICB9XG5cbiAgcHJpdmF0ZSBhdHRhY2hDb21wb25lbnQ8VCwgUj4oXG4gICAgY29tcG9uZW50UmVmOiBDb21wb25lbnRUeXBlPFQ+LFxuICAgIGV4dGVybmFsQ29udGFpbmVyOiBGc0RyYXdlck1lbnVDb21wb25lbnQsXG4gICAgZXh0ZXJuYWxSZWY6IERyYXdlck1lbnVSZWY8VCwgUj4sXG4gICAgY29uZmlnOiBhbnksXG4gICkge1xuXG4gICAgY29uc3QgaW5qZWN0b3IgPSB0aGlzLmNyZWF0ZUluamVjdG9yKGV4dGVybmFsUmVmLCBjb25maWcpO1xuXG4gICAgcmV0dXJuIGV4dGVybmFsQ29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbDxUPihcbiAgICAgIG5ldyBDb21wb25lbnRQb3J0YWw8VD4oY29tcG9uZW50UmVmLCB1bmRlZmluZWQsIGluamVjdG9yKVxuICAgICk7XG4gIH1cblxuXG4gIHByaXZhdGUgY3JlYXRlSW5qZWN0b3IoY29tcG9uZW50UmVmLCBkYXRhRmFjdG9yeTogRHJhd2VyRGF0YSkge1xuICAgIGNvbnN0IGluamVjdGlvblRva2VucyA9IG5ldyBXZWFrTWFwPGFueSwgYW55PihbXG4gICAgICBbRHJhd2VyTWVudVJlZiwgY29tcG9uZW50UmVmXSxcbiAgICAgIFtEUkFXRVJfTUVOVV9EQVRBLCBkYXRhRmFjdG9yeV1cbiAgICBdKTtcblxuICAgIHJldHVybiBuZXcgUG9ydGFsSW5qZWN0b3IodGhpcy5faW5qZWN0b3IsIGluamVjdGlvblRva2Vucyk7XG4gIH1cbn1cbiJdfQ==