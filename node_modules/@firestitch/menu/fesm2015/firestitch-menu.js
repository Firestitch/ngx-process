import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, Inject, Directive, ContentChildren, EventEmitter, TemplateRef, Optional, SkipSelf, Output, ContentChild, ViewChild, Self, NgModule } from '@angular/core';
import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1 from '@angular/material/bottom-sheet';
import { MAT_BOTTOM_SHEET_DATA, MatBottomSheetModule } from '@angular/material/bottom-sheet';
import * as i3$1 from '@angular/material/button';
import { MatButtonModule } from '@angular/material/button';
import * as i4 from '@angular/material/icon';
import { MatIconModule } from '@angular/material/icon';
import * as i1$1 from '@angular/material/list';
import { MatListModule } from '@angular/material/list';
import * as i2$1 from '@angular/material/menu';
import { MatMenuTrigger, MAT_MENU_SCROLL_STRATEGY, MatMenuModule } from '@angular/material/menu';
import * as i3 from '@angular/router';
import { RouterModule } from '@angular/router';
import * as i2$2 from '@angular/cdk/layout';
import { merge, Subject } from 'rxjs';
import { take, takeUntil, debounceTime } from 'rxjs/operators';
import * as i3$2 from '@angular/cdk/bidi';
import * as i1$2 from '@angular/cdk/overlay';
import * as i4$1 from '@angular/cdk/a11y';

function createItemsObserver(data) {
    const itemsObservables = data.reduce((acc, item) => {
        if (item.itemChange$) {
            acc.push(item.itemChange$);
        }
        return acc;
    }, []);
    return merge(...itemsObservables);
}

class BottomItemsListComponent {
    constructor(_bottomSheetRef, _cdRef) {
        this._bottomSheetRef = _bottomSheetRef;
        this._cdRef = _cdRef;
        this._destroy$ = new Subject();
        this._cdRef.detach();
    }
    ngOnInit() {
        this._cdRef.detectChanges();
    }
    ngOnChanges(changes) {
        if (changes.items) {
            this._destroy$.next();
            this.subscribeToChanges();
        }
    }
    /**
     * For improve ngFor perf
     * @param index
     */
    trackBy(index) {
        return index;
    }
    /**
     * Click on element
     * @param event
     * @param item
     */
    click(event, item) {
        event.preventDefault();
        const subscription = this._bottomSheetRef.afterDismissed()
            .pipe(take(1))
            .subscribe(() => {
            if (item === null || item === void 0 ? void 0 : item.click) {
                item.click(event);
            }
            subscription.unsubscribe();
        });
        if (item === null || item === void 0 ? void 0 : item.dismissAfterClick) {
            this._bottomSheetRef.dismiss();
        }
    }
    /**
     * Subscribe to changes in directive parameters.
     * For example we must start detect changes if [hidden] param was changed
     */
    subscribeToChanges() {
        if (this.items && this.items.length) {
            createItemsObserver(this.items)
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this._cdRef.detectChanges();
            });
        }
    }
}
/** @nocollapse */ BottomItemsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: BottomItemsListComponent, deps: [{ token: i1.MatBottomSheetRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ BottomItemsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.13", type: BottomItemsListComponent, selector: "fs-bottom-items-list", inputs: { items: "items", parentVisible: "parentVisible" }, usesOnChanges: true, ngImport: i0, template: "<ng-container *ngFor=\"let item of items; trackBy: trackBy\">\n  <ng-container *ngIf=\"item.isGroup else menuItem\">\n    <div class=\"mat-menu-item\" [hidden]=\"!item.visible\" disabled>\n      <ng-container *ngIf=\"!!item.label; else tpl\">\n        {{ item.label }}\n      </ng-container>\n      <ng-template #tpl\n                   [ngTemplateOutlet]=\"item.groupItemTemplateRef\">\n      </ng-template>\n    </div>\n    <fs-bottom-items-list [items]=\"item.childrenItems\"\n                          [hidden]=\"!item.visible\"\n                          [parentVisible]=\"item.visible\"\n                          class=\"group\">\n    </fs-bottom-items-list>\n  </ng-container>\n  <ng-template #menuItem>\n    <ng-container *ngIf=\"item.visible\">\n      <ng-container *ngIf=\"item.link; else btnLikeAction\">\n        <a (click)=\"click($event, item)\"\n           [routerLink]=\"item.link\"\n           [queryParams]=\"item.queryParams\"\n           [target]=\"item.target\"\n           [class]=\"'mat-menu-item ' + item.cssClass\"\n           [ngClass]=\"item.ngClass\"\n           [id]=\"item.cssId\"\n        >\n          <ng-template [ngTemplateOutlet]=\"item.templateRef\"></ng-template>\n        </a>\n      </ng-container>\n      <ng-template #btnLikeAction>\n        <a (click)=\"click($event, item)\"\n           [class]=\"'mat-menu-item ' + item.cssClass\"\n           [ngClass]=\"item.ngClass\"\n           [id]=\"item.cssId\"\n        >\n          <ng-template [ngTemplateOutlet]=\"item.templateRef\"></ng-template>\n        </a>\n      </ng-template>\n    </ng-container>\n  </ng-template>\n</ng-container>\n", styles: ["fs-bottom-items-list a.mat-menu-item{padding:0 32px}\n"], components: [{ type: BottomItemsListComponent, selector: "fs-bottom-items-list", inputs: ["items", "parentVisible"] }], directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: BottomItemsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-bottom-items-list',
                    templateUrl: './bottom-items-list.component.html',
                    styleUrls: ['./bottom-items-list.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.MatBottomSheetRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { items: [{
                type: Input
            }], parentVisible: [{
                type: Input
            }] } });

class FsBottomSheetComponent {
    constructor(data, _cd) {
        this.data = data;
        this._cd = _cd;
    }
    ngOnInit() {
        this._cd.detectChanges();
    }
}
/** @nocollapse */ FsBottomSheetComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsBottomSheetComponent, deps: [{ token: MAT_BOTTOM_SHEET_DATA }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ FsBottomSheetComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.13", type: FsBottomSheetComponent, selector: "fs-bottom-sheet", ngImport: i0, template: "<mat-nav-list class=\"{{ data.klass }}\">\n  <div class=\"fs-menu-title\" *ngIf=\"data.titleTemplate\">\n    <ng-template [ngTemplateOutlet]=\"data.titleTemplate\"></ng-template>\n  </div>\n  <div class=\"fs-menu-container\" [ngClass]=\"{ 'with-title': !!data.titleTemplate }\">\n    <fs-bottom-items-list [items]=\"data.items\"></fs-bottom-items-list>\n  </div>\n</mat-nav-list>\n", styles: [".mat-list-base{padding-top:0;margin:0 -16px}\n"], components: [{ type: i1$1.MatNavList, selector: "mat-nav-list", inputs: ["disableRipple", "disabled"], exportAs: ["matNavList"] }, { type: BottomItemsListComponent, selector: "fs-bottom-items-list", inputs: ["items", "parentVisible"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsBottomSheetComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-bottom-sheet',
                    templateUrl: './fs-bottom-sheet.component.html',
                    styleUrls: ['./fs-bottom-sheet.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_BOTTOM_SHEET_DATA]
                }] }, { type: i0.ChangeDetectorRef }]; } });

class FsGroupMenuItemTemplateDirective {
}
/** @nocollapse */ FsGroupMenuItemTemplateDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsGroupMenuItemTemplateDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ FsGroupMenuItemTemplateDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: FsGroupMenuItemTemplateDirective, selector: "[fs-group-menu-item-template]", queries: [{ propertyName: "groupMenuItemTemplateRef", predicate: FsGroupMenuItemTemplateDirective }], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsGroupMenuItemTemplateDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fs-group-menu-item-template]'
                }]
        }], propDecorators: { groupMenuItemTemplateRef: [{
                type: ContentChildren,
                args: [FsGroupMenuItemTemplateDirective]
            }] } });

class FsMenuItemDirective {
    constructor(cd, templateRef, parent) {
        this.cd = cd;
        this.templateRef = templateRef;
        this.parent = parent;
        this.ngClass = [];
        this.cssClass = '';
        this.cssId = '';
        this.hidden = false;
        this.dismissAfterClick = true;
        this.target = null;
        this.queryParams = {};
        this.click$ = new EventEmitter();
        this.itemChange$ = new Subject();
        this._isGroup = false;
    }
    set itemsElements(value) {
        this.childrenItems = value.toArray()
            .filter((child) => child !== this);
        this._isGroup = !!this.childrenItems;
        this.checkChildrenVisibility();
        this.itemChange$.next();
    }
    get isGroup() {
        return this._isGroup;
    }
    get visible() {
        if (this.groupHidden !== void 0) {
            return !this.groupHidden;
        }
        else {
            return !this.hidden;
        }
    }
    get groupItemTemplateRef() {
        return this._groupItemTemplateRef;
    }
    ngOnChanges(changes) {
        if (!this.isGroup && this.parent && changes.hidden && !changes.hidden.firstChange) {
            this.parent.checkChildrenVisibility();
        }
        this.itemChange$.next();
    }
    checkChildrenVisibility() {
        if (this.childrenItems) {
            this.hidden = this.childrenItems.every((item) => item.hidden);
        }
    }
    ngOnDestroy() {
        this.itemChange$.complete();
    }
    click(event) {
        this.click$.next(event);
    }
}
/** @nocollapse */ FsMenuItemDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuItemDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.TemplateRef, optional: true }, { token: FsMenuItemDirective, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ FsMenuItemDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: FsMenuItemDirective, selector: "fs-menu-group,[fs-menu-item]", inputs: { ngClass: ["fsClass", "ngClass"], cssClass: ["class", "cssClass"], cssId: ["id", "cssId"], label: "label", hidden: "hidden", groupHidden: "groupHidden", dismissAfterClick: "dismissAfterClick", link: "link", target: "target", queryParams: "queryParams" }, outputs: { click$: "click" }, queries: [{ propertyName: "_groupItemTemplateRef", first: true, predicate: FsGroupMenuItemTemplateDirective, descendants: true, read: TemplateRef }, { propertyName: "itemsElements", predicate: FsMenuItemDirective }], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuItemDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'fs-menu-group,[fs-menu-item]'
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: FsMenuItemDirective, decorators: [{
                    type: SkipSelf
                }, {
                    type: Optional
                }] }]; }, propDecorators: { ngClass: [{
                type: Input,
                args: ['fsClass']
            }], cssClass: [{
                type: Input,
                args: ['class']
            }], cssId: [{
                type: Input,
                args: ['id']
            }], label: [{
                type: Input
            }], hidden: [{
                type: Input
            }], groupHidden: [{
                type: Input
            }], dismissAfterClick: [{
                type: Input
            }], link: [{
                type: Input
            }], target: [{
                type: Input
            }], queryParams: [{
                type: Input
            }], click$: [{
                type: Output,
                args: ['click']
            }], itemsElements: [{
                type: ContentChildren,
                args: [FsMenuItemDirective]
            }], _groupItemTemplateRef: [{
                type: ContentChild,
                args: [FsGroupMenuItemTemplateDirective, { read: TemplateRef }]
            }] } });

class FsMenuTitleDirective {
}
/** @nocollapse */ FsMenuTitleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuTitleDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ FsMenuTitleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: FsMenuTitleDirective, selector: "[fs-menu-title]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuTitleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fs-menu-title]'
                }]
        }] });

class MenuItemsListComponent {
    constructor(_cdRef) {
        this._cdRef = _cdRef;
        this._destroy$ = new Subject();
    }
    ngOnChanges(changes) {
        if (changes.items) {
            this._cdRef.detectChanges();
            this._destroy$.next();
            this.subscribeToChanges();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    /**
     * For improve ngFor perf
     * @param index
     */
    trackBy(index) {
        return index;
    }
    /**
     * Subscribe to changes in directive parameters.
     * For example we must start detect changes if [hidden] param was changed
     */
    subscribeToChanges() {
        if (this.items && this.items.length) {
            createItemsObserver(this.items)
                .pipe(takeUntil(this._destroy$))
                .subscribe(() => {
                this._cdRef.detectChanges();
            });
        }
    }
}
/** @nocollapse */ MenuItemsListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: MenuItemsListComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ MenuItemsListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.13", type: MenuItemsListComponent, selector: "fs-menu-items-list", inputs: { items: "items", parentVisible: "parentVisible" }, usesOnChanges: true, ngImport: i0, template: "<ng-container *ngFor=\"let item of items; trackBy: trackBy\">\n  <ng-container *ngIf=\"item.isGroup; else menuItem\">\n    <div class=\"fs-menu-groupped-list\" [hidden]=\"!item.visible\">\n      <div class=\"mat-menu-item fs-menu-group-label\" disabled>\n        <ng-container *ngIf=\"!!item.label; else tpl\">\n          {{ item.label }}\n        </ng-container>\n        <ng-template #tpl\n                     [ngTemplateOutlet]=\"item.groupItemTemplateRef\">\n        </ng-template>\n      </div>\n      <fs-menu-items-list [items]=\"item.childrenItems\"\n                          [parentVisible]=\"item.visible\">\n      </fs-menu-items-list>\n    </div>\n  </ng-container>\n  <ng-template #menuItem>\n    <ng-container *ngIf=\"item.link; else btn\">\n      <a\n        mat-menu-item\n        *ngIf=\"item.visible\"\n        [routerLink]=\"item.link\"\n        [queryParams]=\"item.queryParams\"\n        [target]=\"item.target\"\n        (click)=\"item.click($event)\"\n        [class]=\"item.cssClass\"\n        [ngClass]=\"item.ngClass\"\n        [id]=\"item.cssId\">\n        <ng-template [ngTemplateOutlet]=\"item.templateRef\"></ng-template>\n      </a>\n    </ng-container>\n    <ng-template #btn>\n      <button type=\"button\"\n              mat-menu-item\n              *ngIf=\"item.visible\"\n              (click)=\"item.click($event)\"\n              [class]=\"item.cssClass\"\n              [ngClass]=\"item.ngClass\"\n              [id]=\"item.cssId\"\n      >\n        <ng-template [ngTemplateOutlet]=\"item.templateRef\"></ng-template>\n      </button>\n    </ng-template>\n  </ng-template>\n</ng-container>\n", styles: [":host ::ng-deep .fs-menu-groupped-list a,:host ::ng-deep .fs-menu-groupped-list button{padding-left:32px}\n"], components: [{ type: MenuItemsListComponent, selector: "fs-menu-items-list", inputs: ["items", "parentVisible"] }, { type: i2$1.MatMenuItem, selector: "[mat-menu-item]", inputs: ["disabled", "disableRipple", "role"], exportAs: ["matMenuItem"] }], directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i3.RouterLinkWithHref, selector: "a[routerLink],area[routerLink]", inputs: ["routerLink", "target", "queryParams", "fragment", "queryParamsHandling", "preserveFragment", "skipLocationChange", "replaceUrl", "state", "relativeTo"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: MenuItemsListComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-menu-items-list',
                    templateUrl: './menu-items-list.component.html',
                    styleUrls: ['./menu-items-list.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { items: [{
                type: Input
            }], parentVisible: [{
                type: Input
            }] } });

class FsMenuComponent {
    constructor(_bottomSheet, _breakpointObserver, _cd) {
        this._bottomSheet = _bottomSheet;
        this._breakpointObserver = _breakpointObserver;
        this._cd = _cd;
        this.klass = null;
        this.buttonClass = '';
        this.opened = new EventEmitter();
        this.closed = new EventEmitter();
        // Items with TemplateRefs and DirectiveRef for passing to bottomSheet
        this.items = [];
        this.useInternalTrigger = false;
        this.mobile = false;
        this.menuOpened = false;
        this.initialized = false;
        this._resolutionChanged = false;
        // Active bottom sheet that was opened
        this._activeSheetRef = null;
        this._destroy$ = new Subject();
        this._cd.detach();
    }
    set itemsElements(value) {
        this.items = value.toArray();
    }
    // Catch trigger for matMenu
    set internalMatMenuTrigger(val) {
        if (val) {
            this.useInternalTrigger = true;
        }
        this._internalMatMenuTrigger = val;
    }
    ;
    set externalMatMenuTrigger(val) {
        this.useInternalTrigger = false;
        this._externalMatMenuTrigger = val;
        this._cd.detectChanges();
    }
    set resolutionChanged(val) {
        this._resolutionChanged = val;
    }
    get resolutionChanged() {
        return this._resolutionChanged;
    }
    get matMenuTrigger() {
        if (this.useInternalTrigger) {
            return this._internalMatMenuTrigger;
        }
        else {
            return this._externalMatMenuTrigger;
        }
    }
    ngOnInit() {
        this.subscribeToResChanges();
        this.initialized = true;
        this._cd.detectChanges();
    }
    ngAfterViewInit() {
        if (!this._externalMatMenuTrigger) {
            this.useInternalTrigger = true;
            this._cd.detectChanges();
        }
    }
    ngOnDestroy() {
        this._destroy$.next();
        this._destroy$.complete();
    }
    /**
     * Subscribe to window resolution changes
     * and switch between mobile and desktop
     */
    subscribeToResChanges() {
        const layoutChanges = this._breakpointObserver.observe([
            FsMenuComponent.MOBILE_BREAKPOINT,
        ]);
        layoutChanges
            .pipe(debounceTime(500), takeUntil(this._destroy$))
            .subscribe(result => {
            // Set mobile/desktop flag
            this.mobile = result.breakpoints[FsMenuComponent.MOBILE_BREAKPOINT];
            if (this.menuOpened) {
                // Flag that menus was closed not by user
                this.resolutionChanged = true;
                if (this.mobile) {
                    this.closeMatMenu();
                    this.openSheetMenu();
                }
                else {
                    this.closeSheetMenu();
                    // Must be here because we should wait till menuTrigger will be catched by @ViewChild
                    setTimeout(() => {
                        if (this.matMenuTrigger) {
                            this.matMenuTrigger.openMenu();
                            // Detect changes because for strategies like OnPush if won't detected by default
                            this._cd.detectChanges();
                        }
                    });
                }
                // Detect changes because for strategies like OnPush if won't detected by default
                this._cd.detectChanges();
            }
            else {
                // Detect changes because for strategies like OnPush if won't detected by default
                this._cd.detectChanges();
            }
        });
    }
    /**
     * Open fs menu depends from mode
     */
    openMenu() {
        if (this.mobile) {
            this.openSheetMenu();
        }
        else {
            this.openMatMenu();
        }
        this.opened.emit();
        this._cd.detectChanges();
    }
    /**
     * Close fs menu depends from mode
     */
    closeMenu() {
        if (this.mobile) {
            this.closeSheetMenu();
        }
        else {
            this.closeMatMenu();
        }
    }
    /**
     * Open Mat Menu
     */
    openMatMenu() {
        this.menuOpened = true;
        this.resolutionChanged = false;
        this.matMenuTrigger.openMenu();
    }
    /**
     * Close Mat Menu
     */
    closeMatMenu() {
        if (this.matMenuTrigger) {
            this.matMenuTrigger.closeMenu();
        }
    }
    /**
     * After menu close event
     */
    closedMatMenu() {
        if (!this.resolutionChanged) {
            this.menuOpened = false;
        }
        this.resolutionChanged = false;
        this.closed.emit();
    }
    /**
     * Open Mat Bottom Sheet
     */
    openSheetMenu() {
        this._activeSheetRef = this._bottomSheet.open(FsBottomSheetComponent, {
            data: { items: this.items, titleTemplate: this.titleTemplate, klass: this.klass }
        });
        this.menuOpened = true;
        this._activeSheetRef.afterDismissed()
            .pipe(takeUntil(this._destroy$))
            .subscribe(() => {
            if (!this.resolutionChanged) {
                this.menuOpened = false;
            }
            this.resolutionChanged = false;
        });
    }
    /**
     * Close Mat Bottom Sheet
     */
    closeSheetMenu() {
        if (this._activeSheetRef) {
            this._activeSheetRef.dismiss();
        }
    }
}
FsMenuComponent.MOBILE_BREAKPOINT = '(max-width: 599px)';
/** @nocollapse */ FsMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuComponent, deps: [{ token: i1.MatBottomSheet }, { token: i2$2.BreakpointObserver }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
/** @nocollapse */ FsMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.13", type: FsMenuComponent, selector: "fs-menu", inputs: { klass: ["class", "klass"], buttonClass: "buttonClass" }, outputs: { opened: "opened", closed: "closed" }, queries: [{ propertyName: "titleTemplate", first: true, predicate: FsMenuTitleDirective, descendants: true, read: TemplateRef }, { propertyName: "itemsElements", predicate: FsMenuItemDirective }], viewQueries: [{ propertyName: "internalMatMenuTrigger", first: true, predicate: MatMenuTrigger, descendants: true }, { propertyName: "fsMenuRef", first: true, predicate: ["fsMenu"], descendants: true, static: true }], ngImport: i0, template: "<ng-template [ngIf]=\"!mobile\" [ngIfElse]=\"sheetMenu\">\n  <button type=\"button\"\n          [ngClass]=\"buttonClass\"\n          mat-icon-button\n          *ngIf=\"useInternalTrigger\"\n          [matMenuTriggerFor]=\"fsMenu\"\n          #menuTrigger=\"matMenuTrigger\"\n          (click)=\"openMenu()\"\n  >\n    <mat-icon>more_vert</mat-icon>\n  </button>\n</ng-template>\n\n<ng-template #sheetMenu>\n  <button type=\"button\"\n          mat-icon-button\n          [ngClass]=\"buttonClass\"\n          *ngIf=\"useInternalTrigger\"\n          (click)=\"openMenu()\">\n    <mat-icon>more_vert</mat-icon>\n  </button>\n</ng-template>\n\n\n<mat-menu #fsMenu=\"matMenu\" [class]=\"klass\" (close)=\"closedMatMenu()\">\n  <div class=\"mat-menu-item fs-menu-title\" *ngIf=\"titleTemplate\" disabled>\n    <ng-template [ngTemplateOutlet]=\"titleTemplate\"></ng-template>\n  </div>\n  <div class=\"fs-menu-container\" [ngClass]=\"{ 'with-title': !!titleTemplate }\">\n    <fs-menu-items-list [items]=\"items\"></fs-menu-items-list>\n  </div>\n</mat-menu>\n", styles: ["::ng-deep *[hidden]{display:none!important}\n"], components: [{ type: i3$1.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i2$1.MatMenu, selector: "mat-menu", exportAs: ["matMenu"] }, { type: MenuItemsListComponent, selector: "fs-menu-items-list", inputs: ["items", "parentVisible"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i2$1.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", exportAs: ["matMenuTrigger"] }, { type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'fs-menu',
                    templateUrl: 'fs-menu.component.html',
                    styleUrls: ['fs-menu.component.scss'],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.MatBottomSheet }, { type: i2$2.BreakpointObserver }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { klass: [{
                type: Input,
                args: ['class']
            }], buttonClass: [{
                type: Input,
                args: ['buttonClass']
            }], opened: [{
                type: Output
            }], closed: [{
                type: Output
            }], titleTemplate: [{
                type: ContentChild,
                args: [FsMenuTitleDirective, { read: TemplateRef }]
            }], itemsElements: [{
                type: ContentChildren,
                args: [FsMenuItemDirective]
            }], internalMatMenuTrigger: [{
                type: ViewChild,
                args: [MatMenuTrigger]
            }], fsMenuRef: [{
                type: ViewChild,
                args: ['fsMenu', { static: true }]
            }] } });

class FsMenuTriggerDirective extends MatMenuTrigger {
    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor) {
        super(_overlay, _element, _viewContainerRef, scrollStrategy, _parentMenu, _menuItemInstance, _dir, _focusMonitor);
        this.fsMenu = null;
    }
    ngOnInit() {
        this.menu = this.fsMenu.fsMenuRef;
        this.fsMenu.externalMatMenuTrigger = this;
    }
    _handleKeydown(event) {
        this._triggerClick();
    }
    /** Handles click events on the trigger. */
    _handleClick(event) {
        this._triggerClick();
    }
    _triggerClick() {
        if (this.fsMenu.menuOpened) {
            this.fsMenu.closeMenu();
        }
        else {
            this.fsMenu.openMenu();
        }
    }
}
/** @nocollapse */ FsMenuTriggerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuTriggerDirective, deps: [{ token: i1$2.Overlay }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: MAT_MENU_SCROLL_STRATEGY }, { token: i2$1.MatMenu, optional: true }, { token: i2$1.MatMenuItem, optional: true, self: true }, { token: i3$2.Directionality, optional: true }, { token: i4$1.FocusMonitor }], target: i0.ɵɵFactoryTarget.Directive });
/** @nocollapse */ FsMenuTriggerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.13", type: FsMenuTriggerDirective, selector: "[fsMenuTriggerFor]", inputs: { fsMenu: ["fsMenuTriggerFor", "fsMenu"] }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[fsMenuTriggerFor]',
                }]
        }], ctorParameters: function () { return [{ type: i1$2.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [MAT_MENU_SCROLL_STRATEGY]
                }] }, { type: i2$1.MatMenu, decorators: [{
                    type: Optional
                }] }, { type: i2$1.MatMenuItem, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i3$2.Directionality, decorators: [{
                    type: Optional
                }] }, { type: i4$1.FocusMonitor }]; }, propDecorators: { fsMenu: [{
                type: Input,
                args: ['fsMenuTriggerFor']
            }] } });

class FsMenuModule {
    static forRoot() {
        return {
            ngModule: FsMenuModule
        };
    }
}
/** @nocollapse */ FsMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ FsMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuModule, declarations: [FsMenuComponent,
        FsBottomSheetComponent,
        MenuItemsListComponent,
        BottomItemsListComponent,
        FsMenuItemDirective,
        FsMenuTriggerDirective,
        FsMenuTitleDirective,
        FsGroupMenuItemTemplateDirective], imports: [CommonModule,
        RouterModule,
        MatButtonModule,
        MatIconModule,
        MatMenuModule,
        MatBottomSheetModule,
        MatListModule], exports: [FsMenuComponent,
        FsMenuItemDirective,
        FsMenuTriggerDirective,
        FsMenuTitleDirective,
        FsGroupMenuItemTemplateDirective] });
/** @nocollapse */ FsMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuModule, imports: [[
            CommonModule,
            RouterModule,
            MatButtonModule,
            MatIconModule,
            MatMenuModule,
            MatBottomSheetModule,
            MatListModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.13", ngImport: i0, type: FsMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        RouterModule,
                        MatButtonModule,
                        MatIconModule,
                        MatMenuModule,
                        MatBottomSheetModule,
                        MatListModule,
                    ],
                    exports: [
                        FsMenuComponent,
                        FsMenuItemDirective,
                        FsMenuTriggerDirective,
                        FsMenuTitleDirective,
                        FsGroupMenuItemTemplateDirective,
                    ],
                    declarations: [
                        FsMenuComponent,
                        FsBottomSheetComponent,
                        MenuItemsListComponent,
                        BottomItemsListComponent,
                        FsMenuItemDirective,
                        FsMenuTriggerDirective,
                        FsMenuTitleDirective,
                        FsGroupMenuItemTemplateDirective,
                    ]
                }]
        }] });

/*
 * Public API Surface of fs-menu
 */

/**
 * Generated bundle index. Do not edit.
 */

export { FsGroupMenuItemTemplateDirective, FsMenuComponent, FsMenuItemDirective, FsMenuModule, FsMenuTitleDirective, FsMenuTriggerDirective };
//# sourceMappingURL=firestitch-menu.js.map
